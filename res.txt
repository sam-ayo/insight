
> insight@1.0.0 start
> ts-node main.ts

URL:  https://react.dev/
[
  'The library for web and native user interfaces',
  'React lets you build user interfaces out of individual pieces called components. Create your own React components like Thumbnail, LikeButton, and Video. Then combine them into entire screens, pages, and apps.',
  'Video description',
  'Whether you work on your own or with thousands of other developers, using React feels the same. It is designed to let you seamlessly combine components written by independent people, teams, and organizations.',
  'React components are JavaScript functions. Want to show some content conditionally? Use an if statement. Displaying a list? Try array map(). Learning React is learning programming.',
  'Video description',
  'Video description',
  'Video description',
  'This markup syntax is called JSX. It is a JavaScript syntax extension popularized by React. Putting JSX markup close to related rendering logic makes React components easy to create, maintain, and delete.',
  'React components receive data and return what should appear on the screen. You can pass them new data in response to an interaction, like when the user types into an input. React will then update the screen to match the new data.',
  'A brief history of React',
  'The origin story of React',
  'Pete Hunt (2013)',
  'Tom Occhino (2015)',
  'Sophie Alpert and Dan Abramov (2018)',
  'Dan Abramov and Lauren Tan (2020)',
  'You don’t have to build your whole page in React. Add React to your existing HTML page, and render interactive React components anywhere on it.',
  'React is a library. It lets you put components together, but it doesn’t prescribe how to do routing and data fetching. To build an entire app with React, we recommend a full-stack React framework like Next.js or Remix.',
  'The React Team',
  'Shruti Kapoor',
  'Shaundai Person',
  'Aakansha Doshi',
  'Brian Vaughn',
  'Xuan Huang (黄玄)',
  'Rachel Nabors',
  "Debbie O'Brien",
  'Sarah Rainsberger',
  'Linton Ye',
  'Delba de Oliveira',
  'Robert Balicki',
  'Eric Rozell and Steven Moyes',
  'Roman Rädle',
  'Daishi Kato',
  'Diego Haz',
  'Tafu Nakazaki',
  'Lyle Troxell',
  'Helen Lin',
  'React is also an architecture. Frameworks that implement it let you fetch data in asynchronous components that run on the server or even during the build. Read data from a file or a database, and pass it down to your interactive components.',
  'People love web and native apps for different reasons. React lets you build both web apps and native apps using the same skills. It leans upon each platform’s unique strengths to let your interfaces feel just right on every platform.',
  'People expect web app pages to load fast. On the server, React lets you start streaming HTML while you’re still fetching data, progressively filling in the remaining content before any JavaScript code loads. On the client, React can use standard web APIs to keep your UI responsive even in the middle of rendering.',
  'People expect native apps to look and feel like their platform. React Native and Expo let you build apps in React for Android, iOS, and more. They look and feel native because their UIs are truly native. It’s not a web view—your React components render real Android and iOS views provided by the platform.',
  'With React, you can be a web and a native developer. Your team can ship to many platforms without sacrificing the user experience. Your organization can bridge the platform silos, and form teams that own entire features end-to-end.',
  'React approaches changes with care. Every React commit is tested on business-critical surfaces with over a billion users. Over 100,000 React components at Meta help validate every migration strategy.',
  'The React team is always researching how to improve React. Some research takes years to pay off. React has a high bar for taking a research idea into production. Only proven approaches become a part of React.',
  'Latest React News',
  'You’re not alone. Two million developers from all over the world visit the React docs every month. React is something that people and teams can agree on.',
  'This is why React is more than a library, an architecture, or even an ecosystem. React is a community. It’s a place where you can ask for help, find opportunities, and meet new friends. You will meet both developers and designers, beginners and experts, researchers and artists, teachers and students. Our backgrounds may be very different, but React lets us all create user interfaces together.'
]
URL:  https://react.dev/learn
[
  'Is this page useful?',
  'Welcome to the React documentation! This page will give you an introduction to the 80% of React concepts that you will use on a daily basis.',
  'React apps are made out of components. A component is a piece of the UI (user interface) that has its own logic and appearance. A component can be as small as a button, or as large as an entire page.',
  'React components are JavaScript functions that return markup:',
  'Now that you’ve declared MyButton, you can nest it into another component:',
  'Notice that <MyButton /> starts with a capital letter. That’s how you know it’s a React component. React component names must always start with a capital letter, while HTML tags must be lowercase.',
  'Have a look at the result:',
  'The export default keywords specify the main component in the file. If you’re not familiar with some piece of JavaScript syntax, MDN and javascript.info have great references.',
  'The markup syntax you’ve seen above is called JSX. It is optional, but most React projects use JSX for its convenience. All of the tools we recommend for local development support JSX out of the box.',
  'JSX is stricter than HTML. You have to close tags like <br />. Your component also can’t return multiple JSX tags. You have to wrap them into a shared parent, like a <div>...</div> or an empty <>...</> wrapper:',
  'If you have a lot of HTML to port to JSX, you can use an online converter.',
  'In React, you specify a CSS class with className. It works the same way as the HTML class attribute:',
  'Then you write the CSS rules for it in a separate CSS file:',
  'React does not prescribe how you add CSS files. In the simplest case, you’ll add a <link> tag to your HTML. If you use a build tool or a framework, consult its documentation to learn how to add a CSS file to your project.',
  'JSX lets you put markup into JavaScript. Curly braces let you “escape back” into JavaScript so that you can embed some variable from your code and display it to the user. For example, this will display user.name:',
  'You can also “escape into JavaScript” from JSX attributes, but you have to use curly braces instead of quotes. For example, className="avatar" passes the "avatar" string as the CSS class, but src={user.imageUrl} reads the JavaScript user.imageUrl variable value, and then passes that value as the src attribute:',
  'You can put more complex expressions inside the JSX curly braces too, for example, string concatenation:',
  'In the above example, style={{}} is not a special syntax, but a regular {} object inside the style={ } JSX curly braces. You can use the style attribute when your styles depend on JavaScript variables.',
  'In React, there is no special syntax for writing conditions. Instead, you’ll use the same techniques as you use when writing regular JavaScript code. For example, you can use an if statement to conditionally include JSX:',
  'If you prefer more compact code, you can use the conditional ? operator. Unlike if, it works inside JSX:',
  'When you don’t need the else branch, you can also use a shorter logical && syntax:',
  'All of these approaches also work for conditionally specifying attributes. If you’re unfamiliar with some of this JavaScript syntax, you can start by always using if...else.',
  'You will rely on JavaScript features like for loop and the array map() function to render lists of components.',
  'For example, let’s say you have an array of products:',
  'Inside your component, use the map() function to transform an array of products into an array of <li> items:',
  'Notice how <li> has a key attribute. For each item in a list, you should pass a string or a number that uniquely identifies that item among its siblings. Usually, a key should be coming from your data, such as a database ID. React uses your keys to know what happened if you later insert, delete, or reorder the items.',
  'You can respond to events by declaring event handler functions inside your components:',
  'Notice how onClick={handleClick} has no parentheses at the end! Do not call the event handler function: you only need to pass it down. React will call your event handler when the user clicks the button.',
  'Often, you’ll want your component to “remember” some information and display it. For example, maybe you want to count the number of times a button is clicked. To do this, add state to your component.',
  'First, import useState from React:',
  'Now you can declare a state variable inside your component:',
  'You’ll get two things from useState: the current state (count), and the function that lets you update it (setCount). You can give them any names, but the convention is to write [something, setSomething].',
  'The first time the button is displayed, count will be 0 because you passed 0 to useState(). When you want to change state, call setCount() and pass the new value to it. Clicking this button will increment the counter:',
  'React will call your component function again. This time, count will be 1. Then it will be 2. And so on.',
  'If you render the same component multiple times, each will get its own state. Click each button separately:',
  'Notice how each button “remembers” its own count state and doesn’t affect other buttons.',
  'Functions starting with use are called Hooks. useState is a built-in Hook provided by React. You can find other built-in Hooks in the API reference. You can also write your own Hooks by combining the existing ones.',
  'Hooks are more restrictive than other functions. You can only call Hooks at the top of your components (or other Hooks). If you want to use useState in a condition or a loop, extract a new component and put it there.',
  'In the previous example, each MyButton had its own independent count, and when each button was clicked, only the count for the button clicked changed:',
  'Initially, each MyButton’s count state is 0',
  'The first MyButton updates its count to 1',
  'However, often you’ll need components to share data and always update together.',
  'To make both MyButton components display the same count and update together, you need to move the state from the individual buttons “upwards” to the closest component containing all of them.',
  'In this example, it is MyApp:',
  'Initially, MyApp’s count state is 0 and is passed down to both children',
  'On click, MyApp updates its count state to 1 and passes it down to both children',
  'Now when you click either button, the count in MyApp will change, which will change both of the counts in MyButton. Here’s how you can express this in code.',
  'First, move the state up from MyButton into MyApp:',
  'Then, pass the state down from MyApp to each MyButton, together with the shared click handler. You can pass information to MyButton using the JSX curly braces, just like you previously did with built-in tags like <img>:',
  'The information you pass down like this is called props. Now the MyApp component contains the count state and the handleClick event handler, and passes both of them down as props to each of the buttons.',
  'Finally, change MyButton to read the props you have passed from its parent component:',
  'When you click the button, the onClick handler fires. Each button’s onClick prop was set to the handleClick function inside MyApp, so the code inside of it runs. That code calls setCount(count + 1), incrementing the count state variable. The new count value is passed as a prop to each button, so they all show the new value. This is called “lifting state up”. By moving state up, you’ve shared it between components.',
  'By now, you know the basics of how to write React code!',
  'Check out the Tutorial to put them into practice and build your first mini-app with React.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react
[
  'Is this page useful?',
  'This section provides detailed reference documentation for working with React. For an introduction to React, please visit the Learn section.',
  'Our The React reference documentation is broken down into functional subsections:',
  'Programmatic React features:',
  'React-dom contains features that are only supported for web applications (which run in the browser DOM environment). This section is broken into the following:',
  'How do you like these docs?'
]
URL:  https://react.dev/community
[
  'Is this page useful?',
  'React has a community of millions of developers. On this page we’ve listed some React-related communities that you can be a part of; see the other pages in this section for additional online and in-person learning materials.',
  'Before participating in React’s communities, please read our Code of Conduct. We have adopted the Contributor Covenant and we expect that all community members adhere to the guidelines within.',
  'Stack Overflow is a popular forum to ask code-level questions or if you’re stuck with a specific error. Read through the existing questions tagged with reactjs or ask your own!',
  'There are many online forums which are a great place for discussion about best practices and application architecture as well as the future of React. If you have an answerable code-level question, Stack Overflow is usually a better fit.',
  'Each community consists of many thousands of React users.',
  'For the latest news about React, follow @reactjs on Twitter and the official React blog on this website.',
  'How do you like these docs?'
]
URL:  https://react.dev/blog
[
  'This blog is the official source for the updates from the React team. Anything important, including release notes or deprecation notices, will be posted here first. You can also follow the @reactjs account on Twitter, but you won’t miss anything essential if you only read this blog.',
  'Traditionally, new React features used to only be available at Meta first, and land in the open source releases later. We’d like to offer the React community an option to adopt individual new features as soon as their design is close to final—similar to how Meta uses React internally. We are introducing a new officially supported Canary release channel. It lets curated setups like frameworks decouple adoption of individual React features from the React release schedule.',
  'In React Labs posts, we write about projects in active research and development. Since our last update, we’ve made significant progress on React Server Components, Asset Loading, Optimizing Compiler, Offscreen Rendering, and Transition Tracing, and we’d like to share what we learned.',
  'Today we are thrilled to launch react.dev, the new home for React and its documentation. In this post, we would like to give you a tour of the new site.',
  'React 18 was years in the making, and with it brought valuable lessons for the React team. Its release was the result of many years of research and exploring many paths. Some of those paths were successful; many more were dead-ends that led to new insights. One lesson we’ve learned is that it’s frustrating for the community to wait for new features without having insight into these paths that we’re exploring…',
  'React 18 is now available on npm! In our last post, we shared step-by-step instructions for upgrading your app to React 18. In this post, we’ll give an overview of what’s new in React 18, and what it means for the future…',
  'As we shared in the release post, React 18 introduces features powered by our new concurrent renderer, with a gradual adoption strategy for existing applications. In this post, we will guide you through the steps for upgrading to React 18…',
  'Last week we hosted our 6th React Conf.  In previous years, we’ve used the React Conf stage to deliver industry changing announcements such as React Native and React Hooks. This year, we shared our multi-platform vision for React, starting with the release of React 18 and gradual adoption of concurrent features…',
  'The React team is excited to share a few updates:',
  '2020 has been a long year. As it comes to an end we wanted to share a special Holiday Update on our research into zero-bundle-size React Server Components. To introduce React Server Components, we have prepared a talk and a demo. If you want, you can check them out during the holidays, or later when work picks back up in the new year…',
  'Not every React release deserves its own blog post, but you can find a detailed changelog for every release in the CHANGELOG.md file in the React repository, as well as on the Releases page.',
  'See the older posts.'
]
URL:  https://react.dev/blog/2023/05/03/react-canaries
[
  'May 3, 2023 by Dan Abramov, Sophie Alpert, Rick Hanlon, Sebastian Markbåge, and Andrew Clark',
  'We’d like to offer the React community an option to adopt individual new features as soon as their design is close to final, before they’re released in a stable version—similar to how Meta has long used bleeding-edge versions of React internally. We are introducing a new officially supported Canary release channel. It lets curated setups like frameworks decouple adoption of individual React features from the React release schedule.',
  'Typically, every React feature has gone through the same stages:',
  'This playbook works well for most features we’ve released so far. However, there can be a significant gap between when the feature is generally ready to use (step 3) and when it is released in open source (step 5).',
  'We’d like to offer the React community an option to follow the same approach as Meta, and adopt individual new features earlier (as they become available) without having to wait for the next release cycle of React.',
  'As always, all React features will eventually make it into a Stable release.',
  'Generally, we do use minor releases for introducing new features.',
  'However, this isn’t always possible. Sometimes, new features are interconnected with other new features which have not yet been fully completed and that we’re still actively iterating on. We can’t release them separately because their implementations are related. We can’t version them separately because they affect the same packages (for example, react and react-dom). And we need to keep the ability to iterate on the pieces that aren’t ready without a flurry of major version releases, which semver would require us to do.',
  'At Meta, we’ve solved this problem by building React from the main branch, and manually updating it to a specific pinned commit every week. This is also the approach that React Native releases have been following for the last several years. Every stable release of React Native is pinned to a specific commit from the main branch of the React repository. This lets React Native include important bugfixes and incrementally adopt new React features at the framework level without getting coupled to the global React release schedule.',
  'We would like to make this workflow available to other frameworks and curated setups. For example, it lets a framework on top of React include a React-related breaking change before this breaking change gets included into a stable React release. This is particularly useful because some breaking changes only affect framework integrations. This lets a framework release such a change in its own minor version without breaking semver.',
  'Rolling releases with the Canaries channel will allow us to have a tighter feedback loop and ensure that new features get comprehensive testing in the community. This workflow is closer to how TC39, the JavaScript standards committee, handles changes in numbered stages. New React features may be available in frameworks built on React before they are in a React stable release, just as new JavaScript features ship in browsers before they are officially ratified as part of the specification.',
  'Although you can technically use Experimental releases, we recommend against using them in production because experimental APIs can undergo significant breaking changes on their way to stabilization (or can even be removed entirely). While Canaries can also contain mistakes (as with any release), going forward we plan to announce any significant breaking changes in Canaries on our blog. Canaries are the closest to the code Meta runs internally, so you can generally expect them to be relatively stable. However, you do need to keep the version pinned and manually scan the GitHub commit log when updating between the pinned commits.',
  'We expect that most people using React outside a curated setup (like a framework) will want to continue using the Stable releases. However, if you’re building a framework, you might want to consider bundling a Canary version of React pinned to a particular commit, and update it at your own pace. The benefit of that is that it lets you ship individual completed React features and bugfixes earlier for your users and at your own release schedule, similar to how React Native has been doing it for the last few years. The downside is that you would take on additional responsibility to review which React commits are being pulled in and communicate to your users which React changes are included with your releases.',
  'If you’re a framework author and want to try this approach, please get in touch with us.',
  'Canary releases represent our best guess of what will go into the next stable React release at any given time.',
  'Traditionally, we’ve only announced breaking changes at the end of the release cycle (when doing a major release). Now that Canary releases are an officially supported way to consume React, we plan to shift towards announcing breaking changes and significant new features as they land in Canaries. For example, if we merge a breaking change that will go out in a Canary, we will write a post about it on the React blog, including codemods and migration instructions if necessary. Then, if you’re a framework author cutting a major release that updates the pinned React canary to include that change, you can link to our blog post from your release notes. Finally, when a stable major version of React is ready, we will link to those already published blog posts, which we hope will help our team make progress faster.',
  'We plan to document APIs as they land in Canaries—even if these APIs are not yet available outside of them. APIs that are only available in Canaries will be marked with a special note on the corresponding pages. This will include APIs like use, and some others (like cache and createServerContext) which we’ll send RFCs for.',
  'If you decide to adopt the Canary workflow for your app or framework, make sure you always pin the exact version of the Canary you’re using. Since Canaries are pre-releases, they may still include breaking changes.',
  'As we announced in March, the React Server Components conventions have been finalized, and we do not expect significant breaking changes related to their user-facing API contract. However, we can’t release support for React Server Components in a stable version of React yet because we are still working on several intertwined framework-only features (such as asset loading) and expect more breaking changes there.',
  'This means that React Server Components are ready to be adopted by frameworks. However, until the next major React release, the only way for a framework to adopt them is to ship a pinned Canary version of React. (To avoid bundling two copies of React, frameworks that wish to do this would need to enforce resolution of react and react-dom to the pinned Canary they ship with their framework, and explain that to their users. As an example, this is what Next.js App Router does.)',
  'We do not expect library authors to test every single Canary release since it would be prohibitively difficult. However, just as when we originally introduced the different React pre-release channels three years ago, we encourage libraries to run tests against both the latest Stable and latest Canary versions. If you see a change in behavior that wasn’t announced, please file a bug in the React repository so that we can help diagnose it. We expect that as this practice becomes widely adopted, it will reduce the amount of effort necessary to upgrade libraries to new major versions of React, since accidental regressions would be found as they land.',
  'Strictly speaking, Canary is not a new release channel—it used to be called Next. However, we’ve decided to rename it to avoid confusion with Next.js. We’re announcing it as a new release channel to communicate the new expectations, such as Canaries being an officially supported way to use React.',
  'We are not introducing any changes to stable React releases.',
  'How do you like these docs?'
]
URL:  https://react.dev/community/versioning-policy
[
  'Is this page useful?',
  'All stable builds of React go through a high level of testing and follow semantic versioning (semver). React also offers unstable release channels to encourage early feedback on experimental features. This page describes what you can expect from React releases.',
  'Stable React releases (also known as “Latest” release channel) follow semantic versioning (semver) principles.',
  'That means that with a version number x.y.z:',
  'Major releases can also contain new features, and any release can include bug fixes.',
  'Minor releases are the most common type of release.',
  'Breaking changes are inconvenient for everyone, so we try to minimize the number of major releases – for example, React 15 was released in April 2016 and React 16 was released in September 2017, and React 17 was released in October 2020.',
  'Instead, we release new features in minor versions. That means that minor releases are often more interesting and compelling than majors, despite their unassuming name.',
  'As we change React over time, we try to minimize the effort required to take advantage of new features. When possible, we’ll keep an older API working, even if that means putting it in a separate package. For example, mixins have been discouraged for years but they’re supported to this day via create-react-class and many codebases continue to use them in stable, legacy code.',
  'Over a million developers use React, collectively maintaining millions of components. The Facebook codebase alone has over 50,000 React components. That means we need to make it as easy as possible to upgrade to new versions of React; if we make large changes without a migration path, people will be stuck on old versions. We test these upgrade paths on Facebook itself – if our team of less than 10 people can update 50,000+ components alone, we hope the upgrade will be manageable for anyone using React. In many cases, we write automated scripts to upgrade component syntax, which we then include in the open-source release for everyone to use.',
  'Development builds of React include many helpful warnings. Whenever possible, we add warnings in preparation for future breaking changes. That way, if your app has no warnings on the latest release, it will be compatible with the next major release. This allows you to upgrade your apps one component at a time.',
  'Development warnings won’t affect the runtime behavior of your app. That way, you can feel confident that your app will behave the same way between the development and production builds — the only differences are that the production build won’t log the warnings and that it is more efficient. (If you ever notice otherwise, please file an issue.)',
  'In general, we don’t bump the major version number for changes to:',
  'This policy is designed to be pragmatic: certainly, we don’t want to cause headaches for you. If we bumped the major version for all of these changes, we would end up releasing more major versions and ultimately causing more versioning pain for the community. It would also mean that we can’t make progress in improving React as fast as we’d like.',
  'That said, if we expect that a change on this list will cause broad problems in the community, we will still do our best to provide a gradual migration path.',
  'It’s possible that a minor release will not include new features. This is allowed by semver, which states “[a minor version] MAY be incremented if substantial new functionality or improvements are introduced within the private code. It MAY include patch level changes.”',
  'However, it does raise the question of why these releases aren’t versioned as patches instead.',
  'The answer is that any change to React (or other software) carries some risk of breaking in unexpected ways. Imagine a scenario where a patch release that fixes one bug accidentally introduces a different bug. This would not only be disruptive to developers, but also harm their confidence in future patch releases. It’s especially regrettable if the original fix is for a bug that is rarely encountered in practice.',
  'We have a pretty good track record for keeping React releases free of bugs, but patch releases have an even higher bar for reliability because most developers assume they can be adopted without adverse consequences.',
  'For these reasons, we reserve patch releases only for the most critical bugs and security vulnerabilities.',
  'If a release includes non-essential changes — such as internal refactors, changes to implementation details, performance improvements, or minor bugfixes — we will bump the minor version even when there are no new features.',
  'React relies on a thriving open source community to file bug reports, open pull requests, and submit RFCs. To encourage feedback we sometimes share special builds of React that include unreleased features.',
  'This section will be most relevant to developers who work on frameworks, libraries, or developer tooling. Developers who use React primarily to build user-facing applications should not need to worry about our prerelease channels.',
  'Each of React’s release channels is designed for a distinct use case:',
  'All releases are published to npm, but only Latest uses semantic versioning. Prereleases (those in the Canary and Experimental channels) have versions generated from a hash of their contents and the commit date, e.g. 18.3.0-canary-388686f29-20230503 for Canary and 0.0.0-experimental-388686f29-20230503 for Experimental.',
  'Both Latest and Canary channels are officially supported for user-facing applications, but with different expectations:',
  'The Experimental releases are provided for testing purposes only, and we provide no guarantees that behavior won’t change between releases. They do not follow the semver protocol that we use for releases from Latest.',
  'By publishing prereleases to the same registry that we use for stable releases, we are able to take advantage of the many tools that support the npm workflow, like unpkg and CodeSandbox.',
  'Latest is the channel used for stable React releases. It corresponds to the latest tag on npm. It is the recommended channel for all React apps that are shipped to real users.',
  'If you’re not sure which channel you should use, it’s Latest. If you’re using React directly, this is what you’re already using. You can expect updates to Latest to be extremely stable. Versions follow the semantic versioning scheme, as described earlier.',
  'The Canary channel is a prerelease channel that tracks the main branch of the React repository. We use prereleases in the Canary channel as release candidates for the Latest channel. You can think of Canary as a superset of Latest that is updated more frequently.',
  'The degree of change between the most recent Canary release and the most recent Latest release is approximately the same as you would find between two minor semver releases. However, the Canary channel does not conform to semantic versioning. You should expect occasional breaking changes between successive releases in the Canary channel.',
  'Do not use prereleases in user-facing applications directly unless you’re following the Canary workflow.',
  'Releases in Canary are published with the canary tag on npm. Versions are generated from a hash of the build’s contents and the commit date, e.g. 18.3.0-canary-388686f29-20230503.',
  'The Canary channel also supports integration testing between React and other projects.',
  'All changes to React go through extensive internal testing before they are released to the public. However, there are a myriad of environments and configurations used throughout the React ecosystem, and it’s not possible for us to test against every single one.',
  'If you’re the author of a third party React framework, library, developer tool, or similar infrastructure-type project, you can help us keep React stable for your users and the entire React community by periodically running your test suite against the most recent changes. If you’re interested, follow these steps:',
  'Set up a cron job using your preferred continuous integration platform. Cron jobs are supported by both CircleCI and Travis CI.',
  'In the cron job, update your React packages to the most recent React release in the Canary channel, using canary tag on npm. Using the npm cli:',
  'Or yarn:',
  'Run your test suite against the updated packages.',
  'If everything passes, great! You can expect that your project will work with the next minor React release.',
  'If something breaks unexpectedly, please let us know by filing an issue.',
  'A project that uses this workflow is Next.js. You can refer to their CircleCI configuration as an example.',
  'Like Canary, the Experimental channel is a prerelease channel that tracks the main branch of the React repository. Unlike Canary, Experimental releases include additional features and APIs that are not ready for wider release.',
  'Usually, an update to Canary is accompanied by a corresponding update to Experimental. They are based on the same source revision, but are built using a different set of feature flags.',
  'Experimental releases may be significantly different than releases to Canary and Latest. Do not use Experimental releases in user-facing applications. You should expect frequent breaking changes between releases in the Experimental channel.',
  'Releases in Experimental are published with the experimental tag on npm. Versions are generated from a hash of the build’s contents and the commit date, e.g. 0.0.0-experimental-68053d940-20210623.',
  'Experimental features are ones that are not ready to be released to the wider public, and may change drastically before they are finalized. Some experiments may never be finalized — the reason we have experiments is to test the viability of proposed changes.',
  'For example, if the Experimental channel had existed when we announced Hooks, we would have released Hooks to the Experimental channel weeks before they were available in Latest.',
  'You may find it valuable to run integration tests against Experimental. This is up to you. However, be advised that Experimental is even less stable than Canary. We do not guarantee any stability between Experimental releases.',
  'Experimental features may or may not be documented. Usually, experiments aren’t documented until they are close to shipping in Canary or Latest.',
  'If a feature is not documented, they may be accompanied by an RFC.',
  'We will post to the React blog when we’re ready to announce new experiments, but that doesn’t mean we will publicize every experiment.',
  'You can always refer to our public GitHub repository’s history for a comprehensive list of changes.',
  'How do you like these docs?'
]
URL:  https://react.dev/community/conferences
[
  'Is this page useful?',
  'Do you know of a local React.js conference? Add it here! (Please keep the list chronological)',
  'September 26 - 29, 2023. Grants Pass, Oregon + remote (hybrid event)',
  'Website - Twitter',
  'September 28 - 30, 2023. Alicante, Spain',
  'Website - Twitter',
  'September 29, 2023. Amsterdam, Netherlands',
  'Website',
  'September 7 & 8, 2023. Wrocław, Poland',
  'Website - Twitter - Facebook',
  'September 29 - 30, 2023. Nairobi, Kenya',
  'Website - Twitter - LinkedIn - YouTube',
  'October 5 - 7, 2023. In-person in Goa, India (hybrid event) + Oct 3 2023 - remote day',
  'Website - Twitter - Facebook - Youtube',
  'October 13th 2023. In-person in Brussels, Belgium + Remote (hybrid)',
  'Website - Twitter',
  'October 20 & 23, 2023. In-person in London, UK + remote first interactivity (hybrid event)',
  'Website - Twitter - Facebook - Videos',
  'October 27th 2023. In-person in Verona, Italy and online (hybrid event)',
  'Website - Twitter - Facebook - YouTube',
  'November 13 & 15, 2023. In-person in New York, US + remote first interactivity (hybrid event)',
  'Website - Twitter - Facebook - Videos',
  'December 8 & 12, 2023. In-person in Berlin, Germany + remote first interactivity (hybrid event)',
  'Website - Twitter - Facebook - Videos',
  'May 22 - 24, 2024. In-person in Kraków, Poland + remote',
  'Website - Twitter',
  'June 12 - June 14, 2024. Atlanta, GA, USA',
  'Website - Discord - Twitter - Instagram - Facebook - LinkedIn - Podcast',
  'August 17 & 18, 2023. Salt Lake City, UT, USA',
  'Website - Twitter - Instagram',
  'July 07 & 08, 2023. Bangalore, India (In-person event)',
  'Website - Twitter - Linkedin - YouTube',
  'June 27th, 2023. Tel Aviv, Israel',
  'Website - Facebook - Youtube',
  'June 16th, 2023. Larvik, Norway',
  'Website - Twitter - Facebook',
  'June 2 & 6, 2023. In-person in Amsterdam, Netherlands + remote first interactivity (hybrid event)',
  'Website - Twitter - Facebook - Videos',
  'May 31 - June 2, 2023. Atlanta, GA, USA',
  'Website - Discord - Twitter - Instagram - Facebook - LinkedIn - Podcast',
  'May 17 - 19, 2023. Portland, OR, USA',
  'Website - Twitter - Facebook - Youtube',
  'May 10 - 12, 2023. In-person in Kraków, Poland + remote',
  'Website - Twitter',
  'May, 2023. Salt Lake City, UT',
  'Website - Twitter',
  'May 2 - 3, 2023. San Francisco, CA, USA',
  'Website - Twitter - YouTube',
  'April 20 - 21, 2023. Miami, FL, USA',
  'Website - Twitter',
  'December 2, 2022. In-person in Berlin, Germany + remote (hybrid event)',
  'Website - Twitter - Facebook - Videos',
  'November 8 - 9, 2022 - Online Summit',
  'Website - LinkedIn',
  'November 18, 2022, 7am PST / 10am EST / 4pm CET - remote event',
  'Website - Twitter - Videos',
  'October 21 & 25, 2022. In-person in London, UK + remote (hybrid event)',
  'Website - Twitter - Facebook - Videos',
  'October 21, 2022 in Verona, Italy',
  'Website - Twitter - LinkedIn - Facebook - Videos',
  'October 14, 2022. In-person in Brussels, Belgium + remote (hybrid event)',
  'Website - Twitter - LinkedIn - Facebook - Videos',
  'September 29 - October 1, 2022. In-person in Alicante, Spain + remote (hybrid event)',
  'Website - Twitter - Facebook - Videos',
  'September 22 - 24, 2022. In-person in Goa, India + remote (hybrid event)',
  'Website - Twitter - Facebook - Videos',
  'September 12 - 16, 2022. In-person in Helsinki, Finland',
  'Website - Twitter - Schedule - Speakers',
  'September 1-2, 2022 - Remote event',
  'Website -\nTwitter -\nLinkedin -\nFacebook -\nInstagram',
  'June 28, 2022. Tel-Aviv, Israel',
  'Website - Twitter - Videos',
  'June 24, 2022. In-person at Farris Bad Hotel in Larvik, Norway and online (hybrid event).',
  'Website - Twitter',
  'June 17 & 21, 2022. In-person in Amsterdam, Netherlands + remote first interactivity (hybrid event)',
  'Website - Twitter - Facebook - Videos',
  'June 8 - 10, 2022. In-person in Kraków, Poland + remote',
  'Website - Twitter',
  'June 8 - 9, 2022.  Remote',
  'Website - Twitter - Linkedin - YouTube',
  'June 1 - 4, 2022. Atlanta, GA, USA',
  'Website - Discord - Twitter - Instagram - Facebook - LinkedIn - Podcast',
  'May 24 - 25, 2022. Salt Lake City, UT',
  'Website - Twitter - YouTube',
  'May 3 - 5, 2022. Berkeley, CA',
  'Website - Twitter -YouTube',
  'April 20 - 21, 2022 - Online Summit',
  'Website - LinkedIn',
  'April 18 - 19, 2022. Miami, Florida\nWebsite',
  'April 1, 2022. Amsterdam, The Netherlands',
  'Website - Twitter',
  'January 27 - 30, 2022. In-person in Dornbirn and Lech Austria',
  'Website - Twitter - Instagram',
  'December 8, 2021 - remote event (replay event on December 9)',
  'Website',
  'December 9-10, 2021 - remote event',
  'Videos',
  'December 15, 2021. Tel-Aviv, Israel',
  'Website - Twitter - Videos',
  'November 12-13, 2021 - remote event',
  ... 202 more items
]
URL:  https://react.dev/community/meetups
[
  'Is this page useful?',
  'Do you have a local React.js meetup? Add it here! (Please keep the list alphabetical)',
  'How do you like these docs?'
]
URL:  https://react.dev/community/videos
[
  'Is this page useful?',
  'Videos dedicated to the discussion of React and the React ecosystem.',
  'In the keynote, we shared our vision for the future of React starting with React 18.',
  'Watch the full keynote from Andrew Clark, Juan Tejada, Lauren Tan, and Rick Hanlon here:',
  'For a demo of upgrading to React 18, see Shruti Kapoor’s talk here:',
  'React 18 also includes improvements to server-side rendering performance using Suspense.',
  'Streaming server rendering lets you generate HTML from React components on the server, and stream that HTML to your users. In React 18, you can use Suspense to break down your app into smaller independent units which can be streamed independently of each other without blocking the rest of the app. This means users will see your content sooner and be able to start interacting with it much faster.',
  'For a deep dive, see Shaundai Person’s talk here:',
  'For React 18, we created our first Working Group to collaborate with a panel of experts, developers, library maintainers, and educators. Together we worked to create our gradual adoption strategy and refine new APIs such as useId, useSyncExternalStore, and useInsertionEffect.',
  'For an overview of this work, see Aakansha’ Doshi’s talk:',
  'To support the new features in this release, we also announced the newly formed React DevTools team and a new Timeline Profiler to help developers debug their React apps.',
  'For more information and a demo of new DevTools features, see Brian Vaughn’s talk:',
  'Looking further into the future, Xuan Huang (黄玄) shared an update from our React Labs research into an auto-memoizing compiler. Check out this talk for more information and a demo of the compiler prototype:',
  'Rachel Nabors kicked off a section of talks about learning and designing with React with a keynote about our investment in React’s new docs (now shipped as react.dev):',
  'We also heard talks on learning and designing with React:',
  'Talks from the Relay, React Native, and PyTorch teams:',
  'And talks from the community on accessibility, tooling, and Server Components:',
  'A playlist of videos from React Conf 2019.',
  'A playlist of videos from React Conf 2018.',
  'A playlist of videos from React.js Conf 2017.',
  'A playlist of videos from React.js Conf 2016.',
  'A playlist of videos from React.js Conf 2015.',
  'Pete Hunt’s talk at JSConf EU 2013 covers three topics: throwing out the notion of templates and building views with JavaScript, “re-rendering” your entire application when your data changes, and a lightweight implementation of the DOM and events - (2013 - 0h30m).',
  'Tom Occhino and Jordan Walke introduce React at Facebook Seattle - (2013 - 1h20m).',
  'How do you like these docs?'
]
URL:  https://react.dev/community/team
[
  'Is this page useful?',
  'React development is led by a dedicated team working full time at Meta. It also receives contributions from people all over the world.',
  'The React Core team members work full time on the core component APIs, the engine that powers React DOM and React Native, React DevTools, and the React documentation website.',
  'Current members of the React team are listed in alphabetical order below.',
  'Andrew got started with web development by making sites with WordPress, and eventually tricked himself into doing JavaScript. His favorite pastime is karaoke. Andrew is either a Disney villain or a Disney princess, depending on the day.',
  'Andrey started his career as a designer and then gradually transitioned into web development. After joining the React Data team at Meta he worked on adding an incremental JavaScript compiler to Relay, and then later on, worked on removing the same compiler from Relay. Outside of work, Andrey likes to play music and engage in various sports.',
  'Dan got into programming after he accidentally discovered Visual Basic inside Microsoft PowerPoint. He has found his true calling in turning Sebastian’s tweets into long-form blog posts. Dan occasionally wins at Fortnite by hiding in a bush until the game ends.',
  'Eli got into programming after he got suspended from middle school for hacking. He has been working on React and React Native since 2017. He enjoys eating treats, especially ice cream and apple pie. You can find Eli trying quirky activities like parkour, indoor skydiving, and aerial silks.',
  'Jason likes having large volumes of Amazon packages delivered to the office so that he can build forts. Despite literally walling himself off from his team at times and not understanding how for-of loops work, we appreciate him for the unique qualities he brings to his work.',
  'Joe was planning to major in math and philosophy but got into computer science after writing physics simulations in Matlab. Prior to React, he worked on Relay, RSocket.js, and the Skip programming language. While he’s not building some sort of reactive system he enjoys running, studying Japanese, and spending time with his family.',
  'Josh majored in Mathematics and discovered programming while in college. His first professional developer job was to program insurance rate calculations in Microsoft Excel, the paragon of Reactive Programming which must be why he now works on React. In between that time Josh has been an IC, Manager, and Executive at a few startups. outside of work he likes to push his limits with cooking.',
  'Kathryn initially discovered web development when she wanted to make her myspace page look cool. She ended up majoring in Computer Science, and quickly became a huge fan of React building features on the Instagram.com team. Outside of work she loves playing pingpong, teaching spin classes, and going plant shopping.',
  'Lauren’s programming career peaked when she first discovered the <marquee> tag. She’s been chasing that high ever since. When she’s not adding bugs into React, she enjoys dropping cheeky memes in chat, and playing all too many video games with her partner, and her dog Zelda.',
  'Luna first learnt the fundamentals of python at the age of 6 from her father. Since then, she has been unstoppable. Luna aspires to be a gen z, and the road to success is paved with environmental advocacy, urban gardening and lots of quality time with her Voo-Doo’d (as pictured).',
  'Matt stumbled into coding, and since then, has become enamored with creating things in communities that can’t be created alone. Prior to React, he worked on YouTube, the Google Assistant, Fuchsia, and Google Cloud AI and Evernote. When he’s not trying to make better developer tools he enjoys the mountains, jazz, and spending time with his family.',
  'Mofei started programming when she realized it can help her cheat in video games. She focused on operating systems in undergrad / grad school, but now finds herself happily tinkering on React. Outside of work, she enjoys debugging bouldering problems and planning her next backpacking trip(s).',
  'Ricky majored in theoretical math and somehow found himself on the React Native team for a couple years before joining the React team. When he’s not programming you can find him snowboarding, biking, climbing, golfing, or closing GitHub issues that do not match the issue template.',
  'Samuel’s interest in programming started with the movie Matrix. He still has Matrix screen saver. Before working on React, he was focused on writing iOS apps. Outside of work, Samuel enjoys playing beach volleyball, squash, badminton and spending time with his family.',
  'Sathya hated the Dragon Book in school but somehow ended up working on compilers all his career. When he’s not compiling React components, he’s either drinking coffee or eating yet another Dosa.',
  'Sebastian majored in psychology. He’s usually quiet. Even when he says something, it often doesn’t make sense to the rest of us until a few months later. The correct way to pronounce his surname is “mark-boa-geh” but he settled for “mark-beige” out of pragmatism — and that’s how he approaches React.',
  'Sebastian learned programming to make the browser games he played during class more enjoyable. Eventually this lead to contributing to as much open source code as possible. Outside of coding he’s busy making sure people don’t confuse him with the other Sebastians and Zilberman of the React community.',
  'Seth started programming as a kid growing up in Tucson, AZ. After school, he was bitten by the music bug and was a touring musician for about 10 years before returning to work, starting with Intuit. In his spare time, he loves taking pictures and flying for animal rescues in the northeastern United States.',
  'Four days after React was released, Sophie rewrote the entirety of her then-current project to use it, which she now realizes was perhaps a bit reckless. After she became the project’s #1 committer, she wondered why she wasn’t getting paid by Facebook like everyone else was and joined the team officially to lead React through its adolescent years. Though she quit that job years ago, somehow she’s still in the team’s group chats and “providing value”.',
  'Tianyu’s interest in computers started as a kid because he loves video games. So he majored in computer science and still plays childish games like League of Legends. When he is not in front of a computer, he enjoys playing with his two kittens, hiking and kayaking.',
  'Yuzhi studied Computer Science in school. She liked the instant gratification of seeing code come to life without having to physically be in a laboratory. Now she’s a manager in the React org. Before management, she used to work on the Relay data fetching framework. In her spare time, Yuzhi enjoys optimizing her life via gardening and home improvement projects.',
  'You can find the past team members and other people who significantly contributed to React over the years on the acknowledgements page.',
  'How do you like these docs?'
]
URL:  https://react.dev/community/docs-contributors
[
  'Is this page useful?',
  'React documentation is written and maintained by the React team and external contributors. On this page, we’d like to thank a few people who’ve made significant contributions to this site.',
  'We’d also like to thank countless alpha testers and community members who gave us feedback along the way.',
  'How do you like these docs?'
]
URL:  https://react.dev/community/acknowledgements
[
  'Is this page useful?',
  'React was originally created by Jordan Walke. Today, React has a dedicated full-time team working on it, as well as over a thousand open source contributors.',
  'We’d like to recognize a few people who have made significant contributions to React and its documentation in the past and have helped maintain them over the years:',
  'This list is not exhaustive.',
  'We’d like to give special thanks to Tom Occhino and Adam Wolff for their guidance and support over the years. We are also thankful to all the volunteers who translated React into other languages.',
  'Additionally, we’re grateful to:',
  'How do you like these docs?'
]
URL:  https://react.dev/learn/installation
[
  'Is this page useful?',
  'React has been designed from the start for gradual adoption. You can use as little or as much React as you need. Whether you want to get a taste of React, add some interactivity to an HTML page, or start a complex React-powered app, this section will help you get started.',
  'You don’t need to install anything to play with React. Try editing this sandbox!',
  'You can edit it directly or open it in a new tab by pressing the “Fork” button in the upper right corner.',
  'Most pages in the React documentation contain sandboxes like this. Outside of the React documentation, there are many online sandboxes that support React: for example, CodeSandbox, StackBlitz, or CodePen.',
  'To try React locally on your computer, download this HTML page. Open it in your editor and in your browser!',
  'If you want to build an app or a website fully with React, start a new React project.',
  'If want to try using React in your existing app or a website, add React to an existing project.',
  'Head to the Quick Start guide for a tour of the most important React concepts you will encounter every day.',
  'How do you like these docs?'
]
URL:  https://react.dev/learn/tutorial-tic-tac-toe
[
  'Is this page useful?',
  'You will build a small tic-tac-toe game during this tutorial. This tutorial does not assume any existing React knowledge. The techniques you’ll learn in the tutorial are fundamental to building any React app, and fully understanding it will give you a deep understanding of React.',
  'This tutorial is designed for people who prefer to learn by doing and want to quickly try making something tangible. If you prefer learning each concept step by step, start with Describing the UI.',
  'The tutorial is divided into several sections:',
  'In this tutorial, you’ll build an interactive tic-tac-toe game with React.',
  'You can see what it will look like when you’re finished here:',
  'If the code doesn’t make sense to you yet, or if you are unfamiliar with the code’s syntax, don’t worry! The goal of this tutorial is to help you understand React and its syntax.',
  'We recommend that you check out the tic-tac-toe game above before continuing with the tutorial. One of the features that you’ll notice is that there is a numbered list to the right of the game’s board. This list gives you a history of all of the moves that have occurred in the game, and it is updated as the game progresses.',
  'Once you’ve played around with the finished tic-tac-toe game, keep scrolling. You’ll start with a simpler template in this tutorial. Our next step is to set you up so that you can start building the game.',
  'In the live code editor below, click Fork in the top-right corner to open the editor in a new tab using the website CodeSandbox. CodeSandbox lets you write code in your browser and preview how your users will see the app you’ve created. The new tab should display an empty square and the starter code for this tutorial.',
  'You can also follow this tutorial using your local development environment. To do this, you need to:',
  'If you get stuck, don’t let this stop you! Follow along online instead and try a local setup again later.',
  'Now that you’re set up, let’s get an overview of React!',
  'In CodeSandbox you’ll see three main sections:',
  'The App.js file should be selected in the Files section. The contents of that file in the code editor should be:',
  'The browser section should be displaying a square with a X in it like this:',
  'Now let’s have a look at the files in the starter code.',
  'The code in App.js creates a component. In React, a component is a piece of reusable code that represents a part of a user interface. Components are used to render, manage, and update the UI elements in your application. Let’s look at the component line by line to see what’s going on:',
  'The first line defines a function called Square. The export JavaScript keyword makes this function accessible outside of this file. The default keyword tells other files using your code that it’s the main function in your file.',
  'The second line returns a button. The return JavaScript keyword means whatever comes after is returned as a value to the caller of the function. <button> is a JSX element. A JSX element is a combination of JavaScript code and HTML tags that describes what you’d like to display. className="square" is a button property or prop that tells CSS how to style the button. X is the text displayed inside of the button and </button> closes the JSX element to indicate that any following content shouldn’t be placed inside the button.',
  'Click on the file labeled styles.css in the Files section of CodeSandbox. This file defines the styles for your React app. The first two CSS selectors (* and body) define the style of large parts of your app while the .square selector defines the style of any component where the className property is set to square. In your code, that would match the button from your Square component in the App.js file.',
  'Click on the file labeled index.js in the Files section of CodeSandbox. You won’t be editing this file during the tutorial but it is the bridge between the component you created in the App.js file and the web browser.',
  'Lines 1-5 brings all the necessary pieces together:',
  'The remainder of the file brings all the pieces together and injects the final product into index.html in the public folder.',
  'Let’s get back to App.js. This is where you’ll spend the rest of the tutorial.',
  'Currently the board is only a single square, but you need nine! If you just try and copy paste your square to make two squares like this:',
  'You’ll get this error:',
  'React components need to return a single JSX element and not multiple adjacent JSX elements like two buttons. To fix this you can use Fragments (<> and </>) to wrap multiple adjacent JSX elements like this:',
  'Now you should see:',
  'Great! Now you just need to copy-paste a few times to add nine squares and…',
  'Oh no! The squares are all in a single line, not in a grid like you need for our board. To fix this you’ll need to group your squares into rows with divs and add some CSS classes. While you’re at it, you’ll give each square a number to make sure you know where each square is displayed.',
  'In the App.js file, update the Square component to look like this:',
  'The CSS defined in styles.css styles the divs with the className of board-row. Now that you’ve grouped your components into rows with the styled divs you have your tic-tac-toe board:',
  'But you now have a problem. Your component named Square, really isn’t a square anymore. Let’s fix that by changing the name to Board:',
  'At this point your code should look something like this:',
  'Psssst… That’s a lot to type! It’s okay to copy and paste code from this page. However, if you’re up for a little challenge, we recommend only copying code that you’ve manually typed at least once yourself.',
  'Next, you’ll want to change the value of a square from empty to “X” when the user clicks on the square. With how you’ve built the board so far you would need to copy-paste the code that updates the square nine times (once for each square you have)! Instead of copy-pasting, React’s component architecture allows you to create a reusable component to avoid messy, duplicated code.',
  'First, you are going to copy the line defining your first square (<button className="square">1</button>) from your Board component into a new Square component:',
  'Then you’ll update the Board component to render that Square component using JSX syntax:',
  'Note how unlike the browser divs, your own components Board and Square must start with a capital letter.',
  'Let’s take a look:',
  'Oh no! You lost the numbered squares you had before. Now each square says “1”. To fix this, you will use props to pass the value each square should have from the parent component (Board) to its child (Square).',
  'Update the Square component to read the value prop that you’ll pass from the Board:',
  'function Square({ value }) indicates the Square component can be passed a prop called value.',
  'Now you want to display that value instead of 1 inside every square. Try doing it like this:',
  'Oops, this is not what you wanted:',
  'You wanted to render the JavaScript variable called value from your component, not the word “value”. To “escape into JavaScript” from JSX, you need curly braces. Add curly braces around value in JSX like so:',
  'For now, you should see an empty board:',
  'This is because the Board component hasn’t passed the value prop to each Square component it renders yet. To fix it you’ll add the value prop to each Square component rendered by the Board component:',
  'Now you should see a grid of numbers again:',
  'Your updated code should look like this:',
  'Let’s fill the Square component with an X when you click it. Declare a function called handleClick inside of the Square. Then, add onClick to the props of the button JSX element returned from the Square:',
  'If you click on a square now, you should see a log saying "clicked!" in the Console tab at the bottom of the Browser section in CodeSandbox. Clicking the square more than once will log "clicked!" again. Repeated console logs with the same message will not create more lines in the console. Instead, you will see an incrementing counter next to your first "clicked!" log.',
  'If you are following this tutorial using your local development environment, you need to open your browser’s Console. For example, if you use the Chrome browser, you can view the Console with the keyboard shortcut Shift + Ctrl + J (on Windows/Linux) or Option + ⌘ + J (on macOS).',
  'As a next step, you want the Square component to “remember” that it got clicked, and fill it with an “X” mark. To “remember” things, components use state.',
  'React provides a special function called useState that you can call from your component to let it “remember” things. Let’s store the current value of the Square in state, and change it when the Square is clicked.',
  'Import useState at the top of the file. Remove the value prop from the Square component. Instead, add a new line at the start of the Square that calls useState. Have it return a state variable called value:',
  'value stores the value and setValue is a function that can be used to change the value. The null passed to useState is used as the initial value for this state variable, so value here starts off equal to null.',
  'Since the Square component no longer accepts props anymore, you’ll remove the value prop from all nine of the Square components created by the Board component:',
  `Now you’ll change Square to display an “X” when clicked. Replace the console.log("clicked!"); event handler with setValue('X');. Now your Square component looks like this:`,
  "By calling this set function from an onClick handler, you’re telling React to re-render that Square whenever its <button> is clicked. After the update, the Square’s value will be 'X', so you’ll see the “X” on the game board. Click on any Square, and “X” should show up:",
  'Each Square has its own state: the value stored in each Square is completely independent of the others. When you call a set function in a component, React automatically updates the child components inside too.',
  'After you’ve made the above changes, your code will look like this:',
  'React DevTools let you check the props and the state of your React components. You can find the React DevTools tab at the bottom of the browser section in CodeSandbox:',
  'To inspect a particular component on the screen, use the button in the top left corner of React DevTools:',
  'For local development, React DevTools is available as a Chrome, Firefox, and Edge browser extension. Install it, and the Components tab will appear in your browser Developer Tools for sites using React.',
  'By this point, you have all the basic building blocks for your tic-tac-toe game. To have a complete game, you now need to alternate placing “X”s and “O”s on the board, and you need a way to determine a winner.',
  'Currently, each Square component maintains a part of the game’s state. To check for a winner in a tic-tac-toe game, the Board would need to somehow know the state of each of the 9 Square components.',
  'How would you approach that? At first, you might guess that the Board needs to “ask” each Square for that Square’s state. Although this approach is technically possible in React, we discourage it because the code becomes difficult to understand, susceptible to bugs, and hard to refactor. Instead, the best approach is to store the game’s state in the parent Board component instead of in each Square. The Board component can tell each Square what to display by passing a prop, like you did when you passed a number to each Square.',
  'To collect data from multiple children, or to have two child components communicate with each other, declare the shared state in their parent component instead. The parent component can pass that state back down to the children via props. This keeps the child components in sync with each other and with their parent.',
  'Lifting state into a parent component is common when React components are refactored.',
  'Let’s take this opportunity to try it out. Edit the Board component so that it declares a state variable named squares that defaults to an array of 9 nulls corresponding to the 9 squares:',
  'Array(9).fill(null) creates an array with nine elements and sets each of them to null. The useState() call around it declares a squares state variable that’s initially set to that array. Each entry in the array corresponds to the value of a square. When you fill the board in later, the squares array will look like this:',
  'Now your Board component needs to pass the value prop down to each Square that it renders:',
  'Next, you’ll edit the Square component to receive the value prop from the Board component. This will require removing the Square component’s own stateful tracking of value and the button’s onClick prop:',
  'At this point you should see an empty tic-tac-toe board:',
  'And your code should look like this:',
  "Each Square will now receive a value prop that will either be 'X', 'O', or null for empty squares.",
  'Next, you need to change what happens when a Square is clicked. The Board component now maintains which squares are filled. You’ll need to create a way for the Square to update the Board’s state. Since state is private to a component that defines it, you cannot update the Board’s state directly from Square.',
  'Instead, you’ll pass down a function from the Board component to the Square component, and you’ll have Square call that function when a square is clicked. You’ll start with the function that the Square component will call when it is clicked. You’ll call that function onSquareClick:',
  'Next, you’ll add the onSquareClick function to the Square component’s props:',
  'Now you’ll connect the onSquareClick prop to a function in the Board component that you’ll name handleClick. To connect onSquareClick to handleClick you’ll pass a function to the onSquareClick prop of the first Square component:',
  'Lastly, you will define the handleClick function inside the Board component to update the squares array holding your board’s state:',
  'The handleClick function creates a copy of the squares array (nextSquares) with the JavaScript slice() Array method. Then, handleClick updates the nextSquares array to add X to the first ([0] index) square.',
  'Calling the setSquares function lets React know the state of the component has changed. This will trigger a re-render of the components that use the squares state (Board) as well as its child components (the Square components that make up the board).',
  'JavaScript supports closures which means an inner function (e.g. handleClick) has access to variables and functions defined in a outer function (e.g. Board). The handleClick function can read the squares state and call the setSquares method because they are both defined inside of the Board function.',
  'Now you can add X’s to the board…  but only to the upper left square. Your handleClick function is hardcoded to update the index for the upper left square (0). Let’s update handleClick to be able to update any square. Add an argument i to the handleClick function that takes the index of the square to update:',
  'Next, you will need to pass that i to handleClick. You could try to set the onSquareClick prop of square to be handleClick(0) directly in the JSX like this, but it won’t work:',
  'Here is why this doesn’t work. The handleClick(0) call will be a part of rendering the board component. Because handleClick(0) alters the state of the board component by calling setSquares, your entire board component will be re-rendered again. But this runs handleClick(0) again, leading to an infinite loop:',
  'Why didn’t this problem happen earlier?',
  'When you were passing onSquareClick={handleClick}, you were passing the handleClick function down as a prop. You were not calling it! But now you are calling that function right away—notice the parentheses in handleClick(0)—and that’s why it runs too early. You don’t want to call handleClick until the user clicks!',
  'You could fix this by creating a function like handleFirstSquareClick that calls handleClick(0), a function like handleSecondSquareClick that calls handleClick(1), and so on. You would pass (rather than call) these functions down as props like onSquareClick={handleFirstSquareClick}. This would solve the infinite loop.',
  'However, defining nine different functions and giving each of them a name is too verbose. Instead, let’s do this:',
  'Notice the new () => syntax. Here, () => handleClick(0) is an arrow function, which is a shorter way to define functions. When the square is clicked, the code after the => “arrow” will run, calling handleClick(0).',
  'Now you need to update the other eight squares to call handleClick from the arrow functions you pass. Make sure that the argument for each call of the handleClick corresponds to the index of the correct square:',
  'Now you can again add X’s to any square on the board by clicking on them:',
  'But this time all the state management is handled by the Board component!',
  'This is what your code should look like:',
  'Now that your state handling is in the Board component, the parent Board component passes props to the child Square components so that they can be displayed correctly. When clicking on a Square, the child Square component now asks the parent Board component to update the state of the board. When the Board’s state changes, both the Board component and every child Square re-renders automatically. Keeping the state of all squares in the Board component will allow it to determine the winner in the future.',
  'Let’s recap what happens when a user clicks the top left square on your board to add an X to it:',
  ... 76 more items
]
URL:  https://react.dev/learn/thinking-in-react
[
  'Is this page useful?',
  'React can change how you think about the designs you look at and the apps you build. When you build a user interface with React, you will first break it apart into pieces called components. Then, you will describe the different visual states for each of your components. Finally, you will connect your components together so that the data flows through them. In this tutorial, we’ll guide you through the thought process of building a searchable product data table with React.',
  'Imagine that you already have a JSON API and a mockup from a designer.',
  'The JSON API returns some data that looks like this:',
  'The mockup looks like this:',
  'To implement a UI in React, you will usually follow the same five steps.',
  'Start by drawing boxes around every component and subcomponent in the mockup and naming them. If you work with a designer, they may have already named these components in their design tool. Ask them!',
  'Depending on your background, you can think about splitting up a design into components in different ways:',
  'If your JSON is well-structured, you’ll often find that it naturally maps to the component structure of your UI. That’s because UI and data models often have the same information architecture—that is, the same shape. Separate your UI into components, where each component matches one piece of your data model.',
  'There are five components on this screen:',
  'If you look at ProductTable (lavender), you’ll see that the table header (containing the “Name” and “Price” labels) isn’t its own component. This is a matter of preference, and you could go either way. For this example, it is a part of ProductTable because it appears inside the ProductTable’s list. However, if this header grows to be complex (e.g., if you add sorting), you can move it into its own ProductTableHeader component.',
  'Now that you’ve identified the components in the mockup, arrange them into a hierarchy. Components that appear within another component in the mockup should appear as a child in the hierarchy:',
  'Now that you have your component hierarchy, it’s time to implement your app. The most straightforward approach is to build a version that renders the UI from your data model without adding any interactivity… yet! It’s often easier to build the static version first and add interactivity later. Building a static version requires a lot of typing and no thinking, but adding interactivity requires a lot of thinking and not a lot of typing.',
  'To build a static version of your app that renders your data model, you’ll want to build components that reuse other components and pass data using props. Props are a way of passing data from parent to child. (If you’re familiar with the concept of state, don’t use state at all to build this static version. State is reserved only for interactivity, that is, data that changes over time. Since this is a static version of the app, you don’t need it.)',
  'You can either build “top down” by starting with building the components higher up in the hierarchy (like FilterableProductTable) or “bottom up” by working from components lower down (like ProductRow). In simpler examples, it’s usually easier to go top-down, and on larger projects, it’s easier to go bottom-up.',
  '(If this code looks intimidating, go through the Quick Start first!)',
  'After building your components, you’ll have a library of reusable components that render your data model. Because this is a static app, the components will only return JSX. The component at the top of the hierarchy (FilterableProductTable) will take your data model as a prop. This is called one-way data flow because the data flows down from the top-level component to the ones at the bottom of the tree.',
  'At this point, you should not be using any state values. That’s for the next step!',
  'To make the UI interactive, you need to let users change your underlying data model. You will use state for this.',
  'Think of state as the minimal set of changing data that your app needs to remember. The most important principle for structuring state is to keep it DRY (Don’t Repeat Yourself). Figure out the absolute minimal representation of the state your application needs and compute everything else on-demand. For example, if you’re building a shopping list, you can store the items as an array in state. If you want to also display the number of items in the list, don’t store the number of items as another state value—instead, read the length of your array.',
  'Now think of all of the pieces of data in this example application:',
  'Which of these are state? Identify the ones that are not:',
  'What’s left is probably state.',
  'Let’s go through them one by one again:',
  'This means only the search text and the value of the checkbox are state! Nicely done!',
  'There are two types of “model” data in React: props and state. The two are very different:',
  'Props and state are different, but they work together. A parent component will often keep some information in state (so that it can change it), and pass it down to child components as their props. It’s okay if the difference still feels fuzzy on the first read. It takes a bit of practice for it to really stick!',
  'After identifying your app’s minimal state data, you need to identify which component is responsible for changing this state, or owns the state. Remember: React uses one-way data flow, passing data down the component hierarchy from parent to child component. It may not be immediately clear which component should own what state. This can be challenging if you’re new to this concept, but you can figure it out by following these steps!',
  'For each piece of state in your application:',
  'In the previous step, you found two pieces of state in this application: the search input text, and the value of the checkbox. In this example, they always appear together, so it makes sense to put them into the same place.',
  'Now let’s run through our strategy for them:',
  'So the state values will live in FilterableProductTable.',
  'Add state to the component with the useState() Hook. Hooks are special functions that let you “hook into” React. Add two state variables at the top of FilterableProductTable and specify their initial state:',
  'Then, pass filterText and inStockOnly to ProductTable and SearchBar as props:',
  "You can start seeing how your application will behave. Edit the filterText initial value from useState('') to useState('fruit') in the sandbox code below. You’ll see both the search input text and the table update:",
  'Notice that editing the form doesn’t work yet. There is a console error in the sandbox above explaining why:',
  'In the sandbox above, ProductTable and SearchBar read the filterText and inStockOnly props to render the table, the input, and the checkbox. For example, here is how SearchBar populates the input value:',
  'However, you haven’t added any code to respond to the user actions like typing yet. This will be your final step.',
  'Currently your app renders correctly with props and state flowing down the hierarchy. But to change the state according to user input, you will need to support data flowing the other way: the form components deep in the hierarchy need to update the state in FilterableProductTable.',
  'React makes this data flow explicit, but it requires a little more typing than two-way data binding. If you try to type or check the box in the example above, you’ll see that React ignores your input. This is intentional. By writing <input value={filterText} />, you’ve set the value prop of the input to always be equal to the filterText state passed in from FilterableProductTable. Since filterText state is never set, the input never changes.',
  'You want to make it so whenever the user changes the form inputs, the state updates to reflect those changes. The state is owned by FilterableProductTable, so only it can call setFilterText and setInStockOnly. To let SearchBar update the FilterableProductTable’s state, you need to pass these functions down to SearchBar:',
  'Inside the SearchBar, you will add the onChange event handlers and set the parent state from them:',
  'Now the application fully works!',
  'You can learn all about handling events and updating state in the Adding Interactivity section.',
  'This was a very brief introduction to how to think about building components and applications with React. You can start a React project right now or dive deeper on all the syntax used in this tutorial.',
  'How do you like these docs?'
]
URL:  https://react.dev/learn/start-a-new-react-project
[
  'Is this page useful?',
  'If you want to build a new app or a new website fully with React, we recommend picking one of the React-powered frameworks popular in the community. Frameworks provide features that most apps and sites eventually need, including routing, data fetching, and generating HTML.',
  'You need to install Node.js for local development. You can also choose to use Node.js in production, but you don’t have to. Many React frameworks support export to a static HTML/CSS/JS folder.',
  'Next.js is a full-stack React framework. It’s versatile and lets you create React apps of any size—from a mostly static blog to a complex dynamic application. To create a new Next.js project, run in your terminal:',
  'If you’re new to Next.js, check out the Next.js tutorial.',
  'Next.js is maintained by Vercel. You can deploy a Next.js app to any Node.js or serverless hosting, or to your own server. Next.js also supports a static export which doesn’t require a server.',
  'Remix is a full-stack React framework with nested routing. It lets you break your app into nested parts that can load data in parallel and refresh in response to the user actions. To create a new Remix project, run:',
  'If you’re new to Remix, check out the Remix blog tutorial (short) and app tutorial (long).',
  'Remix is maintained by Shopify. When you create a Remix project, you need to pick your deployment target. You can deploy a Remix app to any Node.js or serverless hosting by using or writing an adapter.',
  'Gatsby is a React framework for fast CMS-backed websites. Its rich plugin ecosystem and its GraphQL data layer simplify integrating content, APIs, and services into one website. To create a new Gatsby project, run:',
  'If you’re new to Gatsby, check out the Gatsby tutorial.',
  'Gatsby is maintained by Netlify. You can deploy a fully static Gatsby site to any static hosting. If you opt into using server-only features, make sure your hosting provider supports them for Gatsby.',
  'Expo is a React framework that lets you create universal Android, iOS, and web apps with truly native UIs. It provides an SDK for React Native that makes the native parts easier to use. To create a new Expo project, run:',
  'If you’re new to Expo, check out the Expo tutorial.',
  'Expo is maintained by Expo (the company). Building apps with Expo is free, and you can submit them to the Google and Apple app stores without restrictions. Expo additionally provides opt-in paid cloud services.',
  'You can definitely use React without a framework—that’s how you’d use React for a part of your page. However, if you’re building a new app or a site fully with React, we recommend using a framework.',
  'Here’s why.',
  'Even if you don’t need routing or data fetching at first, you’ll likely want to add some libraries for them. As your JavaScript bundle grows with every new feature, you might have to figure out how to split code for every route individually. As your data fetching needs get more complex, you are likely to encounter server-client network waterfalls that make your app feel very slow. As your audience includes more users with poor network conditions and low-end devices, you might need to generate HTML from your components to display content early—either on the server, or during the build time. Changing your setup to run some of your code on the server or during the build can be very tricky.',
  'These problems are not React-specific. This is why Svelte has SvelteKit, Vue has Nuxt, and so on. To solve these problems on your own, you’ll need to integrate your bundler with your router and with your data fetching library. It’s not hard to get an initial setup working, but there are a lot of subtleties involved in making an app that loads quickly even as it grows over time. You’ll want to send down the minimal amount of app code but do so in a single client–server roundtrip, in parallel with any data required for the page. You’ll likely want the page to be interactive before your JavaScript code even runs, to support progressive enhancement. You may want to generate a folder of fully static HTML files for your marketing pages that can be hosted anywhere and still work with JavaScript disabled. Building these capabilities yourself takes real work.',
  'React frameworks on this page solve problems like these by default, with no extra work from your side. They let you start very lean and then scale your app with your needs. Each React framework has a community, so finding answers to questions and upgrading tooling is easier. Frameworks also give structure to your code, helping you and others retain context and skills between different projects. Conversely, with a custom setup it’s easier to get stuck on unsupported dependency versions, and you’ll essentially end up creating your own framework—albeit one with no community or upgrade path (and if it’s anything like the ones we’ve made in the past, more haphazardly designed).',
  'If you’re still not convinced, or your app has unusual constraints not served well by these frameworks and you’d like to roll your own custom setup, we can’t stop you—go for it! Grab react and react-dom from npm, set up your custom build process with a bundler like Vite or Parcel, and add other tools as you need them for routing, static generation or server-side rendering, and more.',
  'As we’ve explored how to continue improving React, we realized that integrating React more closely with frameworks (specifically, with routing, bundling, and server technologies) is our biggest opportunity to help React users build better apps. The Next.js team has agreed to collaborate with us in researching, developing, integrating, and testing framework-agnostic bleeding-edge React features like React Server Components.',
  'These features are getting closer to being production-ready every day, and we’ve been in talks with other bundler and framework developers about integrating them. Our hope is that in a year or two, all frameworks listed on this page will have full support for these features. (If you’re a framework author interested in partnering with us to experiment with these features, please let us know!)',
  'Next.js’s App Router is a redesign of the Next.js APIs aiming to fulfill the React team’s full-stack architecture vision. It lets you fetch data in asynchronous components that run on the server or even during the build.',
  'Next.js is maintained by Vercel. You can deploy a Next.js app to any Node.js or serverless hosting, or to your own server. Next.js also supports static export which doesn’t require a server.',
  'Next.js’s App Router bundler fully implements the official React Server Components specification. This lets you mix build-time, server-only, and interactive components in a single React tree.',
  'For example, you can write a server-only React component as an async function that reads from a database or from a file. Then you can pass data down from it to your interactive components:',
  'Next.js’s App Router also integrates data fetching with Suspense. This lets you specify a loading state (like a skeleton placeholder) for different parts of your user interface directly in your React tree:',
  'Server Components and Suspense are React features rather than Next.js features. However, adopting them at the framework level requires buy-in and non-trivial implementation work. At the moment, the Next.js App Router is the most complete implementation. The React team is working with bundler developers to make these features easier to implement in the next generation of frameworks.',
  'How do you like these docs?'
]
URL:  https://react.dev/learn/add-react-to-an-existing-project
[
  'Is this page useful?',
  'If you want to add some interactivity to your existing project, you don’t have to rewrite it in React. Add React to your existing stack, and render interactive React components anywhere.',
  'You need to install Node.js for local development. Although you can try React online or with a simple HTML page, realistically most JavaScript tooling you’ll want to use for development requires Node.js.',
  'Let’s say you have an existing web app at example.com built with another server technology (like Rails), and you want to implement all routes starting with example.com/some-app/ fully with React.',
  'Here’s how we recommend to set it up:',
  'This ensures the React part of your app can benefit from the best practices baked into those frameworks.',
  'Many React-based frameworks are full-stack and let your React app take advantage of the server. However, you can use the same approach even if you can’t or don’t want to run JavaScript on the server. In that case, serve the HTML/CSS/JS export (next export output for Next.js, default for Gatsby) at /some-app/ instead.',
  'Let’s say you have an existing page built with another technology (either a server one like Rails, or a client one like Backbone), and you want to render interactive React components somewhere on that page. That’s a common way to integrate React—in fact, it’s how most React usage looked at Meta for many years!',
  'You can do this in two steps:',
  'The exact approach depends on your existing page setup, so let’s walk through some details.',
  'A modular JavaScript environment lets you write your React components in individual files, as opposed to writing all of your code in a single file. It also lets you use all the wonderful packages published by other developers on the npm registry—including React itself! How you do this depends on your existing setup:',
  'If your app is already split into files that use import statements, try to use the setup you already have. Check whether writing <div /> in your JS code causes a syntax error. If it causes a syntax error, you might need to transform your JavaScript code with Babel, and enable the Babel React preset to use JSX.',
  'If your app doesn’t have an existing setup for compiling JavaScript modules, set it up with Vite. The Vite community maintains many integrations with backend frameworks, including Rails, Django, and Laravel. If your backend framework is not listed, follow this guide to manually integrate Vite builds with your backend.',
  'To check whether your setup works, run this command in your project folder:',
  'Then add these lines of code at the top of your main JavaScript file (it might be called index.js or main.js):',
  'If the entire content of your page was replaced by a “Hello, world!”, everything worked! Keep reading.',
  'Integrating a modular JavaScript environment into an existing project for the first time can feel intimidating, but it’s worth it! If you get stuck, try our community resources or the Vite Chat.',
  'In the previous step, you put this code at the top of your main file:',
  'Of course, you don’t actually want to clear the existing HTML content!',
  'Delete this code.',
  'Instead, you probably want to render your React components in specific places in your HTML. Open your HTML page (or the server templates that generate it) and add a unique id attribute to any tag, for example:',
  'This lets you find that HTML element with document.getElementById and pass it to createRoot so that you can render your own React component inside:',
  'Notice how the original HTML content from index.html is preserved, but your own NavigationBar React component now appears inside the <nav id="navigation"> from your HTML. Read the createRoot usage documentation to learn more about rendering React components inside an existing HTML page.',
  'When you adopt React in an existing project, it’s common to start with small interactive components (like buttons), and then gradually keep “moving upwards” until eventually your entire page is built with React. If you ever reach that point, we recommend migrating to a React framework right after to get the most out of React.',
  'React Native can also be integrated into existing native apps incrementally. If you have an existing native app for Android (Java or Kotlin) or iOS (Objective-C or Swift), follow this guide to add a React Native screen to it.',
  'How do you like these docs?'
]
URL:  https://react.dev/learn/editor-setup
[
  'Is this page useful?',
  'A properly configured editor can make code clearer to read and faster to write. It can even help you catch bugs as you write them! If this is your first time setting up an editor or you’re looking to tune up your current editor, we have a few recommendations.',
  'VS Code is one of the most popular editors in use today. It has a large marketplace of extensions and integrates well with popular services like GitHub. Most of the features listed below can be added to VS Code as extensions as well, making it highly configurable!',
  'Other popular text editors used in the React community include:',
  'Some editors come with these features built in, but others might require adding an extension. Check to see what support your editor of choice provides to be sure!',
  'Code linters find problems in your code as you write, helping you fix them early. ESLint is a popular, open source linter for JavaScript.',
  'Make sure that you’ve enabled all the eslint-plugin-react-hooks rules for your project. They are essential and catch the most severe bugs early. The recommended eslint-config-react-app preset already includes them.',
  'The last thing you want to do when sharing your code with another contributor is get into an discussion about tabs vs spaces! Fortunately, Prettier will clean up your code by reformatting it to conform to preset, configurable rules. Run Prettier, and all your tabs will be converted to spaces—and your indentation, quotes, etc will also all be changed to conform to the configuration. In the ideal setup, Prettier will run when you save your file, quickly making these edits for you.',
  'You can install the Prettier extension in VSCode by following these steps:',
  'Ideally, you should format your code on every save. VS Code has settings for this!',
  'If your ESLint preset has formatting rules, they may conflict with Prettier. We recommend disabling all formatting rules in your ESLint preset using eslint-config-prettier so that ESLint is only used for catching logical mistakes. If you want to enforce that files are formatted before a pull request is merged, use prettier --check for your continuous integration.',
  'How do you like these docs?'
]
URL:  https://react.dev/learn/typescript
[
  'Is this page useful?',
  'TypeScript is a popular way to add type definitions to JavaScript codebases. Out of the box, TypeScript supports JSX and you can get full React Web support by adding @types/react and @types/react-dom to your project.',
  'All production-grade React frameworks offer support for using TypeScript. Follow the framework specific guide for installation:',
  'To install the latest version of React’s type definitions:',
  'The following compiler options need to be set in your tsconfig.json:',
  'Every file containing JSX must use the .tsx file extension. This is a TypeScript-specific extension that tells TypeScript that this file contains JSX.',
  'Writing TypeScript with React is very similar to writing JavaScript with React. The key difference when working with a component is that you can provide types for your component’s props. These types can be used for correctness checking and providing inline documentation in editors.',
  'Taking the MyButton component from the Quick Start guide, we can add a type describing the title for the button:',
  'These sandboxes can handle TypeScript code, but they do not run the type-checker. This means you can amend the TypeScript sandboxes to learn, but you won’t get any type errors or warnings. To get type-checking, you can use the TypeScript Playground or use a more fully-featured online sandbox.',
  'This inline syntax is the simplest way to provide types for a component, though once you start to have a few fields to describe it can become unwieldy. Instead, you can use an interface or type to describe the component’s props:',
  'The type describing your component’s props can be as simple or as complex as you need, though they should be an object type described with either a type or interface. You can learn about how TypeScript describes objects in Object Types but you may also be interested in using Union Types to describe a prop that can be one of a few different types and the Creating Types from Types guide for more advanced use cases.',
  'The type definitions from @types/react include types for the built-in Hooks, so you can use them in your components without any additional setup. They are built to take into account the code you write in your component, so you will get inferred types a lot of the time and ideally do not need to handle the minutiae of providing the types.',
  'However, we can look at a few examples of how to provide types for Hooks.',
  'The useState Hook will re-use the value passed in as the initial state to determine what the type of the value should be. For example:',
  'Will assign the type of boolean to enabled, and setEnabled will be a function accepting either a boolean argument, or a function that returns a boolean. If you want to explicitly provide a type for the state, you can do so by providing a type argument to the useState call:',
  'This isn’t very useful in this case, but a common case where you may want to provide a type is when you have a union type. For example, status here can be one of a few different strings:',
  'Or, as recommended in Principles for structuring state, you can group related state as an object and describe the different possibilities via object types:',
  'The useReducer Hook is a more complex Hook that takes a reducer function and an initial state. The types for the reducer function are inferred from the initial state. You can optionally provide a type argument to the useReducer call to provide a type for the state, but it is often better to set the type on the initial state instead:',
  'We are using TypeScript in a few key places:',
  'A more explicit alternative to setting the type on initialState is to provide a type argument to useReducer:',
  'The useContext Hook is a technique for passing data down the component tree without having to pass props through components. It is used by creating a provider component and often by creating a Hook to consume the value in a child component.',
  'The type of the value provided by the context is inferred from the value passed to the createContext call:',
  'This technique works when you have a default value which makes sense - but there are occasionally cases when you do not, and in those cases null can feel reasonable as a default value. However, to allow the type-system to understand your code, you need to explicitly set ContextShape | null on the createContext.',
  'This causes the issue that you need to eliminate the | null in the type for context consumers. Our recommendation is to have the Hook do a runtime check for it’s existence and throw an error when not present:',
  'The useMemo Hooks will create/re-access a memorized value from a function call, re-running the function only when dependencies passed as the 2nd parameter are changed. The result of calling the Hook is inferred from the return value from the function in the first parameter. You can be more explicit by providing a type argument to the Hook.',
  'The useCallback provide a stable reference to a function as long as the dependencies passed into the second parameter are the same. Like useMemo, the function’s type is inferred from the return value of the function in the first parameter, and you can be more explicit by providing a type argument to the Hook.',
  'When working in TypeScript strict mode useCallback requires adding types for the parameters in your callback. This is because the type of the callback is inferred from the return value of the function, and without parameters the type cannot be fully understood.',
  'Depending on your code-style preferences, you could use the *EventHandler functions from the React types to provide the type for the event handler at the same time as defining the callback:',
  'There is quite an expansive set of types which come from the @types/react package, it is worth a read when you feel comfortable with how React and TypeScript interact. You can find them in React’s folder in DefinitelyTyped. We will cover a few of the more common types here.',
  'When working with DOM events in React, the type of the event can often be inferred from the event handler. However, when you want to extract a function to be passed to an event handler, you will need to explicitly set the type of the event.',
  'There are many types of events provided in the React types - the full list can be found here which is based on the most popular events from the DOM.',
  'When determining the type you are looking for you can first look at the hover information for the event handler you are using, which will show the type of the event.',
  'If you need to use an event that is not included in this list, you can use the React.SyntheticEvent type, which is the base type for all events.',
  'There are two common paths to describing the children of a component. The first is to use the React.ReactNode type, which is a union of all the possible types that can be passed as children in JSX:',
  'This is a very broad definition of children. The second is to use the React.ReactElement type, which is only JSX elements and not JavaScript primitives like strings or numbers:',
  'Note, that you cannot use TypeScript to describe that the children are a certain type of JSX elements, so you cannot use the type-system to describe a component which only accepts <li> children.',
  'You can see all an example of both React.ReactNode and React.ReactElement with the type-checker in this TypeScript playground.',
  'When using inline styles in React, you can use React.CSSProperties to describe the object passed to the style prop. This type is a union of all the possible CSS properties, and is a good way to ensure you are passing valid CSS properties to the style prop, and to get auto-complete in your editor.',
  'This guide has covered the basics of using TypeScript with React, but there is a lot more to learn.\n' +
    'Individual API pages on the docs may contain more in-depth documentation on how to use them with TypeScript.',
  'We recommend the following resources:',
  'The TypeScript handbook is the official documentation for TypeScript, and covers most key language features.',
  'The TypeScript release notes covers a each new features in-depth.',
  'React TypeScript Cheatsheet is a community-maintained cheatsheet for using TypeScript with React, covering a lot of useful edge cases and providing more breadth than this document.',
  'TypeScript Community Discord is a great place to ask questions and get help with TypeScript and React issues.',
  'How do you like these docs?'
]
URL:  https://react.dev/learn/react-developer-tools
[
  'Is this page useful?',
  'Use React Developer Tools to inspect React components, edit props and state, and identify performance problems.',
  'The easiest way to debug websites built with React is to install the React Developer Tools browser extension. It is available for several popular browsers:',
  'Now, if you visit a website built with React, you will see the Components and Profiler panels.',
  'For other browsers (for example, Safari), install the react-devtools npm package:',
  'Next open the developer tools from the terminal:',
  'Then connect your website by adding the following <script> tag to the beginning of your website’s <head>:',
  'Reload your website in the browser now to view it in developer tools.',
  'React Developer Tools can be used to inspect apps built with React Native as well.',
  'The easiest way to use React Developer Tools is to install it globally:',
  'Next open the developer tools from the terminal.',
  'It should connect to any local React Native app that’s running.',
  'Try reloading the app if developer tools doesn’t connect after a few seconds.',
  'Learn more about debugging React Native.',
  'How do you like these docs?'
]
URL:  https://react.dev/learn/describing-the-ui
[
  'Is this page useful?',
  'React is a JavaScript library for rendering user interfaces (UI). UI is built from small units like buttons, text, and images. React lets you combine them into reusable, nestable components. From web sites to phone apps, everything on the screen can be broken down into components. In this chapter, you’ll learn to create, customize, and conditionally display React components.',
  'React applications are built from isolated pieces of UI called components. A React component is a JavaScript function that you can sprinkle with markup. Components can be as small as a button, or as large as an entire page. Here is a Gallery component rendering three Profile components:',
  'Read Your First Component to learn how to declare and use React components.',
  'You can declare many components in one file, but large files can get difficult to navigate. To solve this, you can export a component into its own file, and then import that component from another file:',
  'Read Importing and Exporting Components to learn how to split components into their own files.',
  'Each React component is a JavaScript function that may contain some markup that React renders into the browser. React components use a syntax extension called JSX to represent that markup. JSX looks a lot like HTML, but it is a bit stricter and can display dynamic information.',
  'If we paste existing HTML markup into a React component, it won’t always work:',
  'If you have existing HTML like this, you can fix it using a converter:',
  'Read Writing Markup with JSX to learn how to write valid JSX.',
  'JSX lets you write HTML-like markup inside a JavaScript file, keeping rendering logic and content in the same place. Sometimes you will want to add a little JavaScript logic or reference a dynamic property inside that markup. In this situation, you can use curly braces in your JSX to “open a window” to JavaScript:',
  'Read JavaScript in JSX with Curly Braces to learn how to access JavaScript data from JSX.',
  'React components use props to communicate with each other. Every parent component can pass some information to its child components by giving them props. Props might remind you of HTML attributes, but you can pass any JavaScript value through them, including objects, arrays, functions, and even JSX!',
  'Read Passing Props to a Component to learn how to pass and read props.',
  'Your components will often need to display different things depending on different conditions. In React, you can conditionally render JSX using JavaScript syntax like if statements, &&, and ? : operators.',
  'In this example, the JavaScript && operator is used to conditionally render a checkmark:',
  'Read Conditional Rendering to learn the different ways to render content conditionally.',
  'You will often want to display multiple similar components from a collection of data. You can use JavaScript’s filter() and map() with React to filter and transform your array of data into an array of components.',
  'For each array item, you will need to specify a key. Usually, you will want to use an ID from the database as a key. Keys let React keep track of each item’s place in the list even if the list changes.',
  'Read Rendering Lists to learn how to render a list of components, and how to choose a key.',
  'Some JavaScript functions are pure. A pure function:',
  'By strictly only writing your components as pure functions, you can avoid an entire class of baffling bugs and unpredictable behavior as your codebase grows. Here is an example of an impure component:',
  'You can make this component pure by passing a prop instead of modifying a preexisting variable:',
  'Read Keeping Components Pure to learn how to write components as pure, predictable functions.',
  'React uses trees to model the relationships between components and modules.',
  'A React render tree is a representation of the parent and child relationship between components.',
  'An example React render tree.',
  'Components near the top of the tree, near the root component, are considered top-level components. Components with no child components are leaf components. This categorization of components is useful for understanding data flow and rendering performance.',
  'Modelling the relationship between JavaScript modules is another useful way to understand your app. We refer to it as a module dependency tree.',
  'An example module dependency tree.',
  'A dependency tree is often used by build tools to bundle all the relevant JavaScript code for the client to download and render. A large bundle size regresses user experience for React apps. Understanding the module dependency tree is helpful to debug such issues.',
  'Read Your UI as a Tree to learn how to create a render and module dependency trees for a React app and how they’re useful mental models for improving user experience and performance.',
  'Head over to Your First Component to start reading this chapter page by page!',
  'Or, if you’re already familiar with these topics, why not read about Adding Interactivity?',
  'How do you like these docs?'
]
URL:  https://react.dev/learn/your-first-component
[
  'Is this page useful?',
  'Components are one of the core concepts of React. They are the foundation upon which you build user interfaces (UI), which makes them the perfect place to start your React journey!',
  'On the Web, HTML lets us create rich structured documents with its built-in set of tags like <h1> and <li>:',
  'This markup represents this article <article>, its heading <h1>, and an (abbreviated) table of contents as an ordered list <ol>. Markup like this, combined with CSS for style, and JavaScript for interactivity, lies behind every sidebar, avatar, modal, dropdown—every piece of UI you see on the Web.',
  'React lets you combine your markup, CSS, and JavaScript into custom “components”, reusable UI elements for your app. The table of contents code you saw above could be turned into a <TableOfContents /> component you could render on every page. Under the hood, it still uses the same HTML tags like <article>, <h1>, etc.',
  'Just like with HTML tags, you can compose, order and nest components to design whole pages. For example, the documentation page you’re reading is made out of React components:',
  'As your project grows, you will notice that many of your designs can be composed by reusing components you already wrote, speeding up your development. Our table of contents above could be added to any screen with <TableOfContents />! You can even jumpstart your project with the thousands of components shared by the React open source community like Chakra UI and Material UI.',
  'Traditionally when creating web pages, web developers marked up their content and then added interaction by sprinkling on some JavaScript. This worked great when interaction was a nice-to-have on the web. Now it is expected for many sites and all apps. React puts interactivity first while still using the same technology: a React component is a JavaScript function that you can sprinkle with markup. Here’s what that looks like (you can edit the example below):',
  'And here’s how to build a component:',
  'The export default prefix is a standard JavaScript syntax (not specific to React). It lets you mark the main function in a file so that you can later import it from other files. (More on importing in Importing and Exporting Components!)',
  'With function Profile() { } you define a JavaScript function with the name Profile.',
  'React components are regular JavaScript functions, but their names must start with a capital letter or they won’t work!',
  'The component returns an <img /> tag with src and alt attributes. <img /> is written like HTML, but it is actually JavaScript under the hood! This syntax is called JSX, and it lets you embed markup inside JavaScript.',
  'Return statements can be written all on one line, as in this component:',
  'But if your markup isn’t all on the same line as the return keyword, you must wrap it in a pair of parentheses:',
  'Without parentheses, any code on the lines after return will be ignored!',
  'Now that you’ve defined your Profile component, you can nest it inside other components. For example, you can export a Gallery component that uses multiple Profile components:',
  'Notice the difference in casing:',
  'And Profile contains even more HTML: <img />. In the end, this is what the browser sees:',
  'Components are regular JavaScript functions, so you can keep multiple components in the same file. This is convenient when components are relatively small or tightly related to each other. If this file gets crowded, you can always move Profile to a separate file. You will learn how to do this shortly on the page about imports.',
  'Because the Profile components are rendered inside Gallery—even several times!—we can say that Gallery is a parent component, rendering each Profile as a “child”. This is part of the magic of React: you can define a component once, and then use it in as many places and as many times as you like.',
  'Components can render other components, but you must never nest their definitions:',
  'The snippet above is very slow and causes bugs. Instead, define every component at the top level:',
  'When a child component needs some data from a parent, pass it by props instead of nesting definitions.',
  'Your React application begins at a “root” component. Usually, it is created automatically when you start a new project. For example, if you use CodeSandbox or if you use the framework Next.js, the root component is defined in pages/index.js. In these examples, you’ve been exporting root components.',
  'Most React apps use components all the way down. This means that you won’t only use components for reusable pieces like buttons, but also for larger pieces like sidebars, lists, and ultimately, complete pages! Components are a handy way to organize UI code and markup, even if some of them are only used once.',
  'React-based frameworks take this a step further. Instead of using an empty HTML file and letting React “take over” managing the page with JavaScript, they also generate the HTML automatically from your React components. This allows your app to show some content before the JavaScript code loads.',
  'Still, many websites only use React to add interactivity to existing HTML pages. They have many root components instead of a single one for the entire page. You can use as much—or as little—React as you need.',
  'You’ve just gotten your first taste of React! Let’s recap some key points.',
  'React lets you create components, reusable UI elements for your app.',
  'In a React app, every piece of UI is a component.',
  'React components are regular JavaScript functions except:',
  'This sandbox doesn’t work because the root component is not exported:',
  'Try to fix it yourself before looking at the solution!',
  'How do you like these docs?'
]
URL:  https://react.dev/learn/importing-and-exporting-components
[
  'Is this page useful?',
  'The magic of components lies in their reusability: you can create components that are composed of other components. But as you nest more and more components, it often makes sense to start splitting them into different files. This lets you keep your files easy to scan and reuse components in more places.',
  'In Your First Component, you made a Profile component and a Gallery component that renders it:',
  'These currently live in a root component file, named App.js in this example. Depending on your setup, your root component could be in another file, though. If you use a framework with file-based routing, such as Next.js, your root component will be different for every page.',
  'What if you want to change the landing screen in the future and put a list of science books there? Or place all the profiles somewhere else? It makes sense to move Gallery and Profile out of the root component file. This will make them more modular and reusable in other files. You can move a component in three steps:',
  'Here both Profile and Gallery have been moved out of App.js into a new file called Gallery.js. Now you can change App.js to import Gallery from Gallery.js:',
  'Notice how this example is broken down into two component files now:',
  'You may encounter files that leave off the .js file extension like so:',
  "Either './Gallery.js' or './Gallery' will work with React, though the former is closer to how native ES Modules work.",
  'There are two primary ways to export values with JavaScript: default exports and named exports. So far, our examples have only used default exports. But you can use one or both of them in the same file. A file can have no more than one default export, but it can have as many named exports as you like.',
  'How you export your component dictates how you must import it. You will get an error if you try to import a default export the same way you would a named export! This chart can help you keep track:',
  "When you write a default import, you can put any name you want after import. For example, you could write import Banana from './Button.js' instead and it would still provide you with the same default export. In contrast, with named imports, the name has to match on both sides. That’s why they are called named imports!",
  'People often use default exports if the file exports only one component, and use named exports if it exports multiple components and values. Regardless of which coding style you prefer, always give meaningful names to your component functions and the files that contain them. Components without names, like export default () => {}, are discouraged because they make debugging harder.',
  'What if you want to show just one Profile instead of a gallery? You can export the Profile component, too. But Gallery.js already has a default export, and you can’t have two default exports. You could create a new file with a default export, or you could add a named export for Profile. A file can only have one default export, but it can have numerous named exports!',
  'To reduce the potential confusion between default and named exports, some teams choose to only stick to one style (default or named), or avoid mixing them in a single file. Do what works best for you!',
  'First, export Profile from Gallery.js using a named export (no default keyword):',
  'Then, import Profile from Gallery.js to App.js using a named import (with the curly braces):',
  'Finally, render <Profile /> from the App component:',
  'Now Gallery.js contains two exports: a default Gallery export, and a named Profile export. App.js imports both of them. Try editing <Profile /> to <Gallery /> and back in this example:',
  'Now you’re using a mix of default and named exports:',
  'On this page you learned:',
  'Currently, Gallery.js exports both Profile and Gallery, which is a bit confusing.',
  'Move the Profile component to its own Profile.js, and then change the App component to render both <Profile /> and <Gallery /> one after another.',
  'You may use either a default or a named export for Profile, but make sure that you use the corresponding import syntax in both App.js and Gallery.js! You can refer to the table from the deep dive above:',
  'After you get it working with one kind of exports, make it work with the other kind.',
  'How do you like these docs?'
]
URL:  https://react.dev/learn/writing-markup-with-jsx
[
  'Is this page useful?',
  'JSX is a syntax extension for JavaScript that lets you write HTML-like markup inside a JavaScript file. Although there are other ways to write components, most React developers prefer the conciseness of JSX, and most codebases use it.',
  'The Web has been built on HTML, CSS, and JavaScript. For many years, web developers kept content in HTML, design in CSS, and logic in JavaScript—often in separate files! Content was marked up inside HTML while the page’s logic lived separately in JavaScript:',
  'HTML',
  'JavaScript',
  'But as the Web became more interactive, logic increasingly determined content. JavaScript was in charge of the HTML! This is why in React, rendering logic and markup live together in the same place—components.',
  'Sidebar.js React component',
  'Form.js React component',
  'Keeping a button’s rendering logic and markup together ensures that they stay in sync with each other on every edit. Conversely, details that are unrelated, such as the button’s markup and a sidebar’s markup, are isolated from each other, making it safer to change either of them on their own.',
  'Each React component is a JavaScript function that may contain some markup that React renders into the browser. React components use a syntax extension called JSX to represent that markup. JSX looks a lot like HTML, but it is a bit stricter and can display dynamic information. The best way to understand this is to convert some HTML markup to JSX markup.',
  'JSX and React are two separate things. They’re often used together, but you can use them independently of each other. JSX is a syntax extension, while React is a JavaScript library.',
  'Suppose that you have some (perfectly valid) HTML:',
  'And you want to put it into your component:',
  'If you copy and paste it as is, it will not work:',
  'This is because JSX is stricter and has a few more rules than HTML! If you read the error messages above, they’ll guide you to fix the markup, or you can follow the guide below.',
  'Most of the time, React’s on-screen error messages will help you find where the problem is. Give them a read if you get stuck!',
  'To return multiple elements from a component, wrap them with a single parent tag.',
  'For example, you can use a <div>:',
  'If you don’t want to add an extra <div> to your markup, you can write <> and </> instead:',
  'This empty tag is called a Fragment. Fragments let you group things without leaving any trace in the browser HTML tree.',
  'JSX looks like HTML, but under the hood it is transformed into plain JavaScript objects. You can’t return two objects from a function without wrapping them into an array. This explains why you also can’t return two JSX tags without wrapping them into another tag or a Fragment.',
  'JSX requires tags to be explicitly closed: self-closing tags like <img> must become <img />, and wrapping tags like <li>oranges must be written as <li>oranges</li>.',
  'This is how Hedy Lamarr’s image and list items look closed:',
  'JSX turns into JavaScript and attributes written in JSX become keys of JavaScript objects. In your own components, you will often want to read those attributes into variables. But JavaScript has limitations on variable names. For example, their names can’t contain dashes or be reserved words like class.',
  'This is why, in React, many HTML and SVG attributes are written in camelCase. For example, instead of stroke-width you use strokeWidth. Since class is a reserved word, in React you write className instead, named after the corresponding DOM property:',
  'You can find all these attributes in the list of DOM component props. If you get one wrong, don’t worry—React will print a message with a possible correction to the browser console.',
  'For historical reasons, aria-* and data-* attributes are written as in HTML with dashes.',
  'Converting all these attributes in existing markup can be tedious! We recommend using a converter to translate your existing HTML and SVG to JSX. Converters are very useful in practice, but it’s still worth understanding what is going on so that you can comfortably write JSX on your own.',
  'Here is your final result:',
  'Now you know why JSX exists and how to use it in components:',
  'This HTML was pasted into a component, but it’s not valid JSX. Fix it:',
  'Whether to do it by hand or using the converter is up to you!',
  'How do you like these docs?'
]
URL:  https://react.dev/learn/javascript-in-jsx-with-curly-braces
[
  'Is this page useful?',
  'JSX lets you write HTML-like markup inside a JavaScript file, keeping rendering logic and content in the same place. Sometimes you will want to add a little JavaScript logic or reference a dynamic property inside that markup. In this situation, you can use curly braces in your JSX to open a window to JavaScript.',
  'When you want to pass a string attribute to JSX, you put it in single or double quotes:',
  'Here, "https://i.imgur.com/7vQD0fPs.jpg" and "Gregorio Y. Zara" are being passed as strings.',
  'But what if you want to dynamically specify the src or alt text? You could use a value from JavaScript by replacing " and " with { and }:',
  'Notice the difference between className="avatar", which specifies an "avatar" CSS class name that makes the image round, and src={avatar} that reads the value of the JavaScript variable called avatar. That’s because curly braces let you work with JavaScript right there in your markup!',
  'JSX is a special way of writing JavaScript. That means it’s possible to use JavaScript inside it—with curly braces { }. The example below first declares a name for the scientist, name, then embeds it with curly braces inside the <h1>:',
  "Try changing the name’s value from 'Gregorio Y. Zara' to 'Hedy Lamarr'. See how the list title changes?",
  'Any JavaScript expression will work between curly braces, including function calls like formatDate():',
  'You can only use curly braces in two ways inside JSX:',
  'In addition to strings, numbers, and other JavaScript expressions, you can even pass objects in JSX. Objects are also denoted with curly braces, like { name: "Hedy Lamarr", inventions: 5 }. Therefore, to pass a JS object in JSX, you must wrap the object in another pair of curly braces: person={{ name: "Hedy Lamarr", inventions: 5 }}.',
  'You may see this with inline CSS styles in JSX. React does not require you to use inline styles (CSS classes work great for most cases). But when you need an inline style, you pass an object to the style attribute:',
  'Try changing the values of backgroundColor and color.',
  'You can really see the JavaScript object inside the curly braces when you write it like this:',
  'The next time you see {{ and }} in JSX, know that it’s nothing more than an object inside the JSX curlies!',
  `Inline style properties are written in camelCase. For example, HTML <ul style="background-color: black"> would be written as <ul style={{ backgroundColor: 'black' }}>  in your component.`,
  'You can move several expressions into one object, and reference them in your JSX inside curly braces:',
  'In this example, the person JavaScript object contains a name string and a theme object:',
  'The component can use these values from person like so:',
  'JSX is very minimal as a templating language because it lets you organize data and logic using JavaScript.',
  'Now you know almost everything about JSX:',
  'This code crashes with an error saying Objects are not valid as a React child:',
  'Can you find the problem?',
  'How do you like these docs?'
]
URL:  https://react.dev/learn/passing-props-to-a-component
[
  'Is this page useful?',
  'React components use props to communicate with each other. Every parent component can pass some information to its child components by giving them props. Props might remind you of HTML attributes, but you can pass any JavaScript value through them, including objects, arrays, and functions.',
  'Props are the information that you pass to a JSX tag. For example, className, src, alt, width, and height are some of the props you can pass to an <img>:',
  'The props you can pass to an <img> tag are predefined (ReactDOM conforms to the HTML standard). But you can pass any props to your own components, such as <Avatar>, to customize them. Here’s how!',
  'In this code, the Profile component isn’t passing any props to its child component, Avatar:',
  'You can give Avatar some props in two steps.',
  'First, pass some props to Avatar. For example, let’s pass two props: person (an object), and size (a number):',
  'If double curly braces after person= confuse you, recall they’re merely an object inside the JSX curlies.',
  'Now you can read these props inside the Avatar component.',
  'You can read these props by listing their names person, size separated by the commas inside ({ and }) directly after function Avatar. This lets you use them inside the Avatar code, like you would with a variable.',
  'Add some logic to Avatar that uses the person and size props for rendering, and you’re done.',
  'Now you can configure Avatar to render in many different ways with different props. Try tweaking the values!',
  'Props let you think about parent and child components independently. For example, you can change the person or the size props inside Profile without having to think about how Avatar uses them. Similarly, you can change how the Avatar uses these props, without looking at the Profile.',
  'You can think of props like “knobs” that you can adjust. They serve the same role as arguments serve for functions—in fact, props are the only argument to your component! React component functions accept a single argument, a props object:',
  'Usually you don’t need the whole props object itself, so you destructure it into individual props.',
  'Don’t miss the pair of { and } curlies inside of ( and ) when declaring props:',
  'This syntax is called “destructuring” and is equivalent to reading properties from a function parameter:',
  'If you want to give a prop a default value to fall back on when no value is specified, you can do it with the destructuring by putting = and the default value right after the parameter:',
  'Now, if <Avatar person={...} /> is rendered with no size prop, the size will be set to 100.',
  'The default value is only used if the size prop is missing or if you pass size={undefined}. But if you pass size={null} or size={0}, the default value will not be used.',
  'Sometimes, passing props gets very repetitive:',
  'There’s nothing wrong with repetitive code—it can be more legible. But at times you may value conciseness. Some components forward all of their props to their children, like how this Profile does with Avatar. Because they don’t use any of their props directly, it can make sense to use a more concise “spread” syntax:',
  'This forwards all of Profile’s props to the Avatar without listing each of their names.',
  'Use spread syntax with restraint. If you’re using it in every other component, something is wrong. Often, it indicates that you should split your components and pass children as JSX. More on that next!',
  'It is common to nest built-in browser tags:',
  'Sometimes you’ll want to nest your own components the same way:',
  'When you nest content inside a JSX tag, the parent component will receive that content in a prop called children. For example, the Card component below will receive a children prop set to <Avatar /> and render it in a wrapper div:',
  'Try replacing the <Avatar> inside <Card> with some text to see how the Card component can wrap any nested content. It doesn’t need to “know” what’s being rendered inside of it. You will see this flexible pattern in many places.',
  'You can think of a component with a children prop as having a “hole” that can be “filled in” by its parent components with arbitrary JSX. You will often use the children prop for visual wrappers: panels, grids, etc.',
  'Illustrated by Rachel Lee Nabors',
  'The Clock component below receives two props from its parent component: color and time. (The parent component’s code is omitted because it uses state, which we won’t dive into just yet.)',
  'Try changing the color in the select box below:',
  'This example illustrates that a component may receive different props over time. Props are not always static! Here, the time prop changes every second, and the color prop changes when you select another color. Props reflect a component’s data at any point in time, rather than only in the beginning.',
  'However, props are immutable—a term from computer science meaning “unchangeable”. When a component needs to change its props (for example, in response to a user interaction or new data), it will have to “ask” its parent component to pass it different props—a new object! Its old props will then be cast aside, and eventually the JavaScript engine will reclaim the memory taken by them.',
  'Don’t try to “change props”. When you need to respond to the user input (like changing the selected color), you will need to “set state”, which you can learn about in State: A Component’s Memory.',
  'This Gallery component contains some very similar markup for two profiles. Extract a Profile component out of it to reduce the duplication. You’ll need to choose what props to pass to it.',
  'How do you like these docs?'
]
URL:  https://react.dev/learn/conditional-rendering
[
  'Is this page useful?',
  'Your components will often need to display different things depending on different conditions. In React, you can conditionally render JSX using JavaScript syntax like if statements, &&, and ? : operators.',
  'Let’s say you have a PackingList component rendering several Items, which can be marked as packed or not:',
  'Notice that some of the Item components have their isPacked prop set to true instead of false. You want to add a checkmark (✔) to packed items if isPacked={true}.',
  'You can write this as an if/else statement like so:',
  'If the isPacked prop is true, this code returns a different JSX tree. With this change, some of the items get a checkmark at the end:',
  'Try editing what gets returned in either case, and see how the result changes!',
  'Notice how you’re creating branching logic with JavaScript’s if and return statements. In React, control flow (like conditions) is handled by JavaScript.',
  'In some situations, you won’t want to render anything at all. For example, say you don’t want to show packed items at all. A component must return something. In this case, you can return null:',
  'If isPacked is true, the component will return nothing, null. Otherwise, it will return JSX to render.',
  'In practice, returning null from a component isn’t common because it might surprise a developer trying to render it. More often, you would conditionally include or exclude the component in the parent component’s JSX. Here’s how to do that!',
  'In the previous example, you controlled which (if any!) JSX tree would be returned by the component. You may already have noticed some duplication in the render output:',
  'is very similar to',
  'Both of the conditional branches return <li className="item">...</li>:',
  'While this duplication isn’t harmful, it could make your code harder to maintain. What if you want to change the className? You’d have to do it in two places in your code! In such a situation, you could conditionally include a little JSX to make your code more DRY.',
  'JavaScript has a compact syntax for writing a conditional expression — the conditional operator or “ternary operator”.',
  'Instead of this:',
  'You can write this:',
  "You can read it as “if isPacked is true, then (?) render name + ' ✔', otherwise (:) render name”.",
  'If you’re coming from an object-oriented programming background, you might assume that the two examples above are subtly different because one of them may create two different “instances” of <li>. But JSX elements aren’t “instances” because they don’t hold any internal state and aren’t real DOM nodes. They’re lightweight descriptions, like blueprints. So these two examples, in fact, are completely equivalent. Preserving and Resetting State goes into detail about how this works.',
  'Now let’s say you want to wrap the completed item’s text into another HTML tag, like <del> to strike it out. You can add even more newlines and parentheses so that it’s easier to nest more JSX in each of the cases:',
  'This style works well for simple conditions, but use it in moderation. If your components get messy with too much nested conditional markup, consider extracting child components to clean things up. In React, markup is a part of your code, so you can use tools like variables and functions to tidy up complex expressions.',
  'Another common shortcut you’ll encounter is the JavaScript logical AND (&&) operator. Inside React components, it often comes up when you want to render some JSX when the condition is true, or render nothing otherwise. With &&, you could conditionally render the checkmark only if isPacked is true:',
  'You can read this as “if isPacked, then (&&) render the checkmark, otherwise, render nothing”.',
  'Here it is in action:',
  'A JavaScript && expression returns the value of its right side (in our case, the checkmark) if the left side (our condition) is true. But if the condition is false, the whole expression becomes false. React considers false as a “hole” in the JSX tree, just like null or undefined, and doesn’t render anything in its place.',
  'Don’t put numbers on the left side of &&.',
  'To test the condition, JavaScript converts the left side to a boolean automatically. However, if the left side is 0, then the whole expression gets that value (0), and React will happily render 0 rather than nothing.',
  'For example, a common mistake is to write code like messageCount && <p>New messages</p>. It’s easy to assume that it renders nothing when messageCount is 0, but it really renders the 0 itself!',
  'To fix it, make the left side a boolean: messageCount > 0 && <p>New messages</p>.',
  'When the shortcuts get in the way of writing plain code, try using an if statement and a variable. You can reassign variables defined with let, so start by providing the default content you want to display, the name:',
  'Use an if statement to reassign a JSX expression to itemContent if isPacked is true:',
  'Curly braces open the “window into JavaScript”. Embed the variable with curly braces in the returned JSX tree, nesting the previously calculated expression inside of JSX:',
  'This style is the most verbose, but it’s also the most flexible. Here it is in action:',
  'Like before, this works not only for text, but for arbitrary JSX too:',
  'If you’re not familiar with JavaScript, this variety of styles might seem overwhelming at first. However, learning them will help you read and write any JavaScript code — and not just React components! Pick the one you prefer for a start, and then consult this reference again if you forget how the other ones work.',
  'Use the conditional operator (cond ? a : b) to render a ❌ if isPacked isn’t true.',
  'How do you like these docs?'
]
URL:  https://react.dev/learn/rendering-lists
[
  'Is this page useful?',
  'You will often want to display multiple similar components from a collection of data. You can use the JavaScript array methods to manipulate an array of data. On this page, you’ll use filter() and map() with React to filter and transform your array of data into an array of components.',
  'Say that you have a list of content.',
  'The only difference among those list items is their contents, their data. You will often need to show several instances of the same component using different data when building interfaces: from lists of comments to galleries of profile images. In these situations, you can store that data in JavaScript objects and arrays and use methods like map() and filter() to render lists of components from them.',
  'Here’s a short example of how to generate a list of items from an array:',
  'Here is the result:',
  'Notice the sandbox above displays a console error:',
  'You’ll learn how to fix this error later on this page. Before we get to that, let’s add some structure to your data.',
  'This data can be structured even more.',
  "Let’s say you want a way to only show people whose profession is 'chemist'. You can use JavaScript’s filter() method to return just those people. This method takes an array of items, passes them through a “test” (a function that returns true or false), and returns a new array of only those items that passed the test (returned true).",
  "You only want the items where profession is 'chemist'. The “test” function for this looks like (person) => person.profession === 'chemist'. Here’s how to put it together:",
  'Arrow functions implicitly return the expression right after =>, so you didn’t need a return statement:',
  'However, you must write return explicitly if your => is followed by a { curly brace!',
  'Arrow functions containing => { are said to have a “block body”. They let you write more than a single line of code, but you have to write a return statement yourself. If you forget it, nothing gets returned!',
  'Notice that all the sandboxes above show an error in the console:',
  'You need to give each array item a key — a string or a number that uniquely identifies it among other items in that array:',
  'JSX elements directly inside a map() call always need keys!',
  'Keys tell React which array item each component corresponds to, so that it can match them up later. This becomes important if your array items can move (e.g. due to sorting), get inserted, or get deleted. A well-chosen key helps React infer what exactly has happened, and make the correct updates to the DOM tree.',
  'Rather than generating keys on the fly, you should include them in your data:',
  'What do you do when each item needs to render not one, but several DOM nodes?',
  'The short <>...</> Fragment syntax won’t let you pass a key, so you need to either group them into a single <div>, or use the slightly longer and more explicit <Fragment> syntax:',
  'Fragments disappear from the DOM, so this will produce a flat list of <h1>, <p>, <h1>, <p>, and so on.',
  'Different sources of data provide different sources of keys:',
  'Imagine that files on your desktop didn’t have names. Instead, you’d refer to them by their order — the first file, the second file, and so on. You could get used to it, but once you delete a file, it would get confusing. The second file would become the first file, the third file would be the second file, and so on.',
  'File names in a folder and JSX keys in an array serve a similar purpose. They let us uniquely identify an item between its siblings. A well-chosen key provides more information than the position within the array. Even if the position changes due to reordering, the key lets React identify the item throughout its lifetime.',
  'You might be tempted to use an item’s index in the array as its key. In fact, that’s what React will use if you don’t specify a key at all. But the order in which you render items will change over time if an item is inserted, deleted, or if the array gets reordered. Index as a key often leads to subtle and confusing bugs.',
  'Similarly, do not generate keys on the fly, e.g. with key={Math.random()}. This will cause keys to never match up between renders, leading to all your components and DOM being recreated every time. Not only is this slow, but it will also lose any user input inside the list items. Instead, use a stable ID based on the data.',
  'Note that your components won’t receive key as a prop. It’s only used as a hint by React itself. If your component needs an ID, you have to pass it as a separate prop: <Profile key={id} userId={id} />.',
  'On this page you learned:',
  'This example shows a list of all people.',
  "Change it to show two separate lists one after another: Chemists and Everyone Else. Like previously, you can determine whether a person is a chemist by checking if person.profession === 'chemist'.",
  'How do you like these docs?'
]
URL:  https://react.dev/learn/keeping-components-pure
[
  'Is this page useful?',
  'Some JavaScript functions are pure. Pure functions only perform a calculation and nothing more. By strictly only writing your components as pure functions, you can avoid an entire class of baffling bugs and unpredictable behavior as your codebase grows. To get these benefits, though, there are a few rules you must follow.',
  'In computer science (and especially the world of functional programming), a pure function is a function with the following characteristics:',
  'You might already be familiar with one example of pure functions: formulas in math.',
  'Consider this math formula: y = 2x.',
  'If x = 2 then y = 4. Always.',
  'If x = 3 then y = 6. Always.',
  'If x = 3, y won’t sometimes be 9 or –1 or 2.5 depending on the time of day or the state of the stock market.',
  'If y = 2x and x = 3, y will always be 6.',
  'If we made this into a JavaScript function, it would look like this:',
  'In the above example, double is a pure function. If you pass it 3, it will return 6. Always.',
  'React is designed around this concept. React assumes that every component you write is a pure function. This means that React components you write must always return the same JSX given the same inputs:',
  'When you pass drinkers={2} to Recipe, it will return JSX containing 2 cups of water. Always.',
  'If you pass drinkers={4}, it will return JSX containing 4 cups of water. Always.',
  'Just like a math formula.',
  'You could think of your components as recipes: if you follow them and don’t introduce new ingredients during the cooking process, you will get the same dish every time. That “dish” is the JSX that the component serves to React to render.',
  'Illustrated by Rachel Lee Nabors',
  'React’s rendering process must always be pure. Components should only return their JSX, and not change any objects or variables that existed before rendering—that would make them impure!',
  'Here is a component that breaks this rule:',
  'This component is reading and writing a guest variable declared outside of it. This means that calling this component multiple times will produce different JSX! And what’s more, if other components read guest, they will produce different JSX, too, depending on when they were rendered! That’s not predictable.',
  'Going back to our formula y = 2x, now even if x = 2, we cannot trust that y = 4. Our tests could fail, our users would be baffled, planes would fall out of the sky—you can see how this would lead to confusing bugs!',
  'You can fix this component by passing guest as a prop instead:',
  'Now your component is pure, as the JSX it returns only depends on the guest prop.',
  'In general, you should not expect your components to be rendered in any particular order. It doesn’t matter if you call y = 2x before or after y = 5x: both formulas will resolve independently of each other. In the same way, each component should only “think for itself”, and not attempt to coordinate with or depend upon others during rendering. Rendering is like a school exam: each component should calculate JSX on their own!',
  'Although you might not have used them all yet, in React there are three kinds of inputs that you can read while rendering: props, state, and context. You should always treat these inputs as read-only.',
  'When you want to change something in response to user input, you should set state instead of writing to a variable. You should never change preexisting variables or objects while your component is rendering.',
  'React offers a “Strict Mode” in which it calls each component’s function twice during development. By calling the component functions twice, Strict Mode helps find components that break these rules.',
  'Notice how the original example displayed “Guest #2”, “Guest #4”, and “Guest #6” instead of “Guest #1”, “Guest #2”, and “Guest #3”. The original function was impure, so calling it twice broke it. But the fixed pure version works even if the function is called twice every time. Pure functions only calculate, so calling them twice won’t change anything—just like calling double(2) twice doesn’t change what’s returned, and solving y = 2x twice doesn’t change what y is. Same inputs, same outputs. Always.',
  'Strict Mode has no effect in production, so it won’t slow down the app for your users. To opt into Strict Mode, you can wrap your root component into <React.StrictMode>. Some frameworks do this by default.',
  'In the above example, the problem was that the component changed a preexisting variable while rendering. This is often called a “mutation” to make it sound a bit scarier. Pure functions don’t mutate variables outside of the function’s scope or objects that were created before the call—that makes them impure!',
  'However, it’s completely fine to change variables and objects that you’ve just created while rendering. In this example, you create an [] array, assign it to a cups variable, and then push a dozen cups into it:',
  'If the cups variable or the [] array were created outside the TeaGathering function, this would be a huge problem! You would be changing a preexisting object by pushing items into that array.',
  'However, it’s fine because you’ve created them during the same render, inside TeaGathering. No code outside of TeaGathering will ever know that this happened. This is called “local mutation”—it’s like your component’s little secret.',
  'While functional programming relies heavily on purity, at some point, somewhere, something has to change. That’s kind of the point of programming! These changes—updating the screen, starting an animation, changing the data—are called side effects. They’re things that happen “on the side”, not during rendering.',
  'In React, side effects usually belong inside event handlers. Event handlers are functions that React runs when you perform some action—for example, when you click a button. Even though event handlers are defined inside your component, they don’t run during rendering! So event handlers don’t need to be pure.',
  'If you’ve exhausted all other options and can’t find the right event handler for your side effect, you can still attach it to your returned JSX with a useEffect call in your component. This tells React to execute it later, after rendering, when side effects are allowed. However, this approach should be your last resort.',
  'When possible, try to express your logic with rendering alone. You’ll be surprised how far this can take you!',
  'Writing pure functions takes some habit and discipline. But it also unlocks marvelous opportunities:',
  'Every new React feature we’re building takes advantage of purity. From data fetching to animations to performance, keeping components pure unlocks the power of the React paradigm.',
  'This component tries to set the <h1>’s CSS class to "night" during the time from midnight to six hours in the morning, and "day" at all other times. However, it doesn’t work. Can you fix this component?',
  'You can verify whether your solution works by temporarily changing the computer’s timezone. When the current time is between midnight and six in the morning, the clock should have inverted colors!',
  'How do you like these docs?'
]
URL:  https://react.dev/learn/understanding-your-ui-as-a-tree
[
  'Is this page useful?',
  'Your React app is taking shape with many components being nested within each other. How does React keep track of your app’s component structure?',
  'React, and many other UI libraries, model UI as a tree. Thinking of your app as a tree is useful for understanding the relationship between components. This understanding will help you debug future concepts like performance and state management.',
  'Trees are a relationship model between items and UI is often represented using tree structures. For example, browsers use tree structures to model HTML (DOM) and CSS (CSSOM). Mobile platforms also use trees to represent their view hierarchy.',
  'React creates a UI tree from your components. In this example, the UI tree is then used to render to the DOM.',
  'Like browsers and mobile platforms, React also uses tree structures to manage and model the relationship between components in a React app. These trees are useful tools to understand how data flows through a React app and how to optimize rendering and app size.',
  'A major feature of components is the ability to compose components of other components. As we nest components, we have the concept of parent and child components, where each parent component may itself be a child of another component.',
  'When we render a React app, we can model this relationship in a tree, known as the render tree.',
  'Here is a React app that renders inspirational quotes.',
  'React creates a render tree, a UI tree, composed of the rendered components.',
  'From the example app, we can construct the above render tree.',
  'The tree is composed of nodes, each of which represents a component. App, FancyText, Copyright, to name a few, are all nodes in our tree.',
  'The root node in a React render tree is the root component of the app. In this case, the root component is App and it is the first component React renders. Each arrow in the tree points from a parent component to a child component.',
  'You’ll notice in the above render tree, there is no mention of the HTML tags that each component renders. This is because the render tree is only composed of React components.',
  'React, as a UI framework, is platform agnostic. On react.dev, we showcase examples that render to the web, which uses HTML markup as its UI primitives. But a React app could just as likely render to a mobile or desktop platform, which may use different UI primitives like UIView or FrameworkElement.',
  'These platform UI primitives are not a part of React. React render trees can provide insight to our React app regardless of what platform your app renders to.',
  'A render tree represents a single render pass of a React application. With conditional rendering, a parent component may render different children depending on the data passed.',
  'We can update the app to conditionally render either an inspirational quote or color.',
  'With conditional rendering, across different renders, the render tree may render different components.',
  'In this example, depending on what inspiration.type is, we may render <FancyText> or <Color>. The render tree may be different for each render pass.',
  'Although render trees may differ across render passes, these trees are generally helpful for identifying what the top-level and leaf components are in a React app. Top-level components are the components nearest to the root component and affect the rendering performance of all the components beneath them and often contain the most complexity. Leaf components are near the bottom of the tree and have no child components and are often frequently re-rendered.',
  'Identifying these categories of components are useful for understanding data flow and performance of your app.',
  'Another relationship in a React app that can be modeled with a tree are an app’s module dependencies. As we break up our components and logic into separate files, we create JS modules where we may export components, functions, or constants.',
  'Each node in a module dependency tree is a module and each branch represents an import statement in that module.',
  'If we take the previous Inspirations app, we can build a module dependency tree, or dependency tree for short.',
  'The module dependency tree for the Inspirations app.',
  'The root node of the tree is the root module, also known as the entrypoint file. It often is the module that contains the root component.',
  'Comparing to the render tree of the same app, there are similar structures but some notable differences:',
  'Dependency trees are useful to determine what modules are necessary to run your React app. When building a React app for production, there is typically a build step that will bundle all the necessary JavaScript to ship to the client. The tool responsible for this is called a bundler, and bundlers will use the dependency tree to determine what modules should be included.',
  'As your app grows, often the bundle size does too. Large bundle sizes are expensive for a client to download and run. Large bundle sizes can delay the time for your UI to get drawn. Getting a sense of your app’s dependency tree may help with debugging these issues.',
  'How do you like these docs?'
]
URL:  https://react.dev/learn/adding-interactivity
[
  'Is this page useful?',
  'Some things on the screen update in response to user input. For example, clicking an image gallery switches the active image. In React, data that changes over time is called state. You can add state to any component, and update it as needed. In this chapter, you’ll learn how to write components that handle interactions, update their state, and display different output over time.',
  'React lets you add event handlers to your JSX. Event handlers are your own functions that will be triggered in response to user interactions like clicking, hovering, focusing on form inputs, and so on.',
  'Built-in components like <button> only support built-in browser events like onClick. However, you can also create your own components, and give their event handler props any application-specific names that you like.',
  'Read Responding to Events to learn how to add event handlers.',
  'Components often need to change what’s on the screen as a result of an interaction. Typing into the form should update the input field, clicking “next” on an image carousel should change which image is displayed, clicking “buy” puts a product in the shopping cart. Components need to “remember” things: the current input value, the current image, the shopping cart. In React, this kind of component-specific memory is called state.',
  'You can add state to a component with a useState Hook. Hooks are special functions that let your components use React features (state is one of those features). The useState Hook lets you declare a state variable. It takes the initial state and returns a pair of values: the current state, and a state setter function that lets you update it.',
  'Here is how an image gallery uses and updates state on click:',
  'Read State: A Component’s Memory to learn how to remember a value and update it on interaction.',
  'Before your components are displayed on the screen, they must be rendered by React. Understanding the steps in this process will help you think about how your code executes and explain its behavior.',
  'Imagine that your components are cooks in the kitchen, assembling tasty dishes from ingredients. In this scenario, React is the waiter who puts in requests from customers and brings them their orders. This process of requesting and serving UI has three steps:',
  'Illustrated by Rachel Lee Nabors',
  'Read Render and Commit to learn the lifecycle of a UI update.',
  'Unlike regular JavaScript variables, React state behaves more like a snapshot. Setting it does not change the state variable you already have, but instead triggers a re-render. This can be surprising at first!',
  'This behavior help you avoid subtle bugs. Here is a little chat app. Try to guess what happens if you press “Send” first and then change the recipient to Bob. Whose name will appear in the alert five seconds later?',
  'Read State as a Snapshot to learn why state appears “fixed” and unchanging inside the event handlers.',
  'This component is buggy: clicking “+3” increments the score only once.',
  'State as a Snapshot explains why this is happening. Setting state requests a new re-render, but does not change it in the already running code. So score continues to be 0 right after you call setScore(score + 1).',
  'You can fix this by passing an updater function when setting state. Notice how replacing setScore(score + 1) with setScore(s => s + 1) fixes the “+3” button. This lets you queue multiple state updates.',
  'Read Queueing a Series of State Updates to learn how to queue a sequence of state updates.',
  'State can hold any kind of JavaScript value, including objects. But you shouldn’t change objects and arrays that you hold in the React state directly. Instead, when you want to update an object and array, you need to create a new one (or make a copy of an existing one), and then update the state to use that copy.',
  'Usually, you will use the ... spread syntax to copy objects and arrays that you want to change. For example, updating a nested object could look like this:',
  'If copying objects in code gets tedious, you can use a library like Immer to reduce repetitive code:',
  'Read Updating Objects in State to learn how to update objects correctly.',
  'Arrays are another type of mutable JavaScript objects you can store in state and should treat as read-only. Just like with objects, when you want to update an array stored in state, you need to create a new one (or make a copy of an existing one), and then set state to use the new array:',
  'If copying arrays in code gets tedious, you can use a library like Immer to reduce repetitive code:',
  'Read Updating Arrays in State to learn how to update arrays correctly.',
  'Head over to Responding to Events to start reading this chapter page by page!',
  'Or, if you’re already familiar with these topics, why not read about Managing State?',
  'How do you like these docs?'
]
URL:  https://react.dev/learn/responding-to-events
[
  'Is this page useful?',
  'React lets you add event handlers to your JSX. Event handlers are your own functions that will be triggered in response to interactions like clicking, hovering, focusing form inputs, and so on.',
  'To add an event handler, you will first define a function and then pass it as a prop to the appropriate JSX tag. For example, here is a button that doesn’t do anything yet:',
  'You can make it show a message when a user clicks by following these three steps:',
  'You defined the handleClick function and then passed it as a prop to <button>.  handleClick is an event handler. Event handler functions:',
  'By convention, it is common to name event handlers as handle followed by the event name. You’ll often see onClick={handleClick}, onMouseEnter={handleMouseEnter}, and so on.',
  'Alternatively, you can define an event handler inline in the JSX:',
  'Or, more concisely, using an arrow function:',
  'All of these styles are equivalent. Inline event handlers are convenient for short functions.',
  'Functions passed to event handlers must be passed, not called. For example:',
  'The difference is subtle. In the first example, the handleClick function is passed as an onClick event handler. This tells React to remember it and only call your function when the user clicks the button.',
  'In the second example, the () at the end of handleClick() fires the function immediately during rendering, without any clicks. This is because JavaScript inside the JSX { and } executes right away.',
  'When you write code inline, the same pitfall presents itself in a different way:',
  'Passing inline code like this won’t fire on click—it fires every time the component renders:',
  'If you want to define your event handler inline, wrap it in an anonymous function like so:',
  'Rather than executing the code inside with every render, this creates a function to be called later.',
  'In both cases, what you want to pass is a function:',
  'Read more about arrow functions.',
  'Because event handlers are declared inside of a component, they have access to the component’s props. Here is a button that, when clicked, shows an alert with its message prop:',
  'This lets these two buttons show different messages. Try changing the messages passed to them.',
  'Often you’ll want the parent component to specify a child’s event handler. Consider buttons: depending on where you’re using a Button component, you might want to execute a different function—perhaps one plays a movie and another uploads an image.',
  'To do this, pass a prop the component receives from its parent as the event handler like so:',
  'Here, the Toolbar component renders a PlayButton and an UploadButton:',
  'Finally, your Button component accepts a prop called onClick. It passes that prop directly to the built-in browser <button> with onClick={onClick}. This tells React to call the passed function on click.',
  'If you use a design system, it’s common for components like buttons to contain styling but not specify behavior. Instead, components like PlayButton and UploadButton will pass event handlers down.',
  'Built-in components like <button> and <div> only support browser event names like onClick. However, when you’re building your own components, you can name their event handler props any way that you like.',
  'By convention, event handler props should start with on, followed by a capital letter.',
  'For example, the Button component’s onClick prop could have been called onSmash:',
  'In this example, <button onClick={onSmash}> shows that the browser <button> (lowercase) still needs a prop called onClick, but the prop name received by your custom Button component is up to you!',
  'When your component supports multiple interactions, you might name event handler props for app-specific concepts. For example, this Toolbar component receives onPlayMovie and onUploadImage event handlers:',
  'Notice how the App component does not need to know what Toolbar will do with onPlayMovie or onUploadImage. That’s an implementation detail of the Toolbar. Here, Toolbar passes them down as onClick handlers to its Buttons, but it could later also trigger them on a keyboard shortcut. Naming props after app-specific interactions like onPlayMovie gives you the flexibility to change how they’re used later.',
  'Make sure that you use the appropriate HTML tags for your event handlers. For example, to handle clicks, use <button onClick={handleClick}> instead of <div onClick={handleClick}>. Using a real browser <button> enables built-in browser behaviors like keyboard navigation. If you don’t like the default browser styling of a button and want to make it look more like a link or a different UI element, you can achieve it with CSS. Learn more about writing accessible markup.',
  'Event handlers will also catch events from any children your component might have. We say that an event “bubbles” or “propagates” up the tree: it starts with where the event happened, and then goes up the tree.',
  'This <div> contains two buttons. Both the <div> and each button have their own onClick handlers. Which handlers do you think will fire when you click a button?',
  'If you click on either button, its onClick will run first, followed by the parent <div>’s onClick. So two messages will appear. If you click the toolbar itself, only the parent <div>’s onClick will run.',
  'All events propagate in React except onScroll, which only works on the JSX tag you attach it to.',
  'Event handlers receive an event object as their only argument. By convention, it’s usually called e, which stands for “event”. You can use this object to read information about the event.',
  'That event object also lets you stop the propagation. If you want to prevent an event from reaching parent components, you need to call e.stopPropagation() like this Button component does:',
  'When you click on a button:',
  'As a result of e.stopPropagation(), clicking on the buttons now only shows a single alert (from the <button>) rather than the two of them (from the <button> and the parent toolbar <div>). Clicking a button is not the same thing as clicking the surrounding toolbar, so stopping the propagation makes sense for this UI.',
  'In rare cases, you might need to catch all events on child elements, even if they stopped propagation. For example, maybe you want to log every click to analytics, regardless of the propagation logic. You can do this by adding Capture at the end of the event name:',
  'Each event propagates in three phases:',
  'Capture events are useful for code like routers or analytics, but you probably won’t use them in app code.',
  'Notice how this click handler runs a line of code and then calls the onClick prop passed by the parent:',
  'You could add more code to this handler before calling the parent onClick event handler, too. This pattern provides an alternative to propagation. It lets the child component handle the event, while also letting the parent component specify some additional behavior. Unlike propagation, it’s not automatic. But the benefit of this pattern is that you can clearly follow the whole chain of code that executes as a result of some event.',
  'If you rely on propagation and it’s difficult to trace which handlers execute and why, try this approach instead.',
  'Some browser events have default behavior associated with them. For example, a <form> submit event, which happens when a button inside of it is clicked, will reload the whole page by default:',
  'You can call e.preventDefault() on the event object to stop this from happening:',
  'Don’t confuse e.stopPropagation() and e.preventDefault(). They are both useful, but are unrelated:',
  'Absolutely! Event handlers are the best place for side effects.',
  'Unlike rendering functions, event handlers don’t need to be pure, so it’s a great place to change something—for example, change an input’s value in response to typing, or change a list in response to a button press. However, in order to change some information, you first need some way to store it. In React, this is done by using state, a component’s memory. You will learn all about it on the next page.',
  'Clicking this button is supposed to switch the page background between white and black. However, nothing happens when you click it. Fix the problem. (Don’t worry about the logic inside handleClick—that part is fine.)',
  'How do you like these docs?'
]
URL:  https://react.dev/learn/state-a-components-memory
[
  'Is this page useful?',
  'Components often need to change what’s on the screen as a result of an interaction. Typing into the form should update the input field, clicking “next” on an image carousel should change which image is displayed, clicking “buy” should put a product in the shopping cart. Components need to “remember” things: the current input value, the current image, the shopping cart. In React, this kind of component-specific memory is called state.',
  'Here’s a component that renders a sculpture image. Clicking the “Next” button should show the next sculpture by changing the index to 1, then 2, and so on. However, this won’t work (you can try it!):',
  'The handleClick event handler is updating a local variable, index. But two things prevent that change from being visible:',
  'To update a component with new data, two things need to happen:',
  'The useState Hook provides those two things:',
  'To add a state variable, import useState from React at the top of the file:',
  'Then, replace this line:',
  'with',
  'index is a state variable and setIndex is the setter function.',
  'The [ and ] syntax here is called array destructuring and it lets you read values from an array. The array returned by useState always has exactly two items.',
  'This is how they work together in handleClick:',
  'Now clicking the “Next” button switches the current sculpture:',
  'In React, useState, as well as any other function starting with ”use”, is called a Hook.',
  'Hooks are special functions that are only available while React is rendering (which we’ll get into in more detail on the next page). They let you “hook into” different React features.',
  'State is just one of those features, but you will meet the other Hooks later.',
  'Hooks—functions starting with use—can only be called at the top level of your components or your own Hooks. You can’t call Hooks inside conditions, loops, or other nested functions. Hooks are functions, but it’s helpful to think of them as unconditional declarations about your component’s needs. You “use” React features at the top of your component similar to how you “import” modules at the top of your file.',
  'When you call useState, you are telling React that you want this component to remember something:',
  'In this case, you want React to remember index.',
  'The convention is to name this pair like const [something, setSomething]. You could name it anything you like, but conventions make things easier to understand across projects.',
  'The only argument to useState is the initial value of your state variable. In this example, the index’s initial value is set to 0 with useState(0).',
  'Every time your component renders, useState gives you an array containing two values:',
  'Here’s how that happens in action:',
  'You can have as many state variables of as many types as you like in one component. This component has two state variables, a number index and a boolean showMore that’s toggled when you click “Show details”:',
  'It is a good idea to have multiple state variables if their state is unrelated, like index and showMore in this example. But if you find that you often change two state variables together, it might be easier to combine them into one. For example, if you have a form with many fields, it’s more convenient to have a single state variable that holds an object than state variable per field. Read Choosing the State Structure for more tips.',
  'You might have noticed that the useState call does not receive any information about which state variable it refers to. There is no “identifier” that is passed to useState, so how does it know which of the state variables to return? Does it rely on some magic like parsing your functions? The answer is no.',
  'Instead, to enable their concise syntax, Hooks rely on a stable call order on every render of the same component. This works well in practice because if you follow the rule above (“only call Hooks at the top level”), Hooks will always be called in the same order. Additionally, a linter plugin catches most mistakes.',
  'Internally, React holds an array of state pairs for every component. It also maintains the current pair index, which is set to 0 before rendering. Each time you call useState, React gives you the next state pair and increments the index. You can read more about this mechanism in React Hooks: Not Magic, Just Arrays.',
  'This example doesn’t use React but it gives you an idea of how useState works internally:',
  'You don’t have to understand it to use React, but you might find this a helpful mental model.',
  'State is local to a component instance on the screen. In other words, if you render the same component twice, each copy will have completely isolated state! Changing one of them will not affect the other.',
  'In this example, the Gallery component from earlier is rendered twice with no changes to its logic. Try clicking the buttons inside each of the galleries. Notice that their state is independent:',
  'This is what makes state different from regular variables that you might declare at the top of your module. State is not tied to a particular function call or a place in the code, but it’s “local” to the specific place on the screen. You rendered two <Gallery /> components, so their state is stored separately.',
  'Also notice how the Page component doesn’t “know” anything about the Gallery state or even whether it has any. Unlike props, state is fully private to the component declaring it. The parent component can’t change it. This lets you add state to any component or remove it without impacting the rest of the components.',
  'What if you wanted both galleries to keep their states in sync? The right way to do it in React is to remove state from child components and add it to their closest shared parent. The next few pages will focus on organizing state of a single component, but we will return to this topic in Sharing State Between Components.',
  'When you press “Next” on the last sculpture, the code crashes. Fix the logic to prevent the crash. You may do this by adding extra logic to event handler or by disabling the button when the action is not possible.',
  'After fixing the crash, add a “Previous” button that shows the previous sculpture. It shouldn’t crash on the first sculpture.',
  'How do you like these docs?'
]
URL:  https://react.dev/learn/render-and-commit
[
  'Is this page useful?',
  'Before your components are displayed on screen, they must be rendered by React. Understanding the steps in this process will help you think about how your code executes and explain its behavior.',
  'Imagine that your components are cooks in the kitchen, assembling tasty dishes from ingredients. In this scenario, React is the waiter who puts in requests from customers and brings them their orders. This process of requesting and serving UI has three steps:',
  'Illustrated by Rachel Lee Nabors',
  'There are two reasons for a component to render:',
  'When your app starts, you need to trigger the initial render. Frameworks and sandboxes sometimes hide this code, but it’s done by calling createRoot with the target DOM node, and then calling its render method with your component:',
  'Try commenting out the root.render() call and see the component disappear!',
  'Once the component has been initially rendered, you can trigger further renders by updating its state with the set function. Updating your component’s state automatically queues a render. (You can imagine these as a restaurant guest ordering tea, dessert, and all sorts of things after putting in their first order, depending on the state of their thirst or hunger.)',
  'Illustrated by Rachel Lee Nabors',
  'After you trigger a render, React calls your components to figure out what to display on screen. “Rendering” is React calling your components.',
  'This process is recursive: if the updated component returns some other component, React will render that component next, and if that component also returns something, it will render that component next, and so on. The process will continue until there are no more nested components and React knows exactly what should be displayed on screen.',
  'In the following example, React will call Gallery() and  Image() several times:',
  'Rendering must always be a pure calculation:',
  'Otherwise, you can encounter confusing bugs and unpredictable behavior as your codebase grows in complexity. When developing in “Strict Mode”, React calls each component’s function twice, which can help surface mistakes caused by impure functions.',
  'The default behavior of rendering all components nested within the updated component is not optimal for performance if the updated component is very high in the tree. If you run into a performance issue, there are several opt-in ways to solve it described in the Performance section. Don’t optimize prematurely!',
  'After rendering (calling) your components, React will modify the DOM.',
  'React only changes the DOM nodes if there’s a difference between renders. For example, here is a component that re-renders with different props passed from its parent every second. Notice how you can add some text into the <input>, updating its value, but the text doesn’t disappear when the component re-renders:',
  'This works because during this last step, React only updates the content of <h1> with the new time. It sees that the <input> appears in the JSX in the same place as last time, so React doesn’t touch the <input>—or its value!',
  'After rendering is done and React updated the DOM, the browser will repaint the screen. Although this process is known as “browser rendering”, we’ll refer to it as “painting” to avoid confusion throughout the docs.',
  'Illustrated by Rachel Lee Nabors',
  'How do you like these docs?'
]
URL:  https://react.dev/learn/state-as-a-snapshot
[
  'Is this page useful?',
  'State variables might look like regular JavaScript variables that you can read and write to. However, state behaves more like a snapshot. Setting it does not change the state variable you already have, but instead triggers a re-render.',
  'You might think of your user interface as changing directly in response to the user event like a click. In React, it works a little differently from this mental model. On the previous page, you saw that setting state requests a re-render from React. This means that for an interface to react to the event, you need to update the state.',
  'In this example, when you press “send”, setIsSent(true) tells React to re-render the UI:',
  'Here’s what happens when you click the button:',
  'Let’s take a closer look at the relationship between state and rendering.',
  '“Rendering” means that React is calling your component, which is a function. The JSX you return from that function is like a snapshot of the UI in time. Its props, event handlers, and local variables were all calculated using its state at the time of the render.',
  'Unlike a photograph or a movie frame, the UI “snapshot” you return is interactive. It includes logic like event handlers that specify what happens in response to inputs. React updates the screen to match this snapshot and connects the event handlers. As a result, pressing a button will trigger the click handler from your JSX.',
  'When React re-renders a component:',
  'Illustrated by Rachel Lee Nabors',
  'As a component’s memory, state is not like a regular variable that disappears after your function returns. State actually “lives” in React itself—as if on a shelf!—outside of your function. When React calls your component, it gives you a snapshot of the state for that particular render. Your component returns a snapshot of the UI with a fresh set of props and event handlers in its JSX, all calculated using the state values from that render!',
  'Illustrated by Rachel Lee Nabors',
  'Here’s a little experiment to show you how this works. In this example, you might expect that clicking the “+3” button would increment the counter three times because it calls setNumber(number + 1) three times.',
  'See what happens when you click the “+3” button:',
  'Notice that number only increments once per click!',
  'Setting state only changes it for the next render. During the first render, number was 0. This is why, in that render’s onClick handler, the value of number is still 0 even after setNumber(number + 1) was called:',
  'Here is what this button’s click handler tells React to do:',
  'Even though you called setNumber(number + 1) three times, in this render’s event handler number is always 0, so you set the state to 1 three times. This is why, after your event handler finishes, React re-renders the component with number equal to 1 rather than 3.',
  'You can also visualize this by mentally substituting state variables with their values in your code. Since the number state variable is 0 for this render, its event handler looks like this:',
  'For the next render, number is 1, so that render’s click handler looks like this:',
  'This is why clicking the button again will set the counter to 2, then to 3 on the next click, and so on.',
  'Well, that was fun. Try to guess what clicking this button will alert:',
  'If you use the substitution method from before, you can guess that the alert shows “0”:',
  'But what if you put a timer on the alert, so it only fires after the component re-rendered? Would it say “0” or “5”? Have a guess!',
  'Surprised? If you use the substitution method, you can see the “snapshot” of the state passed to the alert.',
  'The state stored in React may have changed by the time the alert runs, but it was scheduled using a snapshot of the state at the time the user interacted with it!',
  'A state variable’s value never changes within a render, even if its event handler’s code is asynchronous. Inside that render’s onClick, the value of number continues to be 0 even after setNumber(number + 5) was called. Its value was “fixed” when React “took the snapshot” of the UI by calling your component.',
  'Here is an example of how that makes your event handlers less prone to timing mistakes. Below is a form that sends a message with a five-second delay. Imagine this scenario:',
  'What do you expect the alert to display? Would it display, “You said Hello to Alice”? Or would it display, “You said Hello to Bob”? Make a guess based on what you know, and then try it:',
  'React keeps the state values “fixed” within one render’s event handlers. You don’t need to worry whether the state has changed while the code is running.',
  'But what if you wanted to read the latest state before a re-render? You’ll want to use a state updater function, covered on the next page!',
  'Here is a crosswalk light component that toggles when the button is pressed:',
  'Add an alert to the click handler. When the light is green and says “Walk”, clicking the button should say “Stop is next”. When the light is red and says “Stop”, clicking the button should say “Walk is next”.',
  'Does it make a difference whether you put the alert before or after the setWalk call?',
  'How do you like these docs?'
]
URL:  https://react.dev/learn/queueing-a-series-of-state-updates
[
  'Is this page useful?',
  'Setting a state variable will queue another render. But sometimes you might want to perform multiple operations on the value before queueing the next render. To do this, it helps to understand how React batches state updates.',
  'You might expect that clicking the “+3” button will increment the counter three times because it calls setNumber(number + 1) three times:',
  'However, as you might recall from the previous section, each render’s state values are fixed, so the value of number inside the first render’s event handler is always 0, no matter how many times you call setNumber(1):',
  'But there is one other factor at play here. React waits until all code in the event handlers has run before processing your state updates. This is why the re-render only happens after all these setNumber() calls.',
  'This might remind you of a waiter taking an order at the restaurant. A waiter doesn’t run to the kitchen at the mention of your first dish! Instead, they let you finish your order, let you make changes to it, and even take orders from other people at the table.',
  'Illustrated by Rachel Lee Nabors',
  'This lets you update multiple state variables—even from multiple components—without triggering too many re-renders. But this also means that the UI won’t be updated until after your event handler, and any code in it, completes. This behavior, also known as batching, makes your React app run much faster. It also avoids dealing with confusing “half-finished” renders where only some of the variables have been updated.',
  'React does not batch across multiple intentional events like clicks—each click is handled separately. Rest assured that React only does batching when it’s generally safe to do. This ensures that, for example, if the first button click disables a form, the second click would not submit it again.',
  'It is an uncommon use case, but if you would like to update the same state variable multiple times before the next render, instead of passing the next state value like setNumber(number + 1), you can pass a function that calculates the next state based on the previous one in the queue, like setNumber(n => n + 1). It is a way to tell React to “do something with the state value” instead of just replacing it.',
  'Try incrementing the counter now:',
  'Here, n => n + 1 is called an updater function. When you pass it to a state setter:',
  'Here’s how React works through these lines of code while executing the event handler:',
  'When you call useState during the next render, React goes through the queue. The previous number state was 0, so that’s what React passes to the first updater function as the n argument. Then React takes the return value of your previous updater function and passes it to the next updater as n, and so on:',
  'React stores 3 as the final result and returns it from useState.',
  'This is why clicking “+3” in the above example correctly increments the value by 3.',
  'What about this event handler? What do you think number will be in the next render?',
  'Here’s what this event handler tells React to do:',
  'During the next render, React goes through the state queue:',
  'React stores 6 as the final result and returns it from useState.',
  'You may have noticed that setState(5) actually works like setState(n => 5), but n is unused!',
  'Let’s try one more example. What do you think number will be in the next render?',
  'Here’s how React works through these lines of code while executing this event handler:',
  'During the next render, React goes through the state queue:',
  'Then React stores 42 as the final result and returns it from useState.',
  'To summarize, here’s how you can think of what you’re passing to the setNumber state setter:',
  'After the event handler completes, React will trigger a re-render. During the re-render, React will process the queue. Updater functions run during rendering, so updater functions must be pure and only return the result. Don’t try to set state from inside of them or run other side effects. In Strict Mode, React will run each updater function twice (but discard the second result) to help you find mistakes.',
  'It’s common to name the updater function argument by the first letters of the corresponding state variable:',
  'If you prefer more verbose code, another common convention is to repeat the full state variable name, like setEnabled(enabled => !enabled), or to use a prefix like setEnabled(prevEnabled => !prevEnabled).',
  'You’re working on an art marketplace app that lets the user submit multiple orders for an art item at the same time. Each time the user presses the “Buy” button, the “Pending” counter should increase by one. After three seconds, the “Pending” counter should decrease, and the “Completed” counter should increase.',
  'However, the “Pending” counter does not behave as intended. When you press “Buy”, it decreases to -1 (which should not be possible!). And if you click fast twice, both counters seem to behave unpredictably.',
  'Why does this happen? Fix both counters.',
  'How do you like these docs?'
]
URL:  https://react.dev/learn/updating-objects-in-state
[
  'Is this page useful?',
  'State can hold any kind of JavaScript value, including objects. But you shouldn’t change objects that you hold in the React state directly. Instead, when you want to update an object, you need to create a new one (or make a copy of an existing one), and then set the state to use that copy.',
  'You can store any kind of JavaScript value in state.',
  'So far you’ve been working with numbers, strings, and booleans. These kinds of JavaScript values are “immutable”, meaning unchangeable or “read-only”. You can trigger a re-render to replace a value:',
  'The x state changed from 0 to 5, but the number 0 itself did not change. It’s not possible to make any changes to the built-in primitive values like numbers, strings, and booleans in JavaScript.',
  'Now consider an object in state:',
  'Technically, it is possible to change the contents of the object itself. This is called a mutation:',
  'However, although objects in React state are technically mutable, you should treat them as if they were immutable—like numbers, booleans, and strings. Instead of mutating them, you should always replace them.',
  'In other words, you should treat any JavaScript object that you put into state as read-only.',
  'This example holds an object in state to represent the current pointer position. The red dot is supposed to move when you touch or move the cursor over the preview area. But the dot stays in the initial position:',
  'The problem is with this bit of code.',
  'This code modifies the object assigned to position from the previous render. But without using the state setting function, React has no idea that object has changed. So React does not do anything in response. It’s like trying to change the order after you’ve already eaten the meal. While mutating state can work in some cases, we don’t recommend it. You should treat the state value you have access to in a render as read-only.',
  'To actually trigger a re-render in this case, create a new object and pass it to the state setting function:',
  'With setPosition, you’re telling React:',
  'Notice how the red dot now follows your pointer when you touch or hover over the preview area:',
  'Code like this is a problem because it modifies an existing object in state:',
  'But code like this is absolutely fine because you’re mutating a fresh object you have just created:',
  'In fact, it is completely equivalent to writing this:',
  'Mutation is only a problem when you change existing objects that are already in state. Mutating an object you’ve just created is okay because no other code references it yet. Changing it isn’t going to accidentally impact something that depends on it. This is called a “local mutation”. You can even do local mutation while rendering. Very convenient and completely okay!',
  'In the previous example, the position object is always created fresh from the current cursor position. But often, you will want to include existing data as a part of the new object you’re creating. For example, you may want to update only one field in a form, but keep the previous values for all other fields.',
  'These input fields don’t work because the onChange handlers mutate the state:',
  'For example, this line mutates the state from a past render:',
  'The reliable way to get the behavior you’re looking for is to create a new object and pass it to setPerson. But here, you want to also copy the existing data into it because only one of the fields has changed:',
  'You can use the ... object spread syntax so that you don’t need to copy every property separately.',
  'Now the form works!',
  'Notice how you didn’t declare a separate state variable for each input field. For large forms, keeping all data grouped in an object is very convenient—as long as you update it correctly!',
  'Note that the ... spread syntax is “shallow”—it only copies things one level deep. This makes it fast, but it also means that if you want to update a nested property, you’ll have to use it more than once.',
  'You can also use the [ and ] braces inside your object definition to specify a property with dynamic name. Here is the same example, but with a single event handler instead of three different ones:',
  'Here, e.target.name refers to the name property given to the <input> DOM element.',
  'Consider a nested object structure like this:',
  'If you wanted to update person.artwork.city, it’s clear how to do it with mutation:',
  'But in React, you treat state as immutable! In order to change city, you would first need to produce the new artwork object (pre-populated with data from the previous one), and then produce the new person object which points at the new artwork:',
  'Or, written as a single function call:',
  'This gets a bit wordy, but it works fine for many cases:',
  'An object like this appears “nested” in code:',
  'However, “nesting” is an inaccurate way to think about how objects behave. When the code executes, there is no such thing as a “nested” object. You are really looking at two different objects:',
  'The obj1 object is not “inside” obj2. For example, obj3 could “point” at obj1 too:',
  'If you were to mutate obj3.artwork.city, it would affect both obj2.artwork.city and obj1.city. This is because obj3.artwork, obj2.artwork, and obj1 are the same object. This is difficult to see when you think of objects as “nested”. Instead, they are separate objects “pointing” at each other with properties.',
  'If your state is deeply nested, you might want to consider flattening it. But, if you don’t want to change your state structure, you might prefer a shortcut to nested spreads. Immer is a popular library that lets you write using the convenient but mutating syntax and takes care of producing the copies for you. With Immer, the code you write looks like you are “breaking the rules” and mutating an object:',
  'But unlike a regular mutation, it doesn’t overwrite the past state!',
  'The draft provided by Immer is a special type of object, called a Proxy, that “records” what you do with it. This is why you can mutate it freely as much as you like! Under the hood, Immer figures out which parts of the draft have been changed, and produces a completely new object that contains your edits.',
  'To try Immer:',
  'Here is the above example converted to Immer:',
  'Notice how much more concise the event handlers have become. You can mix and match useState and useImmer in a single component as much as you like. Immer is a great way to keep the update handlers concise, especially if there’s nesting in your state, and copying objects leads to repetitive code.',
  'There are a few reasons:',
  'In practice, you can often “get away” with mutating state in React, but we strongly advise you not to do that so that you can use new React features developed with this approach in mind. Future contributors and perhaps even your future self will thank you!',
  'This form has a few bugs. Click the button that increases the score a few times. Notice that it does not increase. Then edit the first name, and notice that the score has suddenly “caught up” with your changes. Finally, edit the last name, and notice that the score has disappeared completely.',
  'Your task is to fix all of these bugs. As you fix them, explain why each of them happens.',
  'How do you like these docs?'
]
URL:  https://react.dev/learn/updating-arrays-in-state
[
  'Is this page useful?',
  'Arrays are mutable in JavaScript, but you should treat them as immutable when you store them in state. Just like with objects, when you want to update an array stored in state, you need to create a new one (or make a copy of an existing one), and then set state to use the new array.',
  "In JavaScript, arrays are just another kind of object. Like with objects, you should treat arrays in React state as read-only. This means that you shouldn’t reassign items inside an array like arr[0] = 'bird', and you also shouldn’t use methods that mutate the array, such as push() and pop().",
  'Instead, every time you want to update an array, you’ll want to pass a new array to your state setting function. To do that, you can create a new array from the original array in your state by calling its non-mutating methods like filter() and map(). Then you can set your state to the resulting new array.',
  'Here is a reference table of common array operations. When dealing with arrays inside React state, you will need to avoid the methods in the left column, and instead prefer the methods in the right column:',
  'Alternatively, you can use Immer which lets you use methods from both columns.',
  'Unfortunately, slice and splice are named similarly but are very different:',
  'In React, you will be using slice (no p!) a lot more often because you don’t want to mutate objects or arrays in state. Updating Objects explains what mutation is and why it’s not recommended for state.',
  'push() will mutate an array, which you don’t want:',
  'Instead, create a new array which contains the existing items and a new item at the end. There are multiple ways to do this, but the easiest one is to use the ... array spread syntax:',
  'Now it works correctly:',
  'The array spread syntax also lets you prepend an item by placing it before the original ...artists:',
  'In this way, spread can do the job of both push() by adding to the end of an array and unshift() by adding to the beginning of an array. Try it in the sandbox above!',
  'The easiest way to remove an item from an array is to filter it out. In other words, you will produce a new array that will not contain that item. To do this, use the filter method, for example:',
  'Click the “Delete” button a few times, and look at its click handler.',
  'Here, artists.filter(a => a.id !== artist.id) means “create an array that consists of those artists whose IDs are different from artist.id”. In other words, each artist’s “Delete” button will filter that artist out of the array, and then request a re-render with the resulting array. Note that filter does not modify the original array.',
  'If you want to change some or all items of the array, you can use map() to create a new array. The function you will pass to map can decide what to do with each item, based on its data or its index (or both).',
  'In this example, an array holds coordinates of two circles and a square. When you press the button, it moves only the circles down by 50 pixels. It does this by producing a new array of data using map():',
  "It is particularly common to want to replace one or more items in an array. Assignments like arr[0] = 'bird' are mutating the original array, so instead you’ll want to use map for this as well.",
  'To replace an item, create a new array with map. Inside your map call, you will receive the item index as the second argument. Use it to decide whether to return the original item (the first argument) or something else:',
  'Sometimes, you may want to insert an item at a particular position that’s neither at the beginning nor at the end. To do this, you can use the ... array spread syntax together with the slice() method. The slice() method lets you cut a “slice” of the array. To insert an item, you will create an array that spreads the slice before the insertion point, then the new item, and then the rest of the original array.',
  'In this example, the Insert button always inserts at the index 1:',
  'There are some things you can’t do with the spread syntax and non-mutating methods like map() and filter() alone. For example, you may want to reverse or sort an array. The JavaScript reverse() and sort() methods are mutating the original array, so you can’t use them directly.',
  'However, you can copy the array first, and then make changes to it.',
  'For example:',
  'Here, you use the [...list] spread syntax to create a copy of the original array first. Now that you have a copy, you can use mutating methods like nextList.reverse() or nextList.sort(), or even assign individual items with nextList[0] = "something".',
  'However, even if you copy an array, you can’t mutate existing items inside of it directly. This is because copying is shallow—the new array will contain the same items as the original one. So if you modify an object inside the copied array, you are mutating the existing state. For example, code like this is a problem.',
  'Although nextList and list are two different arrays, nextList[0] and list[0] point to the same object. So by changing nextList[0].seen, you are also changing list[0].seen. This is a state mutation, which you should avoid! You can solve this issue in a similar way to updating nested JavaScript objects—by copying individual items you want to change instead of mutating them. Here’s how.',
  'Objects are not really located “inside” arrays. They might appear to be “inside” in code, but each object in an array is a separate value, to which the array “points”. This is why you need to be careful when changing nested fields like list[0]. Another person’s artwork list may point to the same element of the array!',
  'When updating nested state, you need to create copies from the point where you want to update, and all the way up to the top level. Let’s see how this works.',
  'In this example, two separate artwork lists have the same initial state. They are supposed to be isolated, but because of a mutation, their state is accidentally shared, and checking a box in one list affects the other list:',
  'The problem is in code like this:',
  'Although the myNextList array itself is new, the items themselves are the same as in the original myList array. So changing artwork.seen changes the original artwork item. That artwork item is also in yourList, which causes the bug. Bugs like this can be difficult to think about, but thankfully they disappear if you avoid mutating state.',
  'You can use map to substitute an old item with its updated version without mutation.',
  'Here, ... is the object spread syntax used to create a copy of an object.',
  'With this approach, none of the existing state items are being mutated, and the bug is fixed:',
  'In general, you should only mutate objects that you have just created. If you were inserting a new artwork, you could mutate it, but if you’re dealing with something that’s already in state, you need to make a copy.',
  'Updating nested arrays without mutation can get a little bit repetitive. Just as with objects:',
  'Here is the Art Bucket List example rewritten with Immer:',
  'Note how with Immer, mutation like artwork.seen = nextSeen is now okay:',
  'This is because you’re not mutating the original state, but you’re mutating a special draft object provided by Immer. Similarly, you can apply mutating methods like push() and pop() to the content of the draft.',
  'Behind the scenes, Immer always constructs the next state from scratch according to the changes that you’ve done to the draft. This keeps your event handlers very concise without ever mutating state.',
  'Fill in the handleIncreaseClick logic so that pressing ”+” increases the corresponding number:',
  'How do you like these docs?'
]
URL:  https://react.dev/learn/managing-state
[
  'Is this page useful?',
  'As your application grows, it helps to be more intentional about how your state is organized and how the data flows between your components. Redundant or duplicate state is a common source of bugs. In this chapter, you’ll learn how to structure your state well, how to keep your state update logic maintainable, and how to share state between distant components.',
  'With React, you won’t modify the UI from code directly. For example, you won’t write commands like “disable the button”, “enable the button”, “show the success message”, etc. Instead, you will describe the UI you want to see for the different visual states of your component (“initial state”, “typing state”, “success state”), and then trigger the state changes in response to user input. This is similar to how designers think about UI.',
  'Here is a quiz form built using React. Note how it uses the status state variable to determine whether to enable or disable the submit button, and whether to show the success message instead.',
  'Read Reacting to Input with State to learn how to approach interactions with a state-driven mindset.',
  'Structuring state well can make a difference between a component that is pleasant to modify and debug, and one that is a constant source of bugs. The most important principle is that state shouldn’t contain redundant or duplicated information. If there’s unnecessary state, it’s easy to forget to update it, and introduce bugs!',
  'For example, this form has a redundant fullName state variable:',
  'You can remove it and simplify the code by calculating fullName while the component is rendering:',
  'This might seem like a small change, but many bugs in React apps are fixed this way.',
  'Read Choosing the State Structure to learn how to design the state shape to avoid bugs.',
  'Sometimes, you want the state of two components to always change together. To do it, remove state from both of them, move it to their closest common parent, and then pass it down to them via props. This is known as “lifting state up”, and it’s one of the most common things you will do writing React code.',
  'In this example, only one panel should be active at a time. To achieve this, instead of keeping the active state inside each individual panel, the parent component holds the state and specifies the props for its children.',
  'Read Sharing State Between Components to learn how to lift state up and keep components in sync.',
  'When you re-render a component, React needs to decide which parts of the tree to keep (and update), and which parts to discard or re-create from scratch. In most cases, React’s automatic behavior works well enough. By default, React preserves the parts of the tree that “match up” with the previously rendered component tree.',
  'However, sometimes this is not what you want. In this chat app, typing a message and then switching the recipient does not reset the input. This can make the user accidentally send a message to the wrong person:',
  'React lets you override the default behavior, and force a component to reset its state by passing it a different key, like <Chat key={email} />. This tells React that if the recipient is different, it should be considered a different Chat component that needs to be re-created from scratch with the new data (and UI like inputs). Now switching between the recipients resets the input field—even though you render the same component.',
  'Read Preserving and Resetting State to learn the lifetime of state and how to control it.',
  'Components with many state updates spread across many event handlers can get overwhelming. For these cases, you can consolidate all the state update logic outside your component in a single function, called “reducer”. Your event handlers become concise because they only specify the user “actions”. At the bottom of the file, the reducer function specifies how the state should update in response to each action!',
  'Read Extracting State Logic into a Reducer to learn how to consolidate logic in the reducer function.',
  'Usually, you will pass information from a parent component to a child component via props. But passing props can become inconvenient if you need to pass some prop through many components, or if many components need the same information. Context lets the parent component make some information available to any component in the tree below it—no matter how deep it is—without passing it explicitly through props.',
  'Here, the Heading component determines its heading level by “asking” the closest Section for its level. Each Section tracks its own level by asking the parent Section and adding one to it. Every Section provides information to all components below it without passing props—it does that through context.',
  'Read Passing Data Deeply with Context to learn about using context as an alternative to passing props.',
  'Reducers let you consolidate a component’s state update logic. Context lets you pass information deep down to other components. You can combine reducers and context together to manage state of a complex screen.',
  'With this approach, a parent component with complex state manages it with a reducer. Other components anywhere deep in the tree can read its state via context. They can also dispatch actions to update that state.',
  'Read Scaling Up with Reducer and Context to learn how state management scales in a growing app.',
  'Head over to Reacting to Input with State to start reading this chapter page by page!',
  'Or, if you’re already familiar with these topics, why not read about Escape Hatches?',
  'How do you like these docs?'
]
URL:  https://react.dev/learn/reacting-to-input-with-state
[
  'Is this page useful?',
  'React provides a declarative way to manipulate the UI. Instead of manipulating individual pieces of the UI directly, you describe the different states that your component can be in, and switch between them in response to the user input. This is similar to how designers think about the UI.',
  'When you design UI interactions, you probably think about how the UI changes in response to user actions. Consider a form that lets the user submit an answer:',
  'In imperative programming, the above corresponds directly to how you implement interaction. You have to write the exact instructions to manipulate the UI depending on what just happened. Here’s another way to think about this: imagine riding next to someone in a car and telling them turn by turn where to go.',
  'Illustrated by Rachel Lee Nabors',
  'They don’t know where you want to go, they just follow your commands. (And if you get the directions wrong, you end up in the wrong place!) It’s called imperative because you have to “command” each element, from the spinner to the button, telling the computer how to update the UI.',
  'In this example of imperative UI programming, the form is built without React. It only uses the browser DOM:',
  'Manipulating the UI imperatively works well enough for isolated examples, but it gets exponentially more difficult to manage in more complex systems. Imagine updating a page full of different forms like this one. Adding a new UI element or a new interaction would require carefully checking all existing code to make sure you haven’t introduced a bug (for example, forgetting to show or hide something).',
  'React was built to solve this problem.',
  'In React, you don’t directly manipulate the UI—meaning you don’t enable, disable, show, or hide components directly. Instead, you declare what you want to show, and React figures out how to update the UI. Think of getting into a taxi and telling the driver where you want to go instead of telling them exactly where to turn. It’s the driver’s job to get you there, and they might even know some shortcuts you haven’t considered!',
  'Illustrated by Rachel Lee Nabors',
  'You’ve seen how to implement a form imperatively above. To better understand how to think in React, you’ll walk through reimplementing this UI in React below:',
  'In computer science, you may hear about a “state machine” being in one of several “states”. If you work with a designer, you may have seen mockups for different “visual states”. React stands at the intersection of design and computer science, so both of these ideas are sources of inspiration.',
  'First, you need to visualize all the different “states” of the UI the user might see:',
  "Just like a designer, you’ll want to “mock up” or create “mocks” for the different states before you add logic. For example, here is a mock for just the visual part of the form. This mock is controlled by a prop called status with a default value of 'empty':",
  "You could call that prop anything you like, the naming is not important. Try editing status = 'empty' to status = 'success' to see the success message appear. Mocking lets you quickly iterate on the UI before you wire up any logic. Here is a more fleshed out prototype of the same component, still “controlled” by the status prop:",
  'If a component has a lot of visual states, it can be convenient to show them all on one page:',
  'Pages like this are often called “living styleguides” or “storybooks”.',
  'You can trigger state updates in response to two kinds of inputs:',
  'Illustrated by Rachel Lee Nabors',
  'In both cases, you must set state variables to update the UI. For the form you’re developing, you will need to change state in response to a few different inputs:',
  'Notice that human inputs often require event handlers!',
  'To help visualize this flow, try drawing each state on paper as a labeled circle, and each change between two states as an arrow. You can sketch out many flows this way and sort out bugs long before implementation.',
  'Form states',
  'Next you’ll need to represent the visual states of your component in memory with useState. Simplicity is key: each piece of state is a “moving piece”, and you want as few “moving pieces” as possible. More complexity leads to more bugs!',
  'Start with the state that absolutely must be there. For example, you’ll need to store the answer for the input, and the error (if it exists) to store the last error:',
  'Then, you’ll need a state variable representing which one of the visual states that you want to display. There’s usually more than a single way to represent that in memory, so you’ll need to experiment with it.',
  'If you struggle to think of the best way immediately, start by adding enough state that you’re definitely sure that all the possible visual states are covered:',
  'Your first idea likely won’t be the best, but that’s ok—refactoring state is a part of the process!',
  'You want to avoid duplication in the state content so you’re only tracking what is essential. Spending a little time on refactoring your state structure will make your components easier to understand, reduce duplication, and avoid unintended meanings. Your goal is to prevent the cases where the state in memory doesn’t represent any valid UI that you’d want a user to see. (For example, you never want to show an error message and disable the input at the same time, or the user won’t be able to correct the error!)',
  'Here are some questions you can ask about your state variables:',
  'After this clean-up, you’re left with 3 (down from 7!) essential state variables:',
  'You know they are essential, because you can’t remove any of them without breaking the functionality.',
  "These three variables are a good enough representation of this form’s state. However, there are still some intermediate states that don’t fully make sense. For example, a non-null error doesn’t make sense when status is 'success'. To model the state more precisely, you can extract it into a reducer. Reducers let you unify multiple state variables into a single object and consolidate all the related logic!",
  'Lastly, create event handlers that update the state. Below is the final form, with all event handlers wired up:',
  'Although this code is longer than the original imperative example, it is much less fragile. Expressing all interactions as state changes lets you later introduce new visual states without breaking existing ones. It also lets you change what should be displayed in each state without changing the logic of the interaction itself.',
  'Make it so that clicking on the picture removes the background--active CSS class from the outer <div>, but adds the picture--active class to the <img>. Clicking the background again should restore the original CSS classes.',
  'Visually, you should expect that clicking on the picture removes the purple background and highlights the picture border. Clicking outside the picture highlights the background, but removes the picture border highlight.',
  'How do you like these docs?'
]
URL:  https://react.dev/learn/choosing-the-state-structure
[
  'Is this page useful?',
  'Structuring state well can make a difference between a component that is pleasant to modify and debug, and one that is a constant source of bugs. Here are some tips you should consider when structuring state.',
  'When you write a component that holds some state, you’ll have to make choices about how many state variables to use and what the shape of their data should be. While it’s possible to write correct programs even with a suboptimal state structure, there are a few principles that can guide you to make better choices:',
  'The goal behind these principles is to make state easy to update without introducing mistakes. Removing redundant and duplicate data from state helps ensure that all its pieces stay in sync. This is similar to how a database engineer might want to “normalize” the database structure to reduce the chance of bugs. To paraphrase Albert Einstein, “Make your state as simple as it can be—but no simpler.”',
  'Now let’s see how these principles apply in action.',
  'You might sometimes be unsure between using a single or multiple state variables.',
  'Should you do this?',
  'Or this?',
  'Technically, you can use either of these approaches. But if some two state variables always change together, it might be a good idea to unify them into a single state variable. Then you won’t forget to always keep them in sync, like in this example where moving the cursor updates both coordinates of the red dot:',
  'Another case where you’ll group data into an object or an array is when you don’t know how many pieces of state you’ll need. For example, it’s helpful when you have a form where the user can add custom fields.',
  'If your state variable is an object, remember that you can’t update only one field in it without explicitly copying the other fields. For example, you can’t do setPosition({ x: 100 }) in the above example because it would not have the y property at all! Instead, if you wanted to set x alone, you would either do setPosition({ ...position, x: 100 }), or split them into two state variables and do setX(100).',
  'Here is a hotel feedback form with isSending and isSent state variables:',
  'While this code works, it leaves the door open for “impossible” states. For example, if you forget to call setIsSent and setIsSending together, you may end up in a situation where both isSending and isSent are true at the same time. The more complex your component is, the harder it is to understand what happened.',
  "Since isSending and isSent should never be true at the same time, it is better to replace them with one status state variable that may take one of three valid states: 'typing' (initial), 'sending', and 'sent':",
  'You can still declare some constants for readability:',
  'But they’re not state variables, so you don’t need to worry about them getting out of sync with each other.',
  'If you can calculate some information from the component’s props or its existing state variables during rendering, you should not put that information into that component’s state.',
  'For example, take this form. It works, but can you find any redundant state in it?',
  'This form has three state variables: firstName, lastName, and fullName. However, fullName is redundant. You can always calculate fullName from firstName and lastName during render, so remove it from state.',
  'This is how you can do it:',
  'Here, fullName is not a state variable. Instead, it’s calculated during render:',
  'As a result, the change handlers don’t need to do anything special to update it. When you call setFirstName or setLastName, you trigger a re-render, and then the next fullName will be calculated from the fresh data.',
  'A common example of redundant state is code like this:',
  "Here, a color state variable is initialized to the messageColor prop. The problem is that if the parent component passes a different value of messageColor later (for example, 'red' instead of 'blue'), the color state variable would not be updated! The state is only initialized during the first render.",
  'This is why “mirroring” some prop in a state variable can lead to confusion. Instead, use the messageColor prop directly in your code. If you want to give it a shorter name, use a constant:',
  'This way it won’t get out of sync with the prop passed from the parent component.',
  '“Mirroring” props into state only makes sense when you want to ignore all updates for a specific prop. By convention, start the prop name with initial or default to clarify that its new values are ignored:',
  'This menu list component lets you choose a single travel snack out of several:',
  'Currently, it stores the selected item as an object in the selectedItem state variable. However, this is not great: the contents of the selectedItem is the same object as one of the items inside the items list. This means that the information about the item itself is duplicated in two places.',
  'Why is this a problem? Let’s make each item editable:',
  'Notice how if you first click “Choose” on an item and then edit it, the input updates but the label at the bottom does not reflect the edits. This is because you have duplicated state, and you forgot to update selectedItem.',
  'Although you could update selectedItem too, an easier fix is to remove duplication. In this example, instead of a selectedItem object (which creates a duplication with objects inside items), you hold the selectedId in state, and then get the selectedItem by searching the items array for an item with that ID:',
  '(Alternatively, you may hold the selected index in state.)',
  'The state used to be duplicated like this:',
  'But after the change it’s like this:',
  'The duplication is gone, and you only keep the essential state!',
  'Now if you edit the selected item, the message below will update immediately. This is because setItems triggers a re-render, and items.find(...) would find the item with the updated title. You didn’t need to hold the selected item in state, because only the selected ID is essential. The rest could be calculated during render.',
  'Imagine a travel plan consisting of planets, continents, and countries. You might be tempted to structure its state using nested objects and arrays, like in this example:',
  'Now let’s say you want to add a button to delete a place you’ve already visited. How would you go about it? Updating nested state involves making copies of objects all the way up from the part that changed. Deleting a deeply nested place would involve copying its entire parent place chain. Such code can be very verbose.',
  'If the state is too nested to update easily, consider making it “flat”. Here is one way you can restructure this data. Instead of a tree-like structure where each place has an array of its child places, you can have each place hold an array of its child place IDs. Then store a mapping from each place ID to the corresponding place.',
  'This data restructuring might remind you of seeing a database table:',
  'Now that the state is “flat” (also known as “normalized”), updating nested items becomes easier.',
  'In order to remove a place now, you only need to update two levels of state:',
  'Here is an example of how you could go about it:',
  'You can nest state as much as you like, but making it “flat” can solve numerous problems. It makes state easier to update, and it helps ensure you don’t have duplication in different parts of a nested object.',
  'Ideally, you would also remove the deleted items (and their children!) from the “table” object to improve memory usage. This version does that. It also uses Immer to make the update logic more concise.',
  'Sometimes, you can also reduce state nesting by moving some of the nested state into the child components. This works well for ephemeral UI state that doesn’t need to be stored, like whether an item is hovered.',
  'This Clock component receives two props: color and time. When you select a different color in the select box, the Clock component receives a different color prop from its parent component. However, for some reason, the displayed color doesn’t update. Why? Fix the problem.',
  'How do you like these docs?'
]
URL:  https://react.dev/learn/sharing-state-between-components
[
  'Is this page useful?',
  'Sometimes, you want the state of two components to always change together. To do it, remove state from both of them, move it to their closest common parent, and then pass it down to them via props. This is known as lifting state up, and it’s one of the most common things you will do writing React code.',
  'In this example, a parent Accordion component renders two separate Panels:',
  'Each Panel component has a boolean isActive state that determines whether its content is visible.',
  'Press the Show button for both panels:',
  'Notice how pressing one panel’s button does not affect the other panel—they are independent.',
  'Initially, each Panel’s isActive state is false, so they both appear collapsed',
  'Clicking either Panel’s button will only update that Panel’s isActive state alone',
  'But now let’s say you want to change it so that only one panel is expanded at any given time. With that design, expanding the second panel should collapse the first one. How would you do that?',
  'To coordinate these two panels, you need to “lift their state up” to a parent component in three steps:',
  'This will allow the Accordion component to coordinate both Panels and only expand one at a time.',
  'You will give control of the Panel’s isActive to its parent component. This means that the parent component will pass isActive to Panel as a prop instead. Start by removing this line from the Panel component:',
  'And instead, add isActive to the Panel’s list of props:',
  'Now the Panel’s parent component can control isActive by passing it down as a prop. Conversely, the Panel component now has no control over the value of isActive—it’s now up to the parent component!',
  'To lift state up, you must locate the closest common parent component of both of the child components that you want to coordinate:',
  'In this example, it’s the Accordion component. Since it’s above both panels and can control their props, it will become the “source of truth” for which panel is currently active. Make the Accordion component pass a hardcoded value of isActive (for example, true) to both panels:',
  'Try editing the hardcoded isActive values in the Accordion component and see the result on the screen.',
  'Lifting state up often changes the nature of what you’re storing as state.',
  'In this case, only one panel should be active at a time. This means that the Accordion common parent component needs to keep track of which panel is the active one. Instead of a boolean value, it could use a number as the index of the active Panel for the state variable:',
  'When the activeIndex is 0, the first panel is active, and when it’s 1, it’s the second one.',
  'Clicking the “Show” button in either Panel needs to change the active index in Accordion. A Panel can’t set the activeIndex state directly because it’s defined inside the Accordion. The Accordion component needs to explicitly allow the Panel component to change its state by passing an event handler down as a prop:',
  'The <button> inside the Panel will now use the onShow prop as its click event handler:',
  'This completes lifting state up! Moving state into the common parent component allowed you to coordinate the two panels. Using the active index instead of two “is shown” flags ensured that only one panel is active at a given time. And passing down the event handler to the child allowed the child to change the parent’s state.',
  'Initially, Accordion’s activeIndex is 0, so the first Panel receives isActive = true',
  'When Accordion’s activeIndex state changes to 1, the second Panel receives isActive = true instead',
  'It is common to call a component with some local state “uncontrolled”. For example, the original Panel component with an isActive state variable is uncontrolled because its parent cannot influence whether the panel is active or not.',
  'In contrast, you might say a component is “controlled” when the important information in it is driven by props rather than its own local state. This lets the parent component fully specify its behavior. The final Panel component with the isActive prop is controlled by the Accordion component.',
  'Uncontrolled components are easier to use within their parents because they require less configuration. But they’re less flexible when you want to coordinate them together. Controlled components are maximally flexible, but they require the parent components to fully configure them with props.',
  'In practice, “controlled” and “uncontrolled” aren’t strict technical terms—each component usually has some mix of both local state and props. However, this is a useful way to talk about how components are designed and what capabilities they offer.',
  'When writing a component, consider which information in it should be controlled (via props), and which information should be uncontrolled (via state). But you can always change your mind and refactor later.',
  'In a React application, many components will have their own state. Some state may “live” close to the leaf components (components at the bottom of the tree) like inputs. Other state may “live” closer to the top of the app. For example, even client-side routing libraries are usually implemented by storing the current route in the React state, and passing it down by props!',
  'For each unique piece of state, you will choose the component that “owns” it. This principle is also known as having a “single source of truth”. It doesn’t mean that all state lives in one place—but that for each piece of state, there is a specific component that holds that piece of information. Instead of duplicating shared state between components, lift it up to their common shared parent, and pass it down to the children that need it.',
  'Your app will change as you work on it. It is common that you will move state down or back up while you’re still figuring out where each piece of the state “lives”. This is all part of the process!',
  'To see what this feels like in practice with a few more components, read Thinking in React.',
  'These two inputs are independent. Make them stay in sync: editing one input should update the other input with the same text, and vice versa.',
  'How do you like these docs?'
]
URL:  https://react.dev/learn/preserving-and-resetting-state
[
  'Is this page useful?',
  'State is isolated between components. React keeps track of which state belongs to which component based on their place in the UI tree. You can control when to preserve state and when to reset it between re-renders.',
  'React builds render trees for the component structure in your UI.',
  'When you give a component state, you might think the state “lives” inside the component. But the state is actually held inside React. React associates each piece of state it’s holding with the correct component by where that component sits in the render tree.',
  'Here, there is only one <Counter /> JSX tag, but it’s rendered at two different positions:',
  'Here’s how these look as a tree:',
  'React tree',
  'These are two separate counters because each is rendered at its own position in the tree. You don’t usually have to think about these positions to use React, but it can be useful to understand how it works.',
  'In React, each component on the screen has fully isolated state. For example, if you render two Counter components side by side, each of them will get its own, independent, score and hover states.',
  'Try clicking both counters and notice they don’t affect each other:',
  'As you can see, when one counter is updated, only the state for that component is updated:',
  'Updating state',
  'React will keep the state around for as long as you render the same component at the same position in the tree. To see this, increment both counters, then remove the second component by unchecking “Render the second counter” checkbox, and then add it back by ticking it again:',
  'Notice how the moment you stop rendering the second counter, its state disappears completely. That’s because when React removes a component, it destroys its state.',
  'Deleting a component',
  'When you tick “Render the second counter”, a second Counter and its state are initialized from scratch (score = 0) and added to the DOM.',
  'Adding a component',
  'React preserves a component’s state for as long as it’s being rendered at its position in the UI tree. If it gets removed, or a different component gets rendered at the same position, React discards its state.',
  'In this example, there are two different <Counter /> tags:',
  'When you tick or clear the checkbox, the counter state does not get reset. Whether isFancy is true or false, you always have a <Counter /> as the first child of the div returned from the root App component:',
  'Updating the App state does not reset the Counter because Counter stays in the same position',
  'It’s the same component at the same position, so from React’s perspective, it’s the same counter.',
  'Remember that it’s the position in the UI tree—not in the JSX markup—that matters to React! This component has two return clauses with different <Counter /> JSX tags inside and outside the if:',
  'You might expect the state to reset when you tick checkbox, but it doesn’t! This is because both of these <Counter /> tags are rendered at the same position. React doesn’t know where you place the conditions in your function. All it “sees” is the tree you return.',
  'In both cases, the App component returns a <div> with <Counter /> as a first child. To React, these two counters have the same “address”: the first child of the first child of the root. This is how React matches them up between the previous and next renders, regardless of how you structure your logic.',
  'In this example, ticking the checkbox will replace <Counter> with a <p>:',
  'Here, you switch between different component types at the same position. Initially, the first child of the <div> contained a Counter. But when you swapped in a p, React removed the Counter from the UI tree and destroyed its state.',
  'When Counter changes to p, the Counter is deleted and the p is added',
  'When switching back, the p is deleted and the Counter is added',
  'Also, when you render a different component in the same position, it resets the state of its entire subtree. To see how this works, increment the counter and then tick the checkbox:',
  'The counter state gets reset when you click the checkbox. Although you render a Counter, the first child of the div changes from a div to a section. When the child div was removed from the DOM, the whole tree below it (including the Counter and its state) was destroyed as well.',
  'When section changes to div, the section is deleted and the new div is added',
  'When switching back, the div is deleted and the new section is added',
  'As a rule of thumb, if you want to preserve the state between re-renders, the structure of your tree needs to “match up” from one render to another. If the structure is different, the state gets destroyed because React destroys state when it removes a component from the tree.',
  'This is why you should not nest component function definitions.',
  'Here, the MyTextField component function is defined inside MyComponent:',
  'Every time you click the button, the input state disappears! This is because a different MyTextField function is created for every render of MyComponent. You’re rendering a different component in the same position, so React resets all state below. This leads to bugs and performance problems. To avoid this problem, always declare component functions at the top level, and don’t nest their definitions.',
  'By default, React preserves state of a component while it stays at the same position. Usually, this is exactly what you want, so it makes sense as the default behavior. But sometimes, you may want to reset a component’s state. Consider this app that lets two players keep track of their scores during each turn:',
  'Currently, when you change the player, the score is preserved. The two Counters appear in the same position, so React sees them as the same Counter whose person prop has changed.',
  'But conceptually, in this app they should be two separate counters. They might appear in the same place in the UI, but one is a counter for Taylor, and another is a counter for Sarah.',
  'There are two ways to reset state when switching between them:',
  'If you want these two Counters to be independent, you can render them in two different positions:',
  'Initial state',
  'Clicking “next”',
  'Clicking “next” again',
  'Each Counter’s state gets destroyed each time it’s removed from the DOM. This is why they reset every time you click the button.',
  'This solution is convenient when you only have a few independent components rendered in the same place. In this example, you only have two, so it’s not a hassle to render both separately in the JSX.',
  'There is also another, more generic, way to reset a component’s state.',
  'You might have seen keys when rendering lists. Keys aren’t just for lists! You can use keys to make React distinguish between any components. By default, React uses order within the parent (“first counter”, “second counter”) to discern between components. But keys let you tell React that this is not just a first counter, or a second counter, but a specific counter—for example, Taylor’s counter. This way, React will know Taylor’s counter wherever it appears in the tree!',
  'In this example, the two <Counter />s don’t share state even though they appear in the same place in JSX:',
  'Switching between Taylor and Sarah does not preserve the state. This is because you gave them different keys:',
  'Specifying a key tells React to use the key itself as part of the position, instead of their order within the parent. This is why, even though you render them in the same place in JSX, React sees them as two different counters, and so they will never share state. Every time a counter appears on the screen, its state is created. Every time it is removed, its state is destroyed. Toggling between them resets their state over and over.',
  'Remember that keys are not globally unique. They only specify the position within the parent.',
  'Resetting state with a key is particularly useful when dealing with forms.',
  'In this chat app, the <Chat> component contains the text input state:',
  'Try entering something into the input, and then press “Alice” or “Bob” to choose a different recipient. You will notice that the input state is preserved because the <Chat> is rendered at the same position in the tree.',
  'In many apps, this may be the desired behavior, but not in a chat app! You don’t want to let the user send a message they already typed to a wrong person due to an accidental click. To fix it, add a key:',
  'This ensures that when you select a different recipient, the Chat component will be recreated from scratch, including any state in the tree below it. React will also re-create the DOM elements instead of reusing them.',
  'Now switching the recipient always clears the text field:',
  'In a real chat app, you’d probably want to recover the input state when the user selects the previous recipient again. There are a few ways to keep the state “alive” for a component that’s no longer visible:',
  'No matter which strategy you pick, a chat with Alice is conceptually distinct from a chat with Bob, so it makes sense to give a key to the <Chat> tree based on the current recipient.',
  'This example shows a message when you press the button. However, pressing the button also accidentally resets the input. Why does this happen? Fix it so that pressing the button does not reset the input text.',
  'How do you like these docs?'
]
URL:  https://react.dev/learn/extracting-state-logic-into-a-reducer
[
  'Is this page useful?',
  'Components with many state updates spread across many event handlers can get overwhelming. For these cases, you can consolidate all the state update logic outside your component in a single function, called a reducer.',
  'As your components grow in complexity, it can get harder to see at a glance all the different ways in which a component’s state gets updated. For example, the TaskApp component below holds an array of tasks in state and uses three different event handlers to add, remove, and edit tasks:',
  'Each of its event handlers calls setTasks in order to update the state. As this component grows, so does the amount of state logic sprinkled throughout it. To reduce this complexity and keep all your logic in one easy-to-access place, you can move that state logic into a single function outside your component, called a “reducer”.',
  'Reducers are a different way to handle state. You can migrate from useState to useReducer in three steps:',
  'Your event handlers currently specify what to do by setting state:',
  'Remove all the state setting logic. What you are left with are three event handlers:',
  'Managing state with reducers is slightly different from directly setting state. Instead of telling React “what to do” by setting state, you specify “what the user just did” by dispatching “actions” from your event handlers. (The state update logic will live elsewhere!) So instead of “setting tasks” via an event handler, you’re dispatching an “added/changed/deleted a task” action. This is more descriptive of the user’s intent.',
  'The object you pass to dispatch is called an “action”:',
  'It is a regular JavaScript object. You decide what to put in it, but generally it should contain the minimal information about what happened. (You will add the dispatch function itself in a later step.)',
  'An action object can have any shape.',
  "By convention, it is common to give it a string type that describes what happened, and pass any additional information in other fields. The type is specific to a component, so in this example either 'added' or 'added_task' would be fine. Choose a name that says what happened!",
  'A reducer function is where you will put your state logic. It takes two arguments, the current state and the action object, and it returns the next state:',
  'React will set the state to what you return from the reducer.',
  'To move your state setting logic from your event handlers to a reducer function in this example, you will:',
  'Here is all the state setting logic migrated to a reducer function:',
  'Because the reducer function takes state (tasks) as an argument, you can declare it outside of your component. This decreases the indentation level and can make your code easier to read.',
  'The code above uses if/else statements, but it’s a convention to use switch statements inside reducers. The result is the same, but it can be easier to read switch statements at a glance.',
  'We’ll be using them throughout the rest of this documentation like so:',
  'We recommend wrapping each case block into the { and } curly braces so that variables declared inside of different cases don’t clash with each other. Also, a case should usually end with a return. If you forget to return, the code will “fall through” to the next case, which can lead to mistakes!',
  'If you’re not yet comfortable with switch statements, using if/else is completely fine.',
  'Although reducers can “reduce” the amount of code inside your component, they are actually named after the reduce() operation that you can perform on arrays.',
  'The reduce() operation lets you take an array and “accumulate” a single value out of many:',
  'The function you pass to reduce is known as a “reducer”. It takes the result so far and the current item, then it returns the next result. React reducers are an example of the same idea: they take the state so far and the action, and return the next state. In this way, they accumulate actions over time into state.',
  'You could even use the reduce() method with an initialState and an array of actions to calculate the final state by passing your reducer function to it:',
  'You probably won’t need to do this yourself, but this is similar to what React does!',
  'Finally, you need to hook up the tasksReducer to your component. Import the useReducer Hook from React:',
  'Then you can replace useState:',
  'with useReducer like so:',
  'The useReducer Hook is similar to useState—you must pass it an initial state and it returns a stateful value and a way to set state (in this case, the dispatch function). But it’s a little different.',
  'The useReducer Hook takes two arguments:',
  'And it returns:',
  'Now it’s fully wired up! Here, the reducer is declared at the bottom of the component file:',
  'If you want, you can even move the reducer to a different file:',
  'Component logic can be easier to read when you separate concerns like this. Now the event handlers only specify what happened by dispatching actions, and the reducer function determines how the state updates in response to them.',
  'Reducers are not without downsides! Here’s a few ways you can compare them:',
  'We recommend using a reducer if you often encounter bugs due to incorrect state updates in some component, and want to introduce more structure to its code. You don’t have to use reducers for everything: feel free to mix and match! You can even useState and useReducer in the same component.',
  'Keep these two tips in mind when writing reducers:',
  'Just like with updating objects and arrays in regular state, you can use the Immer library to make reducers more concise. Here, useImmerReducer lets you mutate the state with push or arr[i] = assignment:',
  'Reducers must be pure, so they shouldn’t mutate state. But Immer provides you with a special draft object which is safe to mutate. Under the hood, Immer will create a copy of your state with the changes you made to the draft. This is why reducers managed by useImmerReducer can mutate their first argument and don’t need to return state.',
  'Currently, the event handlers in ContactList.js and Chat.js have // TODO comments. This is why typing into the input doesn’t work, and clicking on the buttons doesn’t change the selected recipient.',
  'Replace these two // TODOs with the code to dispatch the corresponding actions. To see the expected shape and the type of the actions, check the reducer in messengerReducer.js. The reducer is already written so you won’t need to change it. You only need to dispatch the actions in ContactList.js and Chat.js.',
  'How do you like these docs?'
]
URL:  https://react.dev/learn/passing-data-deeply-with-context
[
  'Is this page useful?',
  'Usually, you will pass information from a parent component to a child component via props. But passing props can become verbose and inconvenient if you have to pass them through many components in the middle, or if many components in your app need the same information. Context lets the parent component make some information available to any component in the tree below it—no matter how deep—without passing it explicitly through props.',
  'Passing props is a great way to explicitly pipe data through your UI tree to the components that use it.',
  'But passing props can become verbose and inconvenient when you need to pass some prop deeply through the tree, or if many components need the same prop. The nearest common ancestor could be far removed from the components that need data, and lifting state up that high can lead to a situation called “prop drilling”.',
  'Lifting state up',
  'Prop drilling',
  'Wouldn’t it be great if there were a way to “teleport” data to the components in the tree that need it without passing props? With React’s context feature, there is!',
  'Context lets a parent component provide data to the entire tree below it. There are many uses for context. Here is one example. Consider this Heading component that accepts a level for its size:',
  'Let’s say you want multiple headings within the same Section to always have the same size:',
  'Currently, you pass the level prop to each <Heading> separately:',
  'It would be nice if you could pass the level prop to the <Section> component instead and remove it from the <Heading>. This way you could enforce that all headings in the same section have the same size:',
  'But how can the <Heading> component know the level of its closest <Section>? That would require some way for a child to “ask” for data from somewhere above in the tree.',
  'You can’t do it with props alone. This is where context comes into play. You will do it in three steps:',
  'Context lets a parent—even a distant one!—provide some data to the entire tree inside of it.',
  'Using context in close children',
  'Using context in distant children',
  'First, you need to create the context. You’ll need to export it from a file so that your components can use it:',
  'The only argument to createContext is the default value. Here, 1 refers to the biggest heading level, but you could pass any kind of value (even an object). You will see the significance of the default value in the next step.',
  'Import the useContext Hook from React and your context:',
  'Currently, the Heading component reads level from props:',
  'Instead, remove the level prop and read the value from the context you just imported, LevelContext:',
  'useContext is a Hook. Just like useState and useReducer, you can only call a Hook immediately inside a React component (not inside loops or conditions). useContext tells React that the Heading component wants to read the LevelContext.',
  'Now that the Heading component doesn’t have a level prop, you don’t need to pass the level prop to Heading in your JSX like this anymore:',
  'Update the JSX so that it’s the Section that receives it instead:',
  'As a reminder, this is the markup that you were trying to get working:',
  'Notice this example doesn’t quite work, yet! All the headings have the same size because even though you’re using the context, you have not provided it yet. React doesn’t know where to get it!',
  'If you don’t provide the context, React will use the default value you’ve specified in the previous step. In this example, you specified 1 as the argument to createContext, so useContext(LevelContext) returns 1, setting all those headings to <h1>. Let’s fix this problem by having each Section provide its own context.',
  'The Section component currently renders its children:',
  'Wrap them with a context provider to provide the LevelContext to them:',
  'This tells React: “if any component inside this <Section> asks for LevelContext, give them this level.” The component will use the value of the nearest <LevelContext.Provider> in the UI tree above it.',
  'It’s the same result as the original code, but you did not need to pass the level prop to each Heading component! Instead, it “figures out” its heading level by asking the closest Section above:',
  'Currently, you still have to specify each section’s level manually:',
  'Since context lets you read information from a component above, each Section could read the level from the Section above, and pass level + 1 down automatically. Here is how you could do it:',
  'With this change, you don’t need to pass the level prop either to the <Section> or to the <Heading>:',
  'Now both Heading and Section read the LevelContext to figure out how “deep” they are. And the Section wraps its children into the LevelContext to specify that anything inside of it is at a “deeper” level.',
  'This example uses heading levels because they show visually how nested components can override context. But context is useful for many other use cases too. You can pass down any information needed by the entire subtree: the current color theme, the currently logged in user, and so on.',
  'You can insert as many components as you like between the component that provides context and the one that uses it. This includes both built-in components like <div> and components you might build yourself.',
  'In this example, the same Post component (with a dashed border) is rendered at two different nesting levels. Notice that the <Heading> inside of it gets its level automatically from the closest <Section>:',
  'You didn’t do anything special for this to work. A Section specifies the context for the tree inside it, so you can insert a <Heading> anywhere, and it will have the correct size. Try it in the sandbox above!',
  'Context lets you write components that “adapt to their surroundings” and display themselves differently depending on where (or, in other words, in which context) they are being rendered.',
  'How context works might remind you of CSS property inheritance. In CSS, you can specify color: blue for a <div>, and any DOM node inside of it, no matter how deep, will inherit that color unless some other DOM node in the middle overrides it with color: green. Similarly, in React, the only way to override some context coming from above is to wrap children into a context provider with a different value.',
  'In CSS, different properties like color and background-color don’t override each other. You can set all  <div>’s color to red without impacting background-color. Similarly, different React contexts don’t override each other. Each context that you make with createContext() is completely separate from other ones, and ties together components using and providing that particular context. One component may use or provide many different contexts without a problem.',
  'Context is very tempting to use! However, this also means it’s too easy to overuse it. Just because you need to pass some props several levels deep doesn’t mean you should put that information into context.',
  'Here’s a few alternatives you should consider before using context:',
  'If neither of these approaches works well for you, consider context.',
  'Context is not limited to static values. If you pass a different value on the next render, React will update all the components reading it below! This is why context is often used in combination with state.',
  'In general, if some information is needed by distant components in different parts of the tree, it’s a good indication that context will help you.',
  'In this example, toggling the checkbox changes the imageSize prop passed to each <PlaceImage>. The checkbox state is held in the top-level App component, but each <PlaceImage> needs to be aware of it.',
  'Currently, App passes imageSize to List, which passes it to each Place, which passes it to the PlaceImage. Remove the imageSize prop, and instead pass it from the App component directly to PlaceImage.',
  'You can declare context in Context.js.',
  'How do you like these docs?'
]
URL:  https://react.dev/learn/scaling-up-with-reducer-and-context
[
  'Is this page useful?',
  'Reducers let you consolidate a component’s state update logic. Context lets you pass information deep down to other components. You can combine reducers and context together to manage state of a complex screen.',
  'In this example from the introduction to reducers, the state is managed by a reducer. The reducer function contains all of the state update logic and is declared at the bottom of this file:',
  'A reducer helps keep the event handlers short and concise. However, as your app grows, you might run into another difficulty. Currently, the tasks state and the dispatch function are only available in the top-level TaskApp component. To let other components read the list of tasks or change it, you have to explicitly pass down the current state and the event handlers that change it as props.',
  'For example, TaskApp passes a list of tasks and the event handlers to TaskList:',
  'And TaskList passes the event handlers to Task:',
  'In a small example like this, this works well, but if you have tens or hundreds of components in the middle, passing down all state and functions can be quite frustrating!',
  'This is why, as an alternative to passing them through props, you might want to put both the tasks state and the dispatch function into context. This way, any component below TaskApp in the tree can read the tasks and dispatch actions without the repetitive “prop drilling”.',
  'Here is how you can combine a reducer with context:',
  'The useReducer Hook returns the current tasks and the dispatch function that lets you update them:',
  'To pass them down the tree, you will create two separate contexts:',
  'Export them from a separate file so that you can later import them from other files:',
  'Here, you’re passing null as the default value to both contexts. The actual values will be provided by the TaskApp component.',
  'Now you can import both contexts in your TaskApp component. Take the tasks and dispatch returned by useReducer() and provide them to the entire tree below:',
  'For now, you pass the information both via props and in context:',
  'In the next step, you will remove prop passing.',
  'Now you don’t need to pass the list of tasks or the event handlers down the tree:',
  'Instead, any component that needs the task list can read it from the TaskContext:',
  'To update the task list, any component can read the dispatch function from context and call it:',
  'The TaskApp component does not pass any event handlers down, and the TaskList does not pass any event handlers to the Task component either. Each component reads the context that it needs:',
  'The state still “lives” in the top-level TaskApp component, managed with useReducer. But its tasks and dispatch are now available to every component below in the tree by importing and using these contexts.',
  'You don’t have to do this, but you could further declutter the components by moving both reducer and context into a single file. Currently, TasksContext.js contains only two context declarations:',
  'This file is about to get crowded! You’ll move the reducer into that same file. Then you’ll declare a new TasksProvider component in the same file. This component will tie all the pieces together:',
  'This removes all the complexity and wiring from your TaskApp component:',
  'You can also export functions that use the context from TasksContext.js:',
  'When a component needs to read context, it can do it through these functions:',
  'This doesn’t change the behavior in any way, but it lets you later split these contexts further or add some logic to these functions. Now all of the context and reducer wiring is in TasksContext.js. This keeps the components clean and uncluttered, focused on what they display rather than where they get the data:',
  'You can think of TasksProvider as a part of the screen that knows how to deal with tasks, useTasks as a way to read them, and useTasksDispatch as a way to update them from any component below in the tree.',
  'Functions like useTasks and useTasksDispatch are called Custom Hooks. Your function is considered a custom Hook if its name starts with use. This lets you use other Hooks, like useContext, inside it.',
  'As your app grows, you may have many context-reducer pairs like this. This is a powerful way to scale your app and lift state up without too much work whenever you want to access the data deep in the tree.',
  'How do you like these docs?'
]
URL:  https://react.dev/learn/escape-hatches
[
  'Is this page useful?',
  'Some of your components may need to control and synchronize with systems outside of React. For example, you might need to focus an input using the browser API, play and pause a video player implemented without React, or connect and listen to messages from a remote server. In this chapter, you’ll learn the escape hatches that let you “step outside” React and connect to external systems. Most of your application logic and data flow should not rely on these features.',
  'When you want a component to “remember” some information, but you don’t want that information to trigger new renders, you can use a ref:',
  'Like state, refs are retained by React between re-renders. However, setting state re-renders a component. Changing a ref does not! You can access the current value of that ref through the ref.current property.',
  'A ref is like a secret pocket of your component that React doesn’t track. For example, you can use refs to store timeout IDs, DOM elements, and other objects that don’t impact the component’s rendering output.',
  'Read Referencing Values with Refs to learn how to use refs to remember information.',
  'React automatically updates the DOM to match your render output, so your components won’t often need to manipulate it. However, sometimes you might need access to the DOM elements managed by React—for example, to focus a node, scroll to it, or measure its size and position. There is no built-in way to do those things in React, so you will need a ref to the DOM node. For example, clicking the button will focus the input using a ref:',
  'Read Manipulating the DOM with Refs to learn how to access DOM elements managed by React.',
  'Some components need to synchronize with external systems. For example, you might want to control a non-React component based on the React state, set up a server connection, or send an analytics log when a component appears on the screen. Unlike event handlers, which let you handle particular events, Effects let you run some code after rendering. Use them to synchronize your component with a system outside of React.',
  'Press Play/Pause a few times and see how the video player stays synchronized to the isPlaying prop value:',
  'Many Effects also “clean up” after themselves. For example, an Effect that sets up a connection to a chat server should return a cleanup function that tells React how to disconnect your component from that server:',
  'In development, React will immediately run and clean up your Effect one extra time. This is why you see "✅ Connecting..." printed twice. This ensures that you don’t forget to implement the cleanup function.',
  'Read Synchronizing with Effects to learn how to synchronize components with external systems.',
  'Effects are an escape hatch from the React paradigm. They let you “step outside” of React and synchronize your components with some external system. If there is no external system involved (for example, if you want to update a component’s state when some props or state change), you shouldn’t need an Effect. Removing unnecessary Effects will make your code easier to follow, faster to run, and less error-prone.',
  'There are two common cases in which you don’t need Effects:',
  'For example, you don’t need an Effect to adjust some state based on other state:',
  'Instead, calculate as much as you can while rendering:',
  'However, you do need Effects to synchronize with external systems.',
  'Read You Might Not Need an Effect to learn how to remove unnecessary Effects.',
  'Effects have a different lifecycle from components. Components may mount, update, or unmount. An Effect can only do two things: to start synchronizing something, and later to stop synchronizing it. This cycle can happen multiple times if your Effect depends on props and state that change over time.',
  'This Effect depends on the value of the roomId prop. Props are reactive values, which means they can change on a re-render. Notice that the Effect re-synchronizes (and re-connects to the server) if roomId changes:',
  'React provides a linter rule to check that you’ve specified your Effect’s dependencies correctly. If you forget to specify roomId in the list of dependencies in the above example, the linter will find that bug automatically.',
  'Read Lifecycle of Reactive Events to learn how an Effect’s lifecycle is different from a component’s.',
  'This section describes an experimental API that has not yet been released in a stable version of React.',
  'Event handlers only re-run when you perform the same interaction again. Unlike event handlers, Effects re-synchronize if any of the values they read, like props or state, are different than during last render. Sometimes, you want a mix of both behaviors: an Effect that re-runs in response to some values but not others.',
  'All code inside Effects is reactive. It will run again if some reactive value it reads has changed due to a re-render. For example, this Effect will re-connect to the chat if either roomId or theme have changed:',
  'This is not ideal. You want to re-connect to the chat only if the roomId has changed. Switching the theme shouldn’t re-connect to the chat! Move the code reading theme out of your Effect into an Effect Event:',
  'Code inside Effect Events isn’t reactive, so changing the theme no longer makes your Effect re-connect.',
  'Read Separating Events from Effects to learn how to prevent some values from re-triggering Effects.',
  'When you write an Effect, the linter will verify that you’ve included every reactive value (like props and state) that the Effect reads in the list of your Effect’s dependencies. This ensures that your Effect remains synchronized with the latest props and state of your component. Unnecessary dependencies may cause your Effect to run too often, or even create an infinite loop. The way you remove them depends on the case.',
  'For example, this Effect depends on the options object which gets re-created every time you edit the input:',
  'You don’t want the chat to re-connect every time you start typing a message in that chat. To fix this problem, move creation of the options object inside the Effect so that the Effect only depends on the roomId string:',
  'Notice that you didn’t start by editing the dependency list to remove the options dependency. That would be wrong. Instead, you changed the surrounding code so that the dependency became unnecessary. Think of the dependency list as a list of all the reactive values used by your Effect’s code. You don’t intentionally choose what to put on that list. The list describes your code. To change the dependency list, change the code.',
  'Read Removing Effect Dependencies to learn how to make your Effect re-run less often.',
  'React comes with built-in Hooks like useState, useContext, and useEffect. Sometimes, you’ll wish that there was a Hook for some more specific purpose: for example, to fetch data, to keep track of whether the user is online, or to connect to a chat room. To do this, you can create your own Hooks for your application’s needs.',
  'In this example, the usePointerPosition custom Hook tracks the cursor position, while useDelayedValue custom Hook returns a value that’s “lagging behind” the value you passed by a certain number of milliseconds. Move the cursor over the sandbox preview area to see a moving trail of dots following the cursor:',
  'You can create custom Hooks, compose them together, pass data between them, and reuse them between components. As your app grows, you will write fewer Effects by hand because you’ll be able to reuse custom Hooks you already wrote. There are also many excellent custom Hooks maintained by the React community.',
  'Read Reusing Logic with Custom Hooks to learn how to share logic between components.',
  'Head over to Referencing Values with Refs to start reading this chapter page by page!',
  'How do you like these docs?'
]
URL:  https://react.dev/learn/referencing-values-with-refs
[
  'Is this page useful?',
  'When you want a component to “remember” some information, but you don’t want that information to trigger new renders, you can use a ref.',
  'You can add a ref to your component by importing the useRef Hook from React:',
  'Inside your component, call the useRef Hook and pass the initial value that you want to reference as the only argument. For example, here is a ref to the value 0:',
  'useRef returns an object like this:',
  'Illustrated by Rachel Lee Nabors',
  'You can access the current value of that ref through the ref.current property. This value is intentionally mutable, meaning you can both read and write to it. It’s like a secret pocket of your component that React doesn’t track. (This is what makes it an “escape hatch” from React’s one-way data flow—more on that below!)',
  'Here, a button will increment ref.current on every click:',
  'The ref points to a number, but, like state, you could point to anything: a string, an object, or even a function. Unlike state, ref is a plain JavaScript object with the current property that you can read and modify.',
  'Note that the component doesn’t re-render with every increment. Like state, refs are retained by React between re-renders. However, setting state re-renders a component. Changing a ref does not!',
  'You can combine refs and state in a single component. For example, let’s make a stopwatch that the user can start or stop by pressing a button. In order to display how much time has passed since the user pressed “Start”, you will need to keep track of when the Start button was pressed and what the current time is. This information is used for rendering, so you’ll keep it in state:',
  'When the user presses “Start”, you’ll use setInterval in order to update the time every 10 milliseconds:',
  'When the “Stop” button is pressed, you need to cancel the existing interval so that it stops updating the now state variable. You can do this by calling clearInterval, but you need to give it the interval ID that was previously returned by the setInterval call when the user pressed Start. You need to keep the interval ID somewhere. Since the interval ID is not used for rendering, you can keep it in a ref:',
  'When a piece of information is used for rendering, keep it in state. When a piece of information is only needed by event handlers and changing it doesn’t require a re-render, using a ref may be more efficient.',
  'Perhaps you’re thinking refs seem less “strict” than state—you can mutate them instead of always having to use a state setting function, for instance. But in most cases, you’ll want to use state. Refs are an “escape hatch” you won’t need often. Here’s how state and refs compare:',
  'Here is a counter button that’s implemented with state:',
  'Because the count value is displayed, it makes sense to use a state value for it. When the counter’s value is set with setCount(), React re-renders the component and the screen updates to reflect the new count.',
  'If you tried to implement this with a ref, React would never re-render the component, so you’d never see the count change! See how clicking this button does not update its text:',
  'This is why reading ref.current during render leads to unreliable code. If you need that, use state instead.',
  'Although both useState and useRef are provided by React, in principle useRef could be implemented on top of useState. You can imagine that inside of React, useRef is implemented like this:',
  'During the first render, useRef returns { current: initialValue }. This object is stored by React, so during the next render the same object will be returned. Note how the state setter is unused in this example. It is unnecessary because useRef always needs to return the same object!',
  'React provides a built-in version of useRef because it is common enough in practice. But you can think of it as a regular state variable without a setter. If you’re familiar with object-oriented programming, refs might remind you of instance fields—but instead of this.something you write somethingRef.current.',
  'Typically, you will use a ref when your component needs to “step outside” React and communicate with external APIs—often a browser API that won’t impact the appearance of the component. Here are a few of these rare situations:',
  'If your component needs to store some value, but it doesn’t impact the rendering logic, choose refs.',
  'Following these principles will make your components more predictable:',
  'Limitations of React state don’t apply to refs. For example, state acts like a snapshot for every render and doesn’t update synchronously. But when you mutate the current value of a ref, it changes immediately:',
  'This is because the ref itself is a regular JavaScript object, and so it behaves like one.',
  'You also don’t need to worry about avoiding mutation when you work with a ref. As long as the object you’re mutating isn’t used for rendering, React doesn’t care what you do with the ref or its contents.',
  'You can point a ref to any value. However, the most common use case for a ref is to access a DOM element. For example, this is handy if you want to focus an input programmatically. When you pass a ref to a ref attribute in JSX, like <div ref={myRef}>, React will put the corresponding DOM element into myRef.current. Once the element is removed from the DOM, React will update myRef.current to be null. You can read more about this in Manipulating the DOM with Refs.',
  'Type a message and click “Send”. You will notice there is a three second delay before you see the “Sent!” alert. During this delay, you can see an “Undo” button. Click it. This “Undo” button is supposed to stop the “Sent!” message from appearing. It does this by calling clearTimeout for the timeout ID saved during handleSend. However, even after “Undo” is clicked, the “Sent!” message still appears. Find why it doesn’t work, and fix it.',
  'How do you like these docs?'
]
URL:  https://react.dev/learn/manipulating-the-dom-with-refs
[
  'Is this page useful?',
  'React automatically updates the DOM to match your render output, so your components won’t often need to manipulate it. However, sometimes you might need access to the DOM elements managed by React—for example, to focus a node, scroll to it, or measure its size and position. There is no built-in way to do those things in React, so you will need a ref to the DOM node.',
  'To access a DOM node managed by React, first, import the useRef Hook:',
  'Then, use it to declare a ref inside your component:',
  'Finally, pass your ref as the ref attribute to the JSX tag for which you want to get the DOM node:',
  'The useRef Hook returns an object with a single property called current. Initially, myRef.current will be null. When React creates a DOM node for this <div>, React will put a reference to this node into myRef.current. You can then access this DOM node from your event handlers and use the built-in browser APIs defined on it.',
  'In this example, clicking the button will focus the input:',
  'To implement this:',
  'While DOM manipulation is the most common use case for refs, the useRef Hook can be used for storing other things outside React, like timer IDs. Similarly to state, refs remain between renders. Refs are like state variables that don’t trigger re-renders when you set them. Read about refs in Referencing Values with Refs.',
  'You can have more than a single ref in a component. In this example, there is a carousel of three images. Each button centers an image by calling the browser scrollIntoView() method on the corresponding DOM node:',
  'In the above examples, there is a predefined number of refs. However, sometimes you might need a ref to each item in the list, and you don’t know how many you will have. Something like this wouldn’t work:',
  'This is because Hooks must only be called at the top-level of your component. You can’t call useRef in a loop, in a condition, or inside a map() call.',
  'One possible way around this is to get a single ref to their parent element, and then use DOM manipulation methods like querySelectorAll to “find” the individual child nodes from it. However, this is brittle and can break if your DOM structure changes.',
  'Another solution is to pass a function to the ref attribute. This is called a ref callback. React will call your ref callback with the DOM node when it’s time to set the ref, and with null when it’s time to clear it. This lets you maintain your own array or a Map, and access any ref by its index or some kind of ID.',
  'This example shows how you can use this approach to scroll to an arbitrary node in a long list:',
  'In this example, itemsRef doesn’t hold a single DOM node. Instead, it holds a Map from item ID to a DOM node. (Refs can hold any values!) The ref callback on every list item takes care to update the Map:',
  'This lets you read individual DOM nodes from the Map later.',
  'When you put a ref on a built-in component that outputs a browser element like <input />, React will set that ref’s current property to the corresponding DOM node (such as the actual <input /> in the browser).',
  'However, if you try to put a ref on your own component, like <MyInput />, by default you will get null. Here is an example demonstrating it. Notice how clicking the button does not focus the input:',
  'To help you notice the issue, React also prints an error to the console:',
  'This happens because by default React does not let a component access the DOM nodes of other components. Not even for its own children! This is intentional. Refs are an escape hatch that should be used sparingly. Manually manipulating another component’s DOM nodes makes your code even more fragile.',
  'Instead, components that want to expose their DOM nodes have to opt in to that behavior. A component can specify that it “forwards” its ref to one of its children. Here’s how MyInput can use the forwardRef API:',
  'This is how it works:',
  'Now clicking the button to focus the input works:',
  'In design systems, it is a common pattern for low-level components like buttons, inputs, and so on, to forward their refs to their DOM nodes. On the other hand, high-level components like forms, lists, or page sections usually won’t expose their DOM nodes to avoid accidental dependencies on the DOM structure.',
  'In the above example, MyInput exposes the original DOM input element. This lets the parent component call focus() on it. However, this also lets the parent component do something else—for example, change its CSS styles. In uncommon cases, you may want to restrict the exposed functionality. You can do that with useImperativeHandle:',
  'Here, realInputRef inside MyInput holds the actual input DOM node. However, useImperativeHandle instructs React to provide your own special object as the value of a ref to the parent component. So inputRef.current inside the Form component will only have the focus method. In this case, the ref “handle” is not the DOM node, but the custom object you create inside useImperativeHandle call.',
  'In React, every update is split in two phases:',
  'In general, you don’t want to access refs during rendering. That goes for refs holding DOM nodes as well. During the first render, the DOM nodes have not yet been created, so ref.current will be null. And during the rendering of updates, the DOM nodes haven’t been updated yet. So it’s too early to read them.',
  'React sets ref.current during the commit. Before updating the DOM, React sets the affected ref.current values to null. After updating the DOM, React immediately sets them to the corresponding DOM nodes.',
  'Usually, you will access refs from event handlers. If you want to do something with a ref, but there is no particular event to do it in, you might need an Effect. We will discuss effects on the next pages.',
  'Consider code like this, which adds a new todo and scrolls the screen down to the last child of the list. Notice how, for some reason, it always scrolls to the todo that was just before the last added one:',
  'The issue is with these two lines:',
  'In React, state updates are queued. Usually, this is what you want. However, here it causes a problem because setTodos does not immediately update the DOM. So the time you scroll the list to its last element, the todo has not yet been added. This is why scrolling always “lags behind” by one item.',
  'To fix this issue, you can force React to update (“flush”) the DOM synchronously. To do this, import flushSync from react-dom and wrap the state update into a flushSync call:',
  'This will instruct React to update the DOM synchronously right after the code wrapped in flushSync executes. As a result, the last todo will already be in the DOM by the time you try to scroll to it:',
  'Refs are an escape hatch. You should only use them when you have to “step outside React”. Common examples of this include managing focus, scroll position, or calling browser APIs that React does not expose.',
  'If you stick to non-destructive actions like focusing and scrolling, you shouldn’t encounter any problems. However, if you try to modify the DOM manually, you can risk conflicting with the changes React is making.',
  'To illustrate this problem, this example includes a welcome message and two buttons. The first button toggles its presence using conditional rendering and state, as you would usually do in React. The second button uses the remove() DOM API to forcefully remove it from the DOM outside of React’s control.',
  'Try pressing “Toggle with setState” a few times. The message should disappear and appear again. Then press “Remove from the DOM”. This will forcefully remove it. Finally, press “Toggle with setState”:',
  'After you’ve manually removed the DOM element, trying to use setState to show it again will lead to a crash. This is because you’ve changed the DOM, and React doesn’t know how to continue managing it correctly.',
  'Avoid changing DOM nodes managed by React. Modifying, adding children to, or removing children from elements that are managed by React can lead to inconsistent visual results or crashes like above.',
  'However, this doesn’t mean that you can’t do it at all. It requires caution. You can safely modify parts of the DOM that React has no reason to update. For example, if some <div> is always empty in the JSX, React won’t have a reason to touch its children list. Therefore, it is safe to manually add or remove elements there.',
  'In this example, the button toggles a state variable to switch between a playing and a paused state. However, in order to actually play or pause the video, toggling state is not enough. You also need to call play() and pause() on the DOM element for the <video>. Add a ref to it, and make the button work.',
  'For an extra challenge, keep the “Play” button in sync with whether the video is playing even if the user right-clicks the video and plays it using the built-in browser media controls. You might want to listen to onPlay and onPause on the video to do that.',
  'How do you like these docs?'
]
URL:  https://react.dev/learn/synchronizing-with-effects
[
  'Is this page useful?',
  'Some components need to synchronize with external systems. For example, you might want to control a non-React component based on the React state, set up a server connection, or send an analytics log when a component appears on the screen. Effects let you run some code after rendering so that you can synchronize your component with some system outside of React.',
  'Before getting to Effects, you need to be familiar with two types of logic inside React components:',
  'Rendering code (introduced in Describing the UI) lives at the top level of your component. This is where you take the props and state, transform them, and return the JSX you want to see on the screen. Rendering code must be pure. Like a math formula, it should only calculate the result, but not do anything else.',
  'Event handlers (introduced in Adding Interactivity) are nested functions inside your components that do things rather than just calculate them. An event handler might update an input field, submit an HTTP POST request to buy a product, or navigate the user to another screen. Event handlers contain “side effects” (they change the program’s state) caused by a specific user action (for example, a button click or typing).',
  'Sometimes this isn’t enough. Consider a ChatRoom component that must connect to the chat server whenever it’s visible on the screen. Connecting to a server is not a pure calculation (it’s a side effect) so it can’t happen during rendering. However, there is no single particular event like a click that causes ChatRoom to be displayed.',
  'Effects let you specify side effects that are caused by rendering itself, rather than by a particular event. Sending a message in the chat is an event because it is directly caused by the user clicking a specific button. However, setting up a server connection is an Effect because it should happen no matter which interaction caused the component to appear. Effects run at the end of a commit after the screen updates. This is a good time to synchronize the React components with some external system (like network or a third-party library).',
  'Here and later in this text, capitalized “Effect” refers to the React-specific definition above, i.e. a side effect caused by rendering. To refer to the broader programming concept, we’ll say “side effect”.',
  'Don’t rush to add Effects to your components. Keep in mind that Effects are typically used to “step out” of your React code and synchronize with some external system. This includes browser APIs, third-party widgets, network, and so on. If your Effect only adjusts some state based on other state, you might not need an Effect.',
  'To write an Effect, follow these three steps:',
  'Let’s look at each of these steps in detail.',
  'To declare an Effect in your component, import the useEffect Hook from React:',
  'Then, call it at the top level of your component and put some code inside your Effect:',
  'Every time your component renders, React will update the screen and then run the code inside useEffect. In other words, useEffect “delays” a piece of code from running until that render is reflected on the screen.',
  'Let’s see how you can use an Effect to synchronize with an external system. Consider a <VideoPlayer> React component. It would be nice to control whether it’s playing or paused by passing an isPlaying prop to it:',
  'Your custom VideoPlayer component renders the built-in browser <video> tag:',
  'However, the browser <video> tag does not have an isPlaying prop. The only way to control it is to manually call the play() and pause() methods on the DOM element. You need to synchronize the value of isPlaying prop, which tells whether the video should currently be playing, with calls like play() and pause().',
  'We’ll need to first get a ref to the <video> DOM node.',
  'You might be tempted to try to call play() or pause() during rendering, but that isn’t correct:',
  'The reason this code isn’t correct is that it tries to do something with the DOM node during rendering. In React, rendering should be a pure calculation of JSX and should not contain side effects like modifying the DOM.',
  'Moreover, when VideoPlayer is called for the first time, its DOM does not exist yet! There isn’t a DOM node yet to call play() or pause() on, because React doesn’t know what DOM to create until you return the JSX.',
  'The solution here is to wrap the side effect with useEffect to move it out of the rendering calculation:',
  'By wrapping the DOM update in an Effect, you let React update the screen first. Then your Effect runs.',
  'When your VideoPlayer component renders (either the first time or if it re-renders), a few things will happen. First, React will update the screen, ensuring the <video> tag is in the DOM with the right props. Then React will run your Effect. Finally, your Effect will call play() or pause() depending on the value of isPlaying.',
  'Press Play/Pause multiple times and see how the video player stays synchronized to the isPlaying value:',
  'In this example, the “external system” you synchronized to React state was the browser media API. You can use a similar approach to wrap legacy non-React code (like jQuery plugins) into declarative React components.',
  'Note that controlling a video player is much more complex in practice. Calling play() may fail, the user might play or pause using the built-in browser controls, and so on. This example is very simplified and incomplete.',
  'By default, Effects run after every render. This is why code like this will produce an infinite loop:',
  'Effects run as a result of rendering. Setting state triggers rendering. Setting state immediately in an Effect is like plugging a power outlet into itself. The Effect runs, it sets the state, which causes a re-render, which causes the Effect to run, it sets the state again, this causes another re-render, and so on.',
  'Effects should usually synchronize your components with an external system. If there’s no external system and you only want to adjust some state based on other state, you might not need an Effect.',
  'By default, Effects run after every render. Often, this is not what you want:',
  'To demonstrate the issue, here is the previous example with a few console.log calls and a text input that updates the parent component’s state. Notice how typing causes the Effect to re-run:',
  'You can tell React to skip unnecessarily re-running the Effect by specifying an array of dependencies as the second argument to the useEffect call. Start by adding an empty [] array to the above example on line 14:',
  "You should see an error saying React Hook useEffect has a missing dependency: 'isPlaying':",
  'The problem is that the code inside of your Effect depends on the isPlaying prop to decide what to do, but this dependency was not explicitly declared. To fix this issue, add isPlaying to the dependency array:',
  'Now all dependencies are declared, so there is no error. Specifying [isPlaying] as the dependency array tells React that it should skip re-running your Effect if isPlaying is the same as it was during the previous render. With this change, typing into the input doesn’t cause the Effect to re-run, but pressing Play/Pause does:',
  'The dependency array can contain multiple dependencies. React will only skip re-running the Effect if all of the dependencies you specify have exactly the same values as they had during the previous render. React compares the dependency values using the Object.is comparison. See the useEffect reference for details.',
  'Notice that you can’t “choose” your dependencies. You will get a lint error if the dependencies you specified don’t match what React expects based on the code inside your Effect. This helps catch many bugs in your code. If you don’t want some code to re-run, edit the Effect code itself to not “need” that dependency.',
  'The behaviors without the dependency array and with an empty [] dependency array are different:',
  'We’ll take a close look at what “mount” means in the next step.',
  'This Effect uses both ref and isPlaying, but only isPlaying is declared as a dependency:',
  'This is because the ref object has a stable identity: React guarantees you’ll always get the same object from the same useRef call on every render. It never changes, so it will never by itself cause the Effect to re-run. Therefore, it does not matter whether you include it or not. Including it is fine too:',
  'The set functions returned by useState also have stable identity, so you will often see them omitted from the dependencies too. If the linter lets you omit a dependency without errors, it is safe to do.',
  'Omitting always-stable dependencies only works when the linter can “see” that the object is stable. For example, if ref was passed from a parent component, you would have to specify it in the dependency array. However, this is good because you can’t know whether the parent component always passes the same ref, or passes one of several refs conditionally. So your Effect would depend on which ref is passed.',
  'Consider a different example. You’re writing a ChatRoom component that needs to connect to the chat server when it appears. You are given a createConnection() API that returns an object with connect() and disconnect() methods. How do you keep the component connected while it is displayed to the user?',
  'Start by writing the Effect logic:',
  'It would be slow to connect to the chat after every re-render, so you add the dependency array:',
  'The code inside the Effect does not use any props or state, so your dependency array is [] (empty). This tells React to only run this code when the component “mounts”, i.e. appears on the screen for the first time.',
  'Let’s try running this code:',
  'This Effect only runs on mount, so you might expect "✅ Connecting..." to be printed once in the console. However, if you check the console, "✅ Connecting..." gets printed twice. Why does it happen?',
  'Imagine the ChatRoom component is a part of a larger app with many different screens. The user starts their journey on the ChatRoom page. The component mounts and calls connection.connect(). Then imagine the user navigates to another screen—for example, to the Settings page. The ChatRoom component unmounts. Finally, the user clicks Back and ChatRoom mounts again. This would set up a second connection—but the first connection was never destroyed! As the user navigates across the app, the connections would keep piling up.',
  'Bugs like this are easy to miss without extensive manual testing. To help you spot them quickly, in development React remounts every component once immediately after its initial mount.',
  'Seeing the "✅ Connecting..." log twice helps you notice the real issue: your code doesn’t close the connection when the component unmounts.',
  'To fix the issue, return a cleanup function from your Effect:',
  'React will call your cleanup function each time before the Effect runs again, and one final time when the component unmounts (gets removed). Let’s see what happens when the cleanup function is implemented:',
  'Now you get three console logs in development:',
  'This is the correct behavior in development. By remounting your component, React verifies that navigating away and back would not break your code. Disconnecting and then connecting again is exactly what should happen! When you implement the cleanup well, there should be no user-visible difference between running the Effect once vs running it, cleaning it up, and running it again. There’s an extra connect/disconnect call pair because React is probing your code for bugs in development. This is normal—don’t try to make it go away!',
  'In production, you would only see "✅ Connecting..." printed once. Remounting components only happens in development to help you find Effects that need cleanup. You can turn off Strict Mode to opt out of the development behavior, but we recommend keeping it on. This lets you find many bugs like the one above.',
  'React intentionally remounts your components in development to find bugs like in the last example. The right question isn’t “how to run an Effect once”, but “how to fix my Effect so that it works after remounting”.',
  'Usually, the answer is to implement the cleanup function.  The cleanup function should stop or undo whatever the Effect was doing. The rule of thumb is that the user shouldn’t be able to distinguish between the Effect running once (as in production) and a setup → cleanup → setup sequence (as you’d see in development).',
  'Most of the Effects you’ll write will fit into one of the common patterns below.',
  'Sometimes you need to add UI widgets that aren’t written to React. For example, let’s say you’re adding a map component to your page. It has a setZoomLevel() method, and you’d like to keep the zoom level in sync with a zoomLevel state variable in your React code. Your Effect would look similar to this:',
  'Note that there is no cleanup needed in this case. In development, React will call the Effect twice, but this is not a problem because calling setZoomLevel twice with the same value does not do anything. It may be slightly slower, but this doesn’t matter because it won’t remount needlessly in production.',
  'Some APIs may not allow you to call them twice in a row. For example, the showModal method of the built-in <dialog> element throws if you call it twice. Implement the cleanup function and make it close the dialog:',
  'In development, your Effect will call showModal(), then immediately close(), and then showModal() again. This has the same user-visible behavior as calling showModal() once, as you would see in production.',
  'If your Effect subscribes to something, the cleanup function should unsubscribe:',
  'In development, your Effect will call addEventListener(), then immediately removeEventListener(), and then addEventListener() again with the same handler. So there would be only one active subscription at a time. This has the same user-visible behavior as calling addEventListener() once, as in production.',
  'If your Effect animates something in, the cleanup function should reset the animation to the initial values:',
  'In development, opacity will be set to 1, then to 0, and then to 1 again. This should have the same user-visible behavior as setting it to 1 directly, which is what would happen in production. If you use a third-party animation library with support for tweening, your cleanup function should reset the timeline to its initial state.',
  'If your Effect fetches something, the cleanup function should either abort the fetch or ignore its result:',
  "You can’t “undo” a network request that already happened, but your cleanup function should ensure that the fetch that’s not relevant anymore does not keep affecting your application. If the userId changes from 'Alice' to 'Bob', cleanup ensures that the 'Alice' response is ignored even if it arrives after 'Bob'.",
  'In development, you will see two fetches in the Network tab. There is nothing wrong with that. With the approach above, the first Effect will immediately get cleaned up so its copy of the ignore variable will be set to true. So even though there is an extra request, it won’t affect the state thanks to the if (!ignore) check.',
  'In production, there will only be one request. If the second request in development is bothering you, the best approach is to use a solution that deduplicates requests and caches their responses between components:',
  'This will not only improve the development experience, but also make your application feel faster. For example, the user pressing the Back button won’t have to wait for some data to load again because it will be cached. You can either build such a cache yourself or use one of the many alternatives to manual fetching in Effects.',
  'Writing fetch calls inside Effects is a popular way to fetch data, especially in fully client-side apps. This is, however, a very manual approach and it has significant downsides:',
  'This list of downsides is not specific to React. It applies to fetching data on mount with any library. Like with routing, data fetching is not trivial to do well, so we recommend the following approaches:',
  'You can continue fetching data directly in Effects if neither of these approaches suit you.',
  'Consider this code that sends an analytics event on the page visit:',
  'In development, logVisit will be called twice for every URL, so you might be tempted to try to fix that. We recommend keeping this code as is. Like with earlier examples, there is no user-visible behavior difference between running it once and running it twice. From a practical point of view, logVisit should not do anything in development because you don’t want the logs from the development machines to skew the production metrics. Your component remounts every time you save its file, so it logs extra visits in development anyway.',
  'In production, there will be no duplicate visit logs.',
  'To debug the analytics events you’re sending, you can deploy your app to a staging environment (which runs in production mode) or temporarily opt out of Strict Mode and its development-only remounting checks. You may also send analytics from the route change event handlers instead of Effects. For more precise analytics, intersection observers can help track which components are in the viewport and how long they remain visible.',
  'Some logic should only run once when the application starts. You can put it outside your components:',
  'This guarantees that such logic only runs once after the browser loads the page.',
  'Sometimes, even if you write a cleanup function, there’s no way to prevent user-visible consequences of running the Effect twice. For example, maybe your Effect sends a POST request like buying a product:',
  'You wouldn’t want to buy the product twice. However, this is also why you shouldn’t put this logic in an Effect. What if the user goes to another page and then presses Back? Your Effect would run again. You don’t want to buy the product when the user visits a page; you want to buy it when the user clicks the Buy button.',
  'Buying is not caused by rendering; it’s caused by a specific interaction. It should run only when the user presses the button. Delete the Effect and move your /api/buy request into the Buy button event handler:',
  'This illustrates that if remounting breaks the logic of your application, this usually uncovers existing bugs. From a user’s perspective, visiting a page shouldn’t be different from visiting it, clicking a link, then pressing Back to view the page again. React verifies that your components abide by this principle by remounting them once in development.',
  'This playground can help you “get a feel” for how Effects work in practice.',
  'This example uses setTimeout to schedule a console log with the input text to appear three seconds after the Effect runs. The cleanup function cancels the pending timeout. Start by pressing “Mount the component”:',
  'You will see three logs at first: Schedule "a" log, Cancel "a" log, and Schedule "a" log again. Three second later there will also be a log saying a. As you learned earlier, the extra schedule/cancel pair is because React remounts the component once in development to verify that you’ve implemented cleanup well.',
  'Now edit the input to say abc. If you do it fast enough, you’ll see Schedule "ab" log immediately followed by Cancel "ab" log and Schedule "abc" log. React always cleans up the previous render’s Effect before the next render’s Effect. This is why even if you type into the input fast, there is at most one timeout scheduled at a time. Edit the input a few times and watch the console to get a feel for how Effects get cleaned up.',
  'Type something into the input and then immediately press “Unmount the component”. Notice how unmounting cleans up the last render’s Effect. Here, it clears the last timeout before it has a chance to fire.',
  'Finally, edit the component above and comment out the cleanup function so that the timeouts don’t get cancelled. Try typing abcde fast. What do you expect to happen in three seconds? Will console.log(text) inside the timeout print the latest text and produce five abcde logs? Give it a try to check your intuition!',
  "Three seconds later, you should see a sequence of logs (a, ab, abc, abcd, and abcde) rather than five abcde logs. Each Effect “captures” the text value from its corresponding render.  It doesn’t matter that the text state changed: an Effect from the render with text = 'ab' will always see 'ab'. In other words, Effects from each render are isolated from each other. If you’re curious how this works, you can read about closures.",
  'You can think of useEffect as “attaching” a piece of behavior to the render output. Consider this Effect:',
  'Let’s see what exactly happens as the user navigates around the app.',
  `The user visits <ChatRoom roomId="general" />. Let’s mentally substitute roomId with 'general':`,
  'The Effect is also a part of the rendering output. The first render’s Effect becomes:',
  "React runs this Effect, which connects to the 'general' chat room.",
  'Let’s say <ChatRoom roomId="general" /> re-renders. The JSX output is the same:',
  ... 16 more items
]
URL:  https://react.dev/learn/you-might-not-need-an-effect
[
  'Is this page useful?',
  'Effects are an escape hatch from the React paradigm. They let you “step outside” of React and synchronize your components with some external system like a non-React widget, network, or the browser DOM. If there is no external system involved (for example, if you want to update a component’s state when some props or state change), you shouldn’t need an Effect. Removing unnecessary Effects will make your code easier to follow, faster to run, and less error-prone.',
  'There are two common cases in which you don’t need Effects:',
  'You do need Effects to synchronize with external systems. For example, you can write an Effect that keeps a jQuery widget synchronized with the React state. You can also fetch data with Effects: for example, you can synchronize the search results with the current search query. Keep in mind that modern frameworks provide more efficient built-in data fetching mechanisms than writing Effects directly in your components.',
  'To help you gain the right intuition, let’s look at some common concrete examples!',
  'Suppose you have a component with two state variables: firstName and lastName. You want to calculate a fullName from them by concatenating them. Moreover, you’d like fullName to update whenever firstName or lastName change. Your first instinct might be to add a fullName state variable and update it in an Effect:',
  'This is more complicated than necessary. It is inefficient too: it does an entire render pass with a stale value for fullName, then immediately re-renders with the updated value. Remove the state variable and the Effect:',
  'When something can be calculated from the existing props or state, don’t put it in state. Instead, calculate it during rendering. This makes your code faster (you avoid the extra “cascading” updates), simpler (you remove some code), and less error-prone (you avoid bugs caused by different state variables getting out of sync with each other). If this approach feels new to you, Thinking in React explains what should go into state.',
  'This component computes visibleTodos by taking the todos it receives by props and filtering them according to the filter prop. You might feel tempted to store the result in state and update it from an Effect:',
  'Like in the earlier example, this is both unnecessary and inefficient. First, remove the state and the Effect:',
  'Usually, this code is fine! But maybe getFilteredTodos() is slow or you have a lot of todos. In that case you don’t want to recalculate getFilteredTodos() if some unrelated state variable like newTodo has changed.',
  'You can cache (or “memoize”) an expensive calculation by wrapping it in a useMemo Hook:',
  'Or, written as a single line:',
  'This tells React that you don’t want the inner function to re-run unless either todos or filter have changed. React will remember the return value of getFilteredTodos() during the initial render. During the next renders, it will check if todos or filter are different. If they’re the same as last time, useMemo will return the last result it has stored. But if they are different, React will call the inner function again (and store its result).',
  'The function you wrap in useMemo runs during rendering, so this only works for pure calculations.',
  'In general, unless you’re creating or looping over thousands of objects, it’s probably not expensive. If you want to get more confidence, you can add a console log to measure the time spent in a piece of code:',
  'Perform the interaction you’re measuring (for example, typing into the input). You will then see logs like filter array: 0.15ms in your console. If the overall logged time adds up to a significant amount (say, 1ms or more), it might make sense to memoize that calculation. As an experiment, you can then wrap the calculation in useMemo to verify whether the total logged time has decreased for that interaction or not:',
  'useMemo won’t make the first render faster. It only helps you skip unnecessary work on updates.',
  'Keep in mind that your machine is probably faster than your users’ so it’s a good idea to test the performance with an artificial slowdown. For example, Chrome offers a CPU Throttling option for this.',
  'Also note that measuring performance in development will not give you the most accurate results. (For example, when Strict Mode is on, you will see each component render twice rather than once.) To get the most accurate timings, build your app for production and test it on a device like your users have.',
  'This ProfilePage component receives a userId prop. The page contains a comment input, and you use a comment state variable to hold its value. One day, you notice a problem: when you navigate from one profile to another, the comment state does not get reset. As a result, it’s easy to accidentally post a comment on a wrong user’s profile. To fix the issue, you want to clear out the comment state variable whenever the userId changes:',
  'This is inefficient because ProfilePage and its children will first render with the stale value, and then render again. It is also complicated because you’d need to do this in every component that has some state inside ProfilePage. For example, if the comment UI is nested, you’d want to clear out nested comment state too.',
  'Instead, you can tell React that each user’s profile is conceptually a different profile by giving it an explicit key. Split your component in two and pass a key attribute from the outer component to the inner one:',
  'Normally, React preserves the state when the same component is rendered in the same spot. By passing userId as a key to the Profile component, you’re asking React to treat two Profile components with different userId as two different components that should not share any state. Whenever the key (which you’ve set to userId) changes, React will recreate the DOM and reset the state of the Profile component and all of its children. Now the comment field will clear out automatically when navigating between profiles.',
  'Note that in this example, only the outer ProfilePage component is exported and visible to other files in the project. Components rendering ProfilePage don’t need to pass the key to it: they pass userId as a regular prop. The fact ProfilePage passes it as a key to the inner Profile component is an implementation detail.',
  'Sometimes, you might want to reset or adjust a part of the state on a prop change, but not all of it.',
  'This List component receives a list of items as a prop, and maintains the selected item in the selection state variable. You want to reset the selection to null whenever the items prop receives a different array:',
  'This, too, is not ideal. Every time the items change, the List and its child components will render with a stale selection value at first. Then React will update the DOM and run the Effects. Finally, the setSelection(null) call will cause another re-render of the List and its child components, restarting this whole process again.',
  'Start by deleting the Effect. Instead, adjust the state directly during rendering:',
  'Storing information from previous renders like this can be hard to understand, but it’s better than updating the same state in an Effect. In the above example, setSelection is called directly during a render. React will re-render the List immediately after it exits with a return statement. React has not rendered the List children or updated the DOM yet, so this lets the List children skip rendering the stale selection value.',
  'When you update a component during rendering, React throws away the returned JSX and immediately retries rendering. To avoid very slow cascading retries, React only lets you update the same component’s state during a render. If you update another component’s state during a render, you’ll see an error. A condition like items !== prevItems is necessary to avoid loops. You may adjust state like this, but any other side effects (like changing the DOM or setting timeouts) should stay in event handlers or Effects to keep components pure.',
  'Although this pattern is more efficient than an Effect, most components shouldn’t need it either. No matter how you do it, adjusting state based on props or other state makes your data flow more difficult to understand and debug. Always check whether you can reset all state with a key or calculate everything during rendering instead. For example, instead of storing (and resetting) the selected item, you can store the selected item ID:',
  'Now there is no need to “adjust” the state at all. If the item with the selected ID is in the list, it remains selected. If it’s not, the selection calculated during rendering will be null because no matching item was found. This behavior is different, but arguably better because most changes to items preserve the selection.',
  'Let’s say you have a product page with two buttons (Buy and Checkout) that both let you buy that product. You want to show a notification whenever the user puts the product in the cart. Calling showNotification() in both buttons’ click handlers feels repetitive so you might be tempted to place this logic in an Effect:',
  'This Effect is unnecessary. It will also most likely cause bugs. For example, let’s say that your app “remembers” the shopping cart between the page reloads. If you add a product to the cart once and refresh the page, the notification will appear again. It will keep appearing every time you refresh that product’s page. This is because product.isInCart will already be true on the page load, so the Effect above will call showNotification().',
  'When you’re not sure whether some code should be in an Effect or in an event handler, ask yourself why this code needs to run. Use Effects only for code that should run because the component was displayed to the user. In this example, the notification should appear because the user pressed the button, not because the page was displayed! Delete the Effect and put the shared logic into a function called from both event handlers:',
  'This both removes the unnecessary Effect and fixes the bug.',
  'This Form component sends two kinds of POST requests. It sends an analytics event when it mounts. When you fill in the form and click the Submit button, it will send a POST request to the /api/register endpoint:',
  'Let’s apply the same criteria as in the example before.',
  'The analytics POST request should remain in an Effect. This is because the reason to send the analytics event is that the form was displayed. (It would fire twice in development, but see here for how to deal with that.)',
  'However, the /api/register POST request is not caused by the form being displayed. You only want to send the request at one specific moment in time: when the user presses the button. It should only ever happen on that particular interaction. Delete the second Effect and move that POST request into the event handler:',
  'When you choose whether to put some logic into an event handler or an Effect, the main question you need to answer is what kind of logic it is from the user’s perspective. If this logic is caused by a particular interaction, keep it in the event handler. If it’s caused by the user seeing the component on the screen, keep it in the Effect.',
  'Sometimes you might feel tempted to chain Effects that each adjust a piece of state based on other state:',
  'There are two problems with this code.',
  'One problem is that it is very inefficient: the component (and its children) have to re-render between each set call in the chain. In the example above, in the worst case (setCard → render → setGoldCardCount → render → setRound → render → setIsGameOver → render) there are three unnecessary re-renders of the tree below.',
  'Even if it weren’t slow, as your code evolves, you will run into cases where the “chain” you wrote doesn’t fit the new requirements. Imagine you are adding a way to step through the history of the game moves. You’d do it by updating each state variable to a value from the past. However, setting the card state to a value from the past would trigger the Effect chain again and change the data you’re showing. Such code is often rigid and fragile.',
  'In this case, it’s better to calculate what you can during rendering, and adjust the state in the event handler:',
  'This is a lot more efficient. Also, if you implement a way to view game history, now you will be able to set each state variable to a move from the past without triggering the Effect chain that adjusts every other value. If you need to reuse logic between several event handlers, you can extract a function and call it from those handlers.',
  'Remember that inside event handlers, state behaves like a snapshot. For example, even after you call setRound(round + 1), the round variable will reflect the value at the time the user clicked the button. If you need to use the next value for calculations, define it manually like const nextRound = round + 1.',
  'In some cases, you can’t calculate the next state directly in the event handler. For example, imagine a form with multiple dropdowns where the options of the next dropdown depend on the selected value of the previous dropdown. Then, a chain of Effects is appropriate because you are synchronizing with network.',
  'Some logic should only run once when the app loads.',
  'You might be tempted to place it in an Effect in the top-level component:',
  'However, you’ll quickly discover that it runs twice in development. This can cause issues—for example, maybe it invalidates the authentication token because the function wasn’t designed to be called twice. In general, your components should be resilient to being remounted. This includes your top-level App component.',
  'Although it may not ever get remounted in practice in production, following the same constraints in all components makes it easier to move and reuse code. If some logic must run once per app load rather than once per component mount, add a top-level variable to track whether it has already executed:',
  'You can also run it during module initialization and before the app renders:',
  'Code at the top level runs once when your component is imported—even if it doesn’t end up being rendered. To avoid slowdown or surprising behavior when importing arbitrary components, don’t overuse this pattern. Keep app-wide initialization logic to root component modules like App.js or in your application’s entry point.',
  'Let’s say you’re writing a Toggle component with an internal isOn state which can be either true or false. There are a few different ways to toggle it (by clicking or dragging). You want to notify the parent component whenever the Toggle internal state changes, so you expose an onChange event and call it from an Effect:',
  'Like earlier, this is not ideal. The Toggle updates its state first, and React updates the screen. Then React runs the Effect, which calls the onChange function passed from a parent component. Now the parent component will update its own state, starting another render pass. It would be better to do everything in a single pass.',
  'Delete the Effect and instead update the state of both components within the same event handler:',
  'With this approach, both the Toggle component and its parent component update their state during the event. React batches updates from different components together, so there will only be one render pass.',
  'You might also be able to remove the state altogether, and instead receive isOn from the parent component:',
  '“Lifting state up” lets the parent component fully control the Toggle by toggling the parent’s own state. This means the parent component will have to contain more logic, but there will be less state overall to worry about. Whenever you try to keep two different state variables synchronized, try lifting state up instead!',
  'This Child component fetches some data and then passes it to the Parent component in an Effect:',
  'In React, data flows from the parent components to their children. When you see something wrong on the screen, you can trace where the information comes from by going up the component chain until you find which component passes the wrong prop or has the wrong state. When child components update the state of their parent components in Effects, the data flow becomes very difficult to trace. Since both the child and the parent need the same data, let the parent component fetch that data, and pass it down to the child instead:',
  'This is simpler and keeps the data flow predictable: the data flows down from the parent to the child.',
  'Sometimes, your components may need to subscribe to some data outside of the React state. This data could be from a third-party library or a built-in browser API. Since this data can change without React’s knowledge, you need to manually subscribe your components to it. This is often done with an Effect, for example:',
  'Here, the component subscribes to an external data store (in this case, the browser navigator.onLine API). Since this API does not exist on the server (so it can’t be used for the initial HTML), initially the state is set to true. Whenever the value of that data store changes in the browser, the component updates its state.',
  'Although it’s common to use Effects for this, React has a purpose-built Hook for subscribing to an external store that is preferred instead. Delete the Effect and replace it with a call to useSyncExternalStore:',
  'This approach is less error-prone than manually syncing mutable data to React state with an Effect. Typically, you’ll write a custom Hook like useOnlineStatus() above so that you don’t need to repeat this code in the individual components. Read more about subscribing to external stores from React components.',
  'Many apps use Effects to kick off data fetching. It is quite common to write a data fetching Effect like this:',
  'You don’t need to move this fetch to an event handler.',
  'This might seem like a contradiction with the earlier examples where you needed to put the logic into the event handlers! However, consider that it’s not the typing event that’s the main reason to fetch. Search inputs are often prepopulated from the URL, and the user might navigate Back and Forward without touching the input.',
  'It doesn’t matter where page and query come from. While this component is visible, you want to keep results synchronized with data from the network for the current page and query. This is why it’s an Effect.',
  'However, the code above has a bug. Imagine you type "hello" fast. Then the query will change from "h", to "he", "hel", "hell", and "hello". This will kick off separate fetches, but there is no guarantee about which order the responses will arrive in. For example, the "hell" response may arrive after the "hello" response. Since it will call setResults() last, you will be displaying the wrong search results. This is called a “race condition”: two different requests “raced” against each other and came in a different order than you expected.',
  'To fix the race condition, you need to add a cleanup function to ignore stale responses:',
  'This ensures that when your Effect fetches data, all responses except the last requested one will be ignored.',
  'Handling race conditions is not the only difficulty with implementing data fetching. You might also want to think about caching responses (so that the user can click Back and see the previous screen instantly), how to fetch data on the server (so that the initial server-rendered HTML contains the fetched content instead of a spinner), and how to avoid network waterfalls (so that a child can fetch data without waiting for every parent).',
  'These issues apply to any UI library, not just React. Solving them is not trivial, which is why modern frameworks provide more efficient built-in data fetching mechanisms than fetching data in Effects.',
  'If you don’t use a framework (and don’t want to build your own) but would like to make data fetching from Effects more ergonomic, consider extracting your fetching logic into a custom Hook like in this example:',
  'You’ll likely also want to add some logic for error handling and to track whether the content is loading. You can build a Hook like this yourself or use one of the many solutions already available in the React ecosystem. Although this alone won’t be as efficient as using a framework’s built-in data fetching mechanism, moving the data fetching logic into a custom Hook will make it easier to adopt an efficient data fetching strategy later.',
  'In general, whenever you have to resort to writing Effects, keep an eye out for when you can extract a piece of functionality into a custom Hook with a more declarative and purpose-built API like useData above. The fewer raw useEffect calls you have in your components, the easier you will find to maintain your application.',
  'The TodoList below displays a list of todos. When the “Show only active todos” checkbox is ticked, completed todos are not displayed in the list. Regardless of which todos are visible, the footer displays the count of todos that are not yet completed.',
  'Simplify this component by removing all the unnecessary state and Effects.',
  'How do you like these docs?'
]
URL:  https://react.dev/learn/lifecycle-of-reactive-effects
[
  'Is this page useful?',
  'Effects have a different lifecycle from components. Components may mount, update, or unmount. An Effect can only do two things: to start synchronizing something, and later to stop synchronizing it. This cycle can happen multiple times if your Effect depends on props and state that change over time. React provides a linter rule to check that you’ve specified your Effect’s dependencies correctly. This keeps your Effect synchronized to the latest props and state.',
  'Every React component goes through the same lifecycle:',
  'It’s a good way to think about components, but not about Effects. Instead, try to think about each Effect independently from your component’s lifecycle. An Effect describes how to synchronize an external system to the current props and state. As your code changes, synchronization will need to happen more or less often.',
  'To illustrate this point, consider this Effect connecting your component to a chat server:',
  'Your Effect’s body specifies how to start synchronizing:',
  'The cleanup function returned by your Effect specifies how to stop synchronizing:',
  'Intuitively, you might think that React would start synchronizing when your component mounts and stop synchronizing when your component unmounts. However, this is not the end of the story! Sometimes, it may also be necessary to start and stop synchronizing multiple times while the component remains mounted.',
  'Let’s look at why this is necessary, when it happens, and how you can control this behavior.',
  'Some Effects don’t return a cleanup function at all. More often than not, you’ll want to return one—but if you don’t, React will behave as if you returned an empty cleanup function.',
  'Imagine this ChatRoom component receives a roomId prop that the user picks in a dropdown. Let’s say that initially the user picks the "general" room as the roomId. Your app displays the "general" chat room:',
  'After the UI is displayed, React will run your Effect to start synchronizing. It connects to the "general" room:',
  'So far, so good.',
  'Later, the user picks a different room in the dropdown (for example, "travel"). First, React will update the UI:',
  'Think about what should happen next. The user sees that "travel" is the selected chat room in the UI. However, the Effect that ran the last time is still connected to the "general" room. The roomId prop has changed, so what your Effect did back then (connecting to the "general" room) no longer matches the UI.',
  'At this point, you want React to do two things:',
  'Luckily, you’ve already taught React how to do both of these things! Your Effect’s body specifies how to start synchronizing, and your cleanup function specifies how to stop synchronizing. All that React needs to do now is to call them in the correct order and with the correct props and state. Let’s see how exactly that happens.',
  'Recall that your ChatRoom component has received a new value for its roomId prop. It used to be "general", and now it is "travel". React needs to re-synchronize your Effect to re-connect you to a different room.',
  'To stop synchronizing, React will call the cleanup function that your Effect returned after connecting to the "general" room. Since roomId was "general", the cleanup function disconnects from the "general" room:',
  'Then React will run the Effect that you’ve provided during this render. This time, roomId is "travel" so it will start synchronizing to the "travel" chat room (until its cleanup function is eventually called too):',
  'Thanks to this, you’re now connected to the same room that the user chose in the UI. Disaster averted!',
  'Every time after your component re-renders with a different roomId, your Effect will re-synchronize. For example, let’s say the user changes roomId from "travel" to "music". React will again stop synchronizing your Effect by calling its cleanup function (disconnecting you from the "travel" room). Then it will start synchronizing again by running its body with the new roomId prop (connecting you to the "music" room).',
  'Finally, when the user goes to a different screen, ChatRoom unmounts. Now there is no need to stay connected at all. React will stop synchronizing your Effect one last time and disconnect you from the "music" chat room.',
  'Let’s recap everything that’s happened from the ChatRoom component’s perspective:',
  'During each of these points in the component’s lifecycle, your Effect did different things:',
  'Now let’s think about what happened from the perspective of the Effect itself:',
  'This code’s structure might inspire you to see what happened as a sequence of non-overlapping time periods:',
  'Previously, you were thinking from the component’s perspective. When you looked from the component’s perspective, it was tempting to think of Effects as “callbacks” or “lifecycle events” that fire at a specific time like “after a render” or “before unmount”. This way of thinking gets complicated very fast, so it’s best to avoid.',
  'Instead, always focus on a single start/stop cycle at a time. It shouldn’t matter whether a component is mounting, updating, or unmounting. All you need to do is to describe how to start synchronization and how to stop it. If you do it well, your Effect will be resilient to being started and stopped as many times as it’s needed.',
  'This might remind you how you don’t think whether a component is mounting or updating when you write the rendering logic that creates JSX. You describe what should be on the screen, and React figures out the rest.',
  'Here is a live example that you can play with. Press “Open chat” to mount the ChatRoom component:',
  'Notice that when the component mounts for the first time, you see three logs:',
  'The first two logs are development-only. In development, React always remounts each component once.',
  'React verifies that your Effect can re-synchronize by forcing it to do that immediately in development. This might remind you of opening a door and closing it an extra time to check if the door lock works. React starts and stops your Effect one extra time in development to check you’ve implemented its cleanup well.',
  'The main reason your Effect will re-synchronize in practice is if some data it uses has changed. In the sandbox above, change the selected chat room. Notice how, when the roomId changes, your Effect re-synchronizes.',
  'However, there are also more unusual cases in which re-synchronization is necessary. For example, try editing the serverUrl in the sandbox above while the chat is open. Notice how the Effect re-synchronizes in response to your edits to the code. In the future, React may add more features that rely on re-synchronization.',
  'You might be wondering how React knew that your Effect needed to re-synchronize after roomId changes. It’s because you told React that its code depends on roomId by including it in the list of dependencies:',
  'Here’s how this works:',
  'Every time after your component re-renders, React will look at the array of dependencies that you have passed. If any of the values in the array is different from the value at the same spot that you passed during the previous render, React will re-synchronize your Effect.',
  'For example, if you passed ["general"] during the initial render, and later you passed ["travel"] during the next render, React will compare "general" and "travel". These are different values (compared with Object.is), so React will re-synchronize your Effect. On the other hand, if your component re-renders but roomId has not changed, your Effect will remain connected to the same room.',
  'Resist adding unrelated logic to your Effect only because this logic needs to run at the same time as an Effect you already wrote. For example, let’s say you want to send an analytics event when the user visits the room. You already have an Effect that depends on roomId, so you might feel tempted to add the analytics call there:',
  'But imagine you later add another dependency to this Effect that needs to re-establish the connection. If this Effect re-synchronizes, it will also call logVisit(roomId) for the same room, which you did not intend. Logging the visit is a separate process from connecting. Write them as two separate Effects:',
  'Each Effect in your code should represent a separate and independent synchronization process.',
  'In the above example, deleting one Effect wouldn’t break the other Effect’s logic. This is a good indication that they synchronize different things, and so it made sense to split them up. On the other hand, if you split up a cohesive piece of logic into separate Effects, the code may look “cleaner” but will be more difficult to maintain. This is why you should think whether the processes are same or separate, not whether the code looks cleaner.',
  'Your Effect reads two variables (serverUrl and roomId), but you only specified roomId as a dependency:',
  'Why doesn’t serverUrl need to be a dependency?',
  'This is because the serverUrl never changes due to a re-render. It’s always the same no matter how many times the component re-renders and why. Since serverUrl never changes, it wouldn’t make sense to specify it as a dependency. After all, dependencies only do something when they change over time!',
  'On the other hand, roomId may be different on a re-render. Props, state, and other values declared inside the component are reactive because they’re calculated during rendering and participate in the React data flow.',
  'If serverUrl was a state variable, it would be reactive. Reactive values must be included in dependencies:',
  'By including serverUrl as a dependency, you ensure that the Effect re-synchronizes after it changes.',
  'Try changing the selected chat room or edit the server URL in this sandbox:',
  'Whenever you change a reactive value like roomId or serverUrl, the Effect re-connects to the chat server.',
  'What happens if you move both serverUrl and roomId outside the component?',
  'Now your Effect’s code does not use any reactive values, so its dependencies can be empty ([]).',
  'Thinking from the component’s perspective, the empty [] dependency array means this Effect connects to the chat room only when the component mounts, and disconnects only when the component unmounts. (Keep in mind that React would still re-synchronize it an extra time in development to stress-test your logic.)',
  'However, if you think from the Effect’s perspective, you don’t need to think about mounting and unmounting at all. What’s important is you’ve specified what your Effect does to start and stop synchronizing. Today, it has no reactive dependencies. But if you ever want the user to change roomId or serverUrl over time (and they would become reactive), your Effect’s code won’t change. You will only need to add them to the dependencies.',
  'Props and state aren’t the only reactive values. Values that you calculate from them are also reactive. If the props or state change, your component will re-render, and the values calculated from them will also change. This is why all variables from the component body used by the Effect should be in the Effect dependency list.',
  'Let’s say that the user can pick a chat server in the dropdown, but they can also configure a default server in settings. Suppose you’ve already put the settings state in a context so you read the settings from that context. Now you calculate the serverUrl based on the selected server from props and the default server:',
  'In this example, serverUrl is not a prop or a state variable. It’s a regular variable that you calculate during rendering. But it’s calculated during rendering, so it can change due to a re-render. This is why it’s reactive.',
  'All values inside the component (including props, state, and variables in your component’s body) are reactive. Any reactive value can change on a re-render, so you need to include reactive values as Effect’s dependencies.',
  'In other words, Effects “react” to all values from the component body.',
  'Mutable values (including global variables) aren’t reactive.',
  'A mutable value like location.pathname can’t be a dependency. It’s mutable, so it can change at any time completely outside of the React rendering data flow. Changing it wouldn’t trigger a re-render of your component. Therefore, even if you specified it in the dependencies, React wouldn’t know to re-synchronize the Effect when it changes. This also breaks the rules of React because reading mutable data during rendering (which is when you calculate the dependencies) breaks purity of rendering. Instead, you should read and subscribe to an external mutable value with useSyncExternalStore.',
  'A mutable value like ref.current or things you read from it also can’t be a dependency. The ref object returned by useRef itself can be a dependency, but its current property is intentionally mutable. It lets you keep track of something without triggering a re-render. But since changing it doesn’t trigger a re-render, it’s not a reactive value, and React won’t know to re-run your Effect when it changes.',
  'As you’ll learn below on this page, a linter will check for these issues automatically.',
  'If your linter is configured for React, it will check that every reactive value used by your Effect’s code is declared as its dependency. For example, this is a lint error because both roomId and serverUrl are reactive:',
  'This may look like a React error, but really React is pointing out a bug in your code. Both roomId and serverUrl may change over time, but you’re forgetting to re-synchronize your Effect when they change. You will remain connected to the initial roomId and serverUrl even after the user picks different values in the UI.',
  'To fix the bug, follow the linter’s suggestion to specify roomId and serverUrl as dependencies of your Effect:',
  'Try this fix in the sandbox above. Verify that the linter error is gone, and the chat re-connects when needed.',
  'In some cases, React knows that a value never changes even though it’s declared inside the component. For example, the set function returned from useState and the ref object returned by useRef are stable—they are guaranteed to not change on a re-render. Stable values aren’t reactive, so you may omit them from the list. Including them is allowed: they won’t change, so it doesn’t matter.',
  'In the previous example, you’ve fixed the lint error by listing roomId and serverUrl as dependencies.',
  'However, you could instead “prove” to the linter that these values aren’t reactive values, i.e. that they can’t change as a result of a re-render. For example, if serverUrl and roomId don’t depend on rendering and always have the same values, you can move them outside the component. Now they don’t need to be dependencies:',
  'You can also move them inside the Effect. They aren’t calculated during rendering, so they’re not reactive:',
  'Effects are reactive blocks of code. They re-synchronize when the values you read inside of them change. Unlike event handlers, which only run once per interaction, Effects run whenever synchronization is necessary.',
  'You can’t “choose” your dependencies. Your dependencies must include every reactive value you read in the Effect. The linter enforces this. Sometimes this may lead to problems like infinite loops and to your Effect re-synchronizing too often. Don’t fix these problems by suppressing the linter! Here’s what to try instead:',
  'Check that your Effect represents an independent synchronization process. If your Effect doesn’t synchronize anything, it might be unnecessary. If it synchronizes several independent things, split it up.',
  'If you want to read the latest value of props or state without “reacting” to it and re-synchronizing the Effect, you can split your Effect into a reactive part (which you’ll keep in the Effect) and a non-reactive part (which you’ll extract into something called an Effect Event). Read about separating Events from Effects.',
  'Avoid relying on objects and functions as dependencies. If you create objects and functions during rendering and then read them from an Effect, they will be different on every render. This will cause your Effect to re-synchronize every time. Read more about removing unnecessary dependencies from Effects.',
  'The linter is your friend, but its powers are limited. The linter only knows when the dependencies are wrong. It doesn’t know the best way to solve each case. If the linter suggests a dependency, but adding it causes a loop, it doesn’t mean the linter should be ignored. You need to change the code inside (or outside) the Effect so that that value isn’t reactive and doesn’t need to be a dependency.',
  'If you have an existing codebase, you might have some Effects that suppress the linter like this:',
  'On the next pages, you’ll learn how to fix this code without breaking the rules. It’s always worth fixing!',
  'In this example, the ChatRoom component connects to the chat room when the component mounts, disconnects when it unmounts, and reconnects when you select a different chat room. This behavior is correct, so you need to keep it working.',
  'However, there is a problem. Whenever you type into the message box input at the bottom, ChatRoom also reconnects to the chat. (You can notice this by clearing the console and typing into the input.) Fix the issue so that this doesn’t happen.',
  'How do you like these docs?'
]
URL:  https://react.dev/learn/separating-events-from-effects
[
  'Is this page useful?',
  'Event handlers only re-run when you perform the same interaction again. Unlike event handlers, Effects re-synchronize if some value they read, like a prop or a state variable, is different from what it was during the last render. Sometimes, you also want a mix of both behaviors: an Effect that re-runs in response to some values but not others. This page will teach you how to do that.',
  'First, let’s recap the difference between event handlers and Effects.',
  'Imagine you’re implementing a chat room component. Your requirements look like this:',
  'Let’s say you’ve already implemented the code for them, but you’re not sure where to put it. Should you use event handlers or Effects? Every time you need to answer this question, consider why the code needs to run.',
  'From the user’s perspective, sending a message should happen because the particular “Send” button was clicked. The user will get rather upset if you send their message at any other time or for any other reason. This is why sending a message should be an event handler. Event handlers let you handle specific interactions:',
  'With an event handler, you can be sure that sendMessage(message) will only run if the user presses the button.',
  'Recall that you also need to keep the component connected to the chat room. Where does that code go?',
  'The reason to run this code is not some particular interaction. It doesn’t matter why or how the user navigated to the chat room screen. Now that they’re looking at it and could interact with it, the component needs to stay connected to the selected chat server. Even if the chat room component was the initial screen of your app, and the user has not performed any interactions at all, you would still need to connect. This is why it’s an Effect:',
  'With this code, you can be sure that there is always an active connection to the currently selected chat server, regardless of the specific interactions performed by the user. Whether the user has only opened your app, selected a different room, or navigated to another screen and back, your Effect ensures that the component will remain synchronized with the currently selected room, and will re-connect whenever it’s necessary.',
  'Intuitively, you could say that event handlers are always triggered “manually”, for example by clicking a button. Effects, on the other hand, are “automatic”: they run and re-run as often as it’s needed to stay synchronized.',
  'There is a more precise way to think about this.',
  'Props, state, and variables declared inside your component’s body are called reactive values. In this example, serverUrl is not a reactive value, but roomId and message are. They participate in the rendering data flow:',
  'Reactive values like these can change due to a re-render. For example, the user may edit the message or choose a different roomId in a dropdown. Event handlers and Effects respond to changes differently:',
  'Let’s revisit the previous example to illustrate this difference.',
  'Take a look at this line of code. Should this logic be reactive or not?',
  'From the user’s perspective, a change to the message does not mean that they want to send a message. It only means that the user is typing. In other words, the logic that sends a message should not be reactive. It should not run again only because the reactive value has changed. That’s why it belongs in the event handler:',
  'Event handlers aren’t reactive, so sendMessage(message) will only run when the user clicks the Send button.',
  'Now let’s return to these lines:',
  'From the user’s perspective, a change to the roomId does mean that they want to connect to a different room. In other words, the logic for connecting to the room should be reactive. You want these lines of code to “keep up” with the reactive value, and to run again if that value is different. That’s why it belongs in an Effect:',
  'Effects are reactive, so createConnection(serverUrl, roomId) and connection.connect() will run for every distinct value of roomId. Your Effect keeps the chat connection synchronized to the currently selected room.',
  'Things get more tricky when you want to mix reactive logic with non-reactive logic.',
  'For example, imagine that you want to show a notification when the user connects to the chat. You read the current theme (dark or light) from the props so that you can show the notification in the correct color:',
  'However, theme is a reactive value (it can change as a result of re-rendering), and every reactive value read by an Effect must be declared as its dependency. Now you have to specify theme as a dependency of your Effect:',
  'Play with this example and see if you can spot the problem with this user experience:',
  'When the roomId changes, the chat re-connects as you would expect. But since theme is also a dependency, the chat also re-connects every time you switch between the dark and the light theme. That’s not great!',
  'In other words, you don’t want this line to be reactive, even though it is inside an Effect (which is reactive):',
  'You need a way to separate this non-reactive logic from the reactive Effect around it.',
  'This section describes an experimental API that has not yet been released in a stable version of React.',
  'Use a special Hook called useEffectEvent to extract this non-reactive logic out of your Effect:',
  'Here, onConnected is called an Effect Event. It’s a part of your Effect logic, but it behaves a lot more like an event handler. The logic inside it is not reactive, and it always “sees” the latest values of your props and state.',
  'Now you can call the onConnected Effect Event from inside your Effect:',
  'This solves the problem. Note that you had to remove onConnected from the list of your Effect’s dependencies. Effect Events are not reactive and must be omitted from dependencies.',
  'Verify that the new behavior works as you would expect:',
  'You can think of Effect Events as being very similar to event handlers. The main difference is that event handlers run in response to a user interactions, whereas Effect Events are triggered by you from Effects. Effect Events let you “break the chain” between the reactivity of Effects and code that should not be reactive.',
  'This section describes an experimental API that has not yet been released in a stable version of React.',
  'Effect Events let you fix many patterns where you might be tempted to suppress the dependency linter.',
  'For example, say you have an Effect to log the page visits:',
  'Later, you add multiple routes to your site. Now your Page component receives a url prop with the current path. You want to pass the url as a part of your logVisit call, but the dependency linter complains:',
  'Think about what you want the code to do. You want to log a separate visit for different URLs since each URL represents a different page. In other words, this logVisit call should be reactive with respect to the url. This is why, in this case, it makes sense to follow the dependency linter, and add url as a dependency:',
  'Now let’s say you want to include the number of items in the shopping cart together with every page visit:',
  'You used numberOfItems inside the Effect, so the linter asks you to add it as a dependency. However, you don’t want the logVisit call to be reactive with respect to numberOfItems. If the user puts something into the shopping cart, and the numberOfItems changes, this does not mean that the user visited the page again. In other words, visiting the page is, in some sense, an “event”. It happens at a precise moment in time.',
  'Split the code in two parts:',
  'Here, onVisit is an Effect Event. The code inside it isn’t reactive. This is why you can use numberOfItems (or any other reactive value!) without worrying that it will cause the surrounding code to re-execute on changes.',
  'On the other hand, the Effect itself remains reactive. Code inside the Effect uses the url prop, so the Effect will re-run after every re-render with a different url. This, in turn, will call the onVisit Effect Event.',
  'As a result, you will call logVisit for every change to the url, and always read the latest numberOfItems. However, if numberOfItems changes on its own, this will not cause any of the code to re-run.',
  'You might be wondering if you could call onVisit() with no arguments, and read the url inside it:',
  'This would work, but it’s better to pass this url to the Effect Event explicitly. By passing url as an argument to your Effect Event, you are saying that visiting a page with a different url constitutes a separate “event” from the user’s perspective. The visitedUrl is a part of the “event” that happened:',
  'Since your Effect Event explicitly “asks” for the visitedUrl, now you can’t accidentally remove url from the Effect’s dependencies. If you remove the url dependency (causing distinct page visits to be counted as one), the linter will warn you about it. You want onVisit to be reactive with regards to the url, so instead of reading the url inside (where it wouldn’t be reactive), you pass it from your Effect.',
  'This becomes especially important if there is some asynchronous logic inside the Effect:',
  'Here, url inside onVisit corresponds to the latest url (which could have already changed), but visitedUrl corresponds to the url that originally caused this Effect (and this onVisit call) to run.',
  'In the existing codebases, you may sometimes see the lint rule suppressed like this:',
  'After useEffectEvent becomes a stable part of React, we recommend never suppressing the linter.',
  'The first downside of suppressing the rule is that React will no longer warn you when your Effect needs to “react” to a new reactive dependency you’ve introduced to your code. In the earlier example, you added url to the dependencies because React reminded you to do it. You will no longer get such reminders for any future edits to that Effect if you disable the linter. This leads to bugs.',
  'Here is an example of a confusing bug caused by suppressing the linter. In this example, the handleMove function is supposed to read the current canMove state variable value in order to decide whether the dot should follow the cursor. However, canMove is always true inside handleMove.',
  'Can you see why?',
  'The problem with this code is in suppressing the dependency linter. If you remove the suppression, you’ll see that this Effect should depend on the handleMove function. This makes sense: handleMove is declared inside the component body, which makes it a reactive value. Every reactive value must be specified as a dependency, or it can potentially get stale over time!',
  'The author of the original code has “lied” to React by saying that the Effect does not depend ([]) on any reactive values. This is why React did not re-synchronize the Effect after canMove has changed (and handleMove with it). Because React did not re-synchronize the Effect, the handleMove attached as a listener is the handleMove function created during the initial render. During the initial render, canMove was true, which is why handleMove from the initial render will forever see that value.',
  'If you never suppress the linter, you will never see problems with stale values.',
  'With useEffectEvent, there is no need to “lie” to the linter, and the code works as you would expect:',
  'This doesn’t mean that useEffectEvent is always the correct solution. You should only apply it to the lines of code that you don’t want to be reactive. In the above sandbox, you didn’t want the Effect’s code to be reactive with regards to canMove. That’s why it made sense to extract an Effect Event.',
  'Read Removing Effect Dependencies for other correct alternatives to suppressing the linter.',
  'This section describes an experimental API that has not yet been released in a stable version of React.',
  'Effect Events are very limited in how you can use them:',
  'For example, don’t declare and pass an Effect Event like this:',
  'Instead, always declare Effect Events directly next to the Effects that use them:',
  'Effect Events are non-reactive “pieces” of your Effect code. They should be next to the Effect using them.',
  'This Timer component keeps a count state variable which increases every second. The value by which it’s increasing is stored in the increment state variable. You can control the increment variable with the plus and minus buttons.',
  'However, no matter how many times you click the plus button, the counter is still incremented by one every second. What’s wrong with this code? Why is increment always equal to 1 inside the Effect’s code? Find the mistake and fix it.',
  'How do you like these docs?'
]
URL:  https://react.dev/learn/removing-effect-dependencies
[
  'Is this page useful?',
  'When you write an Effect, the linter will verify that you’ve included every reactive value (like props and state) that the Effect reads in the list of your Effect’s dependencies. This ensures that your Effect remains synchronized with the latest props and state of your component. Unnecessary dependencies may cause your Effect to run too often, or even create an infinite loop. Follow this guide to review and remove unnecessary dependencies from your Effects.',
  'When you write an Effect, you first specify how to start and stop whatever you want your Effect to be doing:',
  'Then, if you leave the Effect dependencies empty ([]), the linter will suggest the correct dependencies:',
  'Fill them in according to what the linter says:',
  'Effects “react” to reactive values. Since roomId is a reactive value (it can change due to a re-render), the linter verifies that you’ve specified it as a dependency. If roomId receives a different value, React will re-synchronize your Effect. This ensures that the chat stays connected to the selected room and “reacts” to the dropdown:',
  'Notice that you can’t “choose” the dependencies of your Effect. Every reactive value used by your Effect’s code must be declared in your dependency list. The dependency list is determined by the surrounding code:',
  'Reactive values include props and all variables and functions declared directly inside of your component. Since roomId is a reactive value, you can’t remove it from the dependency list. The linter wouldn’t allow it:',
  'And the linter would be right! Since roomId may change over time, this would introduce a bug in your code.',
  'To remove a dependency, “prove” to the linter that it doesn’t need to be a dependency. For example, you can move roomId out of your component to prove that it’s not reactive and won’t change on re-renders:',
  'Now that roomId is not a reactive value (and can’t change on a re-render), it doesn’t need to be a dependency:',
  'This is why you could now specify an empty ([]) dependency list. Your Effect really doesn’t depend on any reactive value anymore, so it really doesn’t need to re-run when any of the component’s props or state change.',
  'You might have noticed a pattern in your workflow:',
  'The last part is important. If you want to change the dependencies, change the surrounding code first. You can think of the dependency list as a list of all the reactive values used by your Effect’s code. You don’t choose what to put on that list. The list describes your code. To change the dependency list, change the code.',
  'This might feel like solving an equation. You might start with a goal (for example, to remove a dependency), and you need to “find” the code matching that goal. Not everyone finds solving equations fun, and the same thing could be said about writing Effects! Luckily, there is a list of common recipes that you can try below.',
  'If you have an existing codebase, you might have some Effects that suppress the linter like this:',
  'When dependencies don’t match the code, there is a very high risk of introducing bugs. By suppressing the linter, you “lie” to React about the values your Effect depends on.',
  'Instead, use the techniques below.',
  'Suppressing the linter leads to very unintuitive bugs that are hard to find and fix. Here’s one example:',
  'Let’s say that you wanted to run the Effect “only on mount”. You’ve read that empty ([]) dependencies do that, so you’ve decided to ignore the linter, and forcefully specified [] as the dependencies.',
  'This counter was supposed to increment every second by the amount configurable with the two buttons. However, since you “lied” to React that this Effect doesn’t depend on anything, React forever keeps using the onTick function from the initial render. During that render, count was 0 and increment was 1. This is why onTick from that render always calls setCount(0 + 1) every second, and you always see 1. Bugs like this are harder to fix when they’re spread across multiple components.',
  'There’s always a better solution than ignoring the linter! To fix this code, you need to add onTick to the dependency list. (To ensure the interval is only setup once, make onTick an Effect Event.)',
  'We recommend treating the dependency lint error as a compilation error. If you don’t suppress it, you will never see bugs like this. The rest of this page documents the alternatives for this and other cases.',
  'Every time you adjust the Effect’s dependencies to reflect the code, look at the dependency list. Does it make sense for the Effect to re-run when any of these dependencies change? Sometimes, the answer is “no”:',
  'To find the right solution, you’ll need to answer a few questions about your Effect. Let’s walk through them.',
  'The first thing you should think about is whether this code should be an Effect at all.',
  'Imagine a form. On submit, you set the submitted state variable to true. You need to send a POST request and show a notification. You’ve put this logic inside an Effect that “reacts” to submitted being true:',
  'Later, you want to style the notification message according to the current theme, so you read the current theme. Since theme is declared in the component body, it is a reactive value, so you add it as a dependency:',
  'By doing this, you’ve introduced a bug. Imagine you submit the form first and then switch between Dark and Light themes. The theme will change, the Effect will re-run, and so it will display the same notification again!',
  'The problem here is that this shouldn’t be an Effect in the first place. You want to send this POST request and show the notification in response to submitting the form, which is a particular interaction. To run some code in response to particular interaction, put that logic directly into the corresponding event handler:',
  'Now that the code is in an event handler, it’s not reactive—so it will only run when the user submits the form. Read more about choosing between event handlers and Effects and how to delete unnecessary Effects.',
  'The next question you should ask yourself is whether your Effect is doing several unrelated things.',
  'Imagine you’re creating a shipping form where the user needs to choose their city and area. You fetch the list of cities from the server according to the selected country to show them in a dropdown:',
  'This is a good example of fetching data in an Effect. You are synchronizing the cities state with the network according to the country prop. You can’t do this in an event handler because you need to fetch as soon as ShippingForm is displayed and whenever the country changes (no matter which interaction causes it).',
  'Now let’s say you’re adding a second select box for city areas, which should fetch the areas for the currently selected city. You might start by adding a second fetch call for the list of areas inside the same Effect:',
  'However, since the Effect now uses the city state variable, you’ve had to add city to the list of dependencies. That, in turn, introduced a problem: when the user selects a different city, the Effect will re-run and call fetchCities(country). As a result, you will be unnecessarily refetching the list of cities many times.',
  'The problem with this code is that you’re synchronizing two different unrelated things:',
  'Split the logic into two Effects, each of which reacts to the prop that it needs to synchronize with:',
  'Now the first Effect only re-runs if the country changes, while the second Effect re-runs when the city changes. You’ve separated them by purpose: two different things are synchronized by two separate Effects. Two separate Effects have two separate dependency lists, so they won’t trigger each other unintentionally.',
  'The final code is longer than the original, but splitting these Effects is still correct. Each Effect should represent an independent synchronization process. In this example, deleting one Effect doesn’t break the other Effect’s logic. This means they synchronize different things, and it’s good to split them up. If you’re concerned about duplication, you can improve this code by extracting repetitive logic into a custom Hook.',
  'This Effect updates the messages state variable with a newly created array every time a new message arrives:',
  'It uses the messages variable to create a new array starting with all the existing messages and adds the new message at the end. However, since messages is a reactive value read by an Effect, it must be a dependency:',
  'And making messages a dependency introduces a problem.',
  'Every time you receive a message, setMessages() causes the component to re-render with a new messages array that includes the received message. However, since this Effect now depends on messages, this will also re-synchronize the Effect. So every new message will make the chat re-connect. The user would not like that!',
  'To fix the issue, don’t read messages inside the Effect. Instead, pass an updater function to setMessages:',
  'Notice how your Effect does not read the messages variable at all now. You only need to pass an updater function like msgs => [...msgs, receivedMessage]. React puts your updater function in a queue and will provide the msgs argument to it during the next render. This is why the Effect itself doesn’t need to depend on messages anymore. As a result of this fix, receiving a chat message will no longer make the chat re-connect.',
  'This section describes an experimental API that has not yet been released in a stable version of React.',
  'Suppose that you want to play a sound when the user receives a new message unless isMuted is true:',
  'Since your Effect now uses isMuted in its code, you have to add it to the dependencies:',
  'The problem is that every time isMuted changes (for example, when the user presses the “Muted” toggle), the Effect will re-synchronize, and reconnect to the chat. This is not the desired user experience! (In this example, even disabling the linter would not work—if you do that, isMuted would get “stuck” with its old value.)',
  'To solve this problem, you need to extract the logic that shouldn’t be reactive out of the Effect. You don’t want this Effect to “react” to the changes in isMuted. Move this non-reactive piece of logic into an Effect Event:',
  'Effect Events let you split an Effect into reactive parts (which should “react” to reactive values like roomId and their changes) and non-reactive parts (which only read their latest values, like onMessage reads isMuted). Now that you read isMuted inside an Effect Event, it doesn’t need to be a dependency of your Effect. As a result, the chat won’t re-connect when you toggle the “Muted” setting on and off, solving the original issue!',
  'You might run into a similar problem when your component receives an event handler as a prop:',
  'Suppose that the parent component passes a different onReceiveMessage function on every render:',
  'Since onReceiveMessage is a dependency, it would cause the Effect to re-synchronize after every parent re-render. This would make it re-connect to the chat. To solve this, wrap the call in an Effect Event:',
  'Effect Events aren’t reactive, so you don’t need to specify them as dependencies. As a result, the chat will no longer re-connect even if the parent component passes a function that’s different on every re-render.',
  'In this example, you want to log a visit every time roomId changes. You want to include the current notificationCount with every log, but you don’t want a change to notificationCount to trigger a log event.',
  'The solution is again to split out the non-reactive code into an Effect Event:',
  'You want your logic to be reactive with regards to roomId, so you read roomId inside of your Effect. However, you don’t want a change to notificationCount to log an extra visit, so you read notificationCount inside of the Effect Event. Learn more about reading the latest props and state from Effects using Effect Events.',
  'Sometimes, you do want your Effect to “react” to a certain value, but that value changes more often than you’d like—and might not reflect any actual change from the user’s perspective. For example, let’s say that you create an options object in the body of your component, and then read that object from inside of your Effect:',
  'This object is declared in the component body, so it’s a reactive value. When you read a reactive value like this inside an Effect, you declare it as a dependency. This ensures your Effect “reacts” to its changes:',
  'It is important to declare it as a dependency! This ensures, for example, that if the roomId changes, your Effect will re-connect to the chat with the new options. However, there is also a problem with the code above. To see it, try typing into the input in the sandbox below, and watch what happens in the console:',
  'In the sandbox above, the input only updates the message state variable. From the user’s perspective, this should not affect the chat connection. However, every time you update the message, your component re-renders. When your component re-renders, the code inside of it runs again from scratch.',
  'A new options object is created from scratch on every re-render of the ChatRoom component. React sees that the options object is a different object from the options object created during the last render. This is why it re-synchronizes your Effect (which depends on options), and the chat re-connects as you type.',
  'This problem only affects objects and functions. In JavaScript, each newly created object and function is considered distinct from all the others. It doesn’t matter that the contents inside of them may be the same!',
  'Object and function dependencies can make your Effect re-synchronize more often than you need.',
  'This is why, whenever possible, you should try to avoid objects and functions as your Effect’s dependencies. Instead, try moving them outside the component, inside the Effect, or extracting primitive values out of them.',
  'If the object does not depend on any props and state, you can move that object outside your component:',
  'This way, you prove to the linter that it’s not reactive. It can’t change as a result of a re-render, so it doesn’t need to be a dependency. Now re-rendering ChatRoom won’t cause your Effect to re-synchronize.',
  'This works for functions too:',
  'Since createOptions is declared outside your component, it’s not a reactive value. This is why it doesn’t need to be specified in your Effect’s dependencies, and why it won’t ever cause your Effect to re-synchronize.',
  'If your object depends on some reactive value that may change as a result of a re-render, like a roomId prop, you can’t pull it outside your component. You can, however, move its creation inside of your Effect’s code:',
  'Now that options is declared inside of your Effect, it is no longer a dependency of your Effect. Instead, the only reactive value used by your Effect is roomId. Since roomId is not an object or function, you can be sure that it won’t be unintentionally different. In JavaScript, numbers and strings are compared by their content:',
  'Thanks to this fix, the chat no longer re-connects if you edit the input:',
  'However, it does re-connect when you change the roomId dropdown, as you would expect.',
  'This works for functions, too:',
  'You can write your own functions to group pieces of logic inside your Effect. As long as you also declare them inside your Effect, they’re not reactive values, and so they don’t need to be dependencies of your Effect.',
  'Sometimes, you may receive an object from props:',
  'The risk here is that the parent component will create the object during rendering:',
  'This would cause your Effect to re-connect every time the parent component re-renders. To fix this, read information from the object outside the Effect, and avoid having object and function dependencies:',
  'The logic gets a little repetitive (you read some values from an object outside an Effect, and then create an object with the same values inside the Effect). But it makes it very explicit what information your Effect actually depends on. If an object is re-created unintentionally by the parent component, the chat would not re-connect. However, if options.roomId or options.serverUrl really are different, the chat would re-connect.',
  'The same approach can work for functions. For example, suppose the parent component passes a function:',
  'To avoid making it a dependency (and causing it to re-connect on re-renders), call it outside the Effect. This gives you the roomId and serverUrl values that aren’t objects, and that you can read from inside your Effect:',
  'This only works for pure functions because they are safe to call during rendering. If your function is an event handler, but you don’t want its changes to re-synchronize your Effect, wrap it into an Effect Event instead.',
  'This Effect sets up an interval that ticks every second. You’ve noticed something strange happening: it seems like the interval gets destroyed and re-created every time it ticks. Fix the code so that the interval doesn’t get constantly re-created.',
  'How do you like these docs?'
]
URL:  https://react.dev/learn/reusing-logic-with-custom-hooks
[
  'Is this page useful?',
  'React comes with several built-in Hooks like useState, useContext, and useEffect. Sometimes, you’ll wish that there was a Hook for some more specific purpose: for example, to fetch data, to keep track of whether the user is online, or to connect to a chat room. You might not find these Hooks in React, but you can create your own Hooks for your application’s needs.',
  'Imagine you’re developing an app that heavily relies on the network (as most apps do). You want to warn the user if their network connection has accidentally gone off while they were using your app. How would you go about it? It seems like you’ll need two things in your component:',
  'This will keep your component synchronized with the network status. You might start with something like this:',
  'Try turning your network on and off, and notice how this StatusBar updates in response to your actions.',
  'Now imagine you also want to use the same logic in a different component. You want to implement a Save button that will become disabled and show “Reconnecting…” instead of “Save” while the network is off.',
  'To start, you can copy and paste the isOnline state and the Effect into SaveButton:',
  'Verify that, if you turn off the network, the button will change its appearance.',
  'These two components work fine, but the duplication in logic between them is unfortunate. It seems like even though they have different visual appearance, you want to reuse the logic between them.',
  'Imagine for a moment that, similar to useState and useEffect, there was a built-in useOnlineStatus Hook. Then both of these components could be simplified and you could remove the duplication between them:',
  'Although there is no such built-in Hook, you can write it yourself. Declare a function called useOnlineStatus and move all the duplicated code into it from the components you wrote earlier:',
  'At the end of the function, return isOnline. This lets your components read that value:',
  'Verify that switching the network on and off updates both components.',
  'Now your components don’t have as much repetitive logic. More importantly, the code inside them describes what they want to do (use the online status!) rather than how to do it (by subscribing to the browser events).',
  'When you extract logic into custom Hooks, you can hide the gnarly details of how you deal with some external system or a browser API. The code of your components expresses your intent, not the implementation.',
  'React applications are built from components. Components are built from Hooks, whether built-in or custom. You’ll likely often use custom Hooks created by others, but occasionally you might write one yourself!',
  'You must follow these naming conventions:',
  'This convention guarantees that you can always look at a component and know where its state, Effects, and other React features might “hide”. For example, if you see a getColor() function call inside your component, you can be sure that it can’t possibly contain React state inside because its name doesn’t start with use. However, a function call like useOnlineStatus() will most likely contain calls to other Hooks inside!',
  'If your linter is configured for React, it will enforce this naming convention. Scroll up to the sandbox above and rename useOnlineStatus to getOnlineStatus. Notice that the linter won’t allow you to call useState or useEffect inside of it anymore. Only Hooks and components can call other Hooks!',
  'No. Functions that don’t call Hooks don’t need to be Hooks.',
  'If your function doesn’t call any Hooks, avoid the use prefix. Instead, write it as a regular function without the use prefix. For example, useSorted below doesn’t call Hooks, so call it getSorted instead:',
  'This ensures that your code can call this regular function anywhere, including conditions:',
  'You should give use prefix to a function (and thus make it a Hook) if it uses at least one Hook inside of it:',
  'Technically, this isn’t enforced by React. In principle, you could make a Hook that doesn’t call other Hooks. This is often confusing and limiting so it’s best to avoid that pattern. However, there may be rare cases where it is helpful. For example, maybe your function doesn’t use any Hooks right now, but you plan to add some Hook calls to it in the future. Then it makes sense to name it with the use prefix:',
  'Then components won’t be able to call it conditionally. This will become important when you actually add Hook calls inside. If you don’t plan to use Hooks inside it (now or later), don’t make it a Hook.',
  'In the earlier example, when you turned the network on and off, both components updated together. However, it’s wrong to think that a single isOnline state variable is shared between them. Look at this code:',
  'It works the same way as before you extracted the duplication:',
  'These are two completely independent state variables and Effects! They happened to have the same value at the same time because you synchronized them with the same external value (whether the network is on).',
  'To better illustrate this, we’ll need a different example. Consider this Form component:',
  'There’s some repetitive logic for each form field:',
  'You can extract the repetitive logic into this useFormInput custom Hook:',
  'Notice that it only declares one state variable called value.',
  'However, the Form component calls useFormInput two times:',
  'This is why it works like declaring two separate state variables!',
  'Custom Hooks let you share stateful logic but not state itself. Each call to a Hook is completely independent from every other call to the same Hook. This is why the two sandboxes above are completely equivalent. If you’d like, scroll back up and compare them. The behavior before and after extracting a custom Hook is identical.',
  'When you need to share the state itself between multiple components, lift it up and pass it down instead.',
  'The code inside your custom Hooks will re-run during every re-render of your component. This is why, like components, custom Hooks need to be pure. Think of custom Hooks’ code as part of your component’s body!',
  'Because custom Hooks re-render together with your component, they always receive the latest props and state. To see what this means, consider this chat room example. Change the server URL or the chat room:',
  'When you change serverUrl or roomId, the Effect “reacts” to your changes and re-synchronizes. You can tell by the console messages that the chat re-connects every time that you change your Effect’s dependencies.',
  'Now move the Effect’s code into a custom Hook:',
  'This lets your ChatRoom component call your custom Hook without worrying about how it works inside:',
  'This looks much simpler! (But it does the same thing.)',
  'Notice that the logic still responds to prop and state changes. Try editing the server URL or the selected room:',
  'Notice how you’re taking the return value of one Hook:',
  'and pass it as an input to another Hook:',
  'Every time your ChatRoom component re-renders, it passes the latest roomId and serverUrl to your Hook. This is why your Effect re-connects to the chat whenever their values are different after a re-render. (If you ever worked with audio or video processing software, chaining Hooks like this might remind you of chaining visual or audio effects. It’s as if the output of useState “feeds into” the input of the useChatRoom.)',
  'This section describes an experimental API that has not yet been released in a stable version of React.',
  'As you start using useChatRoom in more components, you might want to let components customize its behavior. For example, currently, the logic for what to do when a message arrives is hardcoded inside the Hook:',
  'Let’s say you want to move this logic back to your component:',
  'To make this work, change your custom Hook to take onReceiveMessage as one of its named options:',
  'This will work, but there’s one more improvement you can do when your custom Hook accepts event handlers.',
  'Adding a dependency on onReceiveMessage is not ideal because it will cause the chat to re-connect every time the component re-renders. Wrap this event handler into an Effect Event to remove it from the dependencies:',
  'Now the chat won’t re-connect every time that the ChatRoom component re-renders. Here is a fully working demo of passing an event handler to a custom Hook that you can play with:',
  'Notice how you no longer need to know how useChatRoom works in order to use it. You could add it to any other component, pass any other options, and it would work the same way. That’s the power of custom Hooks.',
  'You don’t need to extract a custom Hook for every little duplicated bit of code. Some duplication is fine. For example, extracting a useFormInput Hook to wrap a single useState call like earlier is probably unnecessary.',
  'However, whenever you write an Effect, consider whether it would be clearer to also wrap it in a custom Hook. You shouldn’t need Effects very often, so if you’re writing one, it means that you need to “step outside React” to synchronize with some external system or to do something that React doesn’t have a built-in API for. Wrapping it into a custom Hook lets you precisely communicate your intent and how the data flows through it.',
  'For example, consider a ShippingForm component that displays two dropdowns: one shows the list of cities, and another shows the list of areas in the selected city. You might start with some code that looks like this:',
  'Although this code is quite repetitive, it’s correct to keep these Effects separate from each other. They synchronize two different things, so you shouldn’t merge them into one Effect. Instead, you can simplify the ShippingForm component above by extracting the common logic between them into your own useData Hook:',
  'Now you can replace both Effects in the ShippingForm components with calls to useData:',
  'Extracting a custom Hook makes the data flow explicit. You feed the url in and you get the data out. By “hiding” your Effect inside useData, you also prevent someone working on the ShippingForm component from adding unnecessary dependencies to it. With time, most of your app’s Effects will be in custom Hooks.',
  'Start by choosing your custom Hook’s name. If you struggle to pick a clear name, it might mean that your Effect is too coupled to the rest of your component’s logic, and is not yet ready to be extracted.',
  'Ideally, your custom Hook’s name should be clear enough that even a person who doesn’t write code often could have a good guess about what your custom Hook does, what it takes, and what it returns:',
  'When you synchronize with an external system, your custom Hook name may be more technical and use jargon specific to that system. It’s good as long as it would be clear to a person familiar with that system:',
  'Keep custom Hooks focused on concrete high-level use cases. Avoid creating and using custom “lifecycle” Hooks that act as alternatives and convenience wrappers for the useEffect API itself:',
  'For example, this useMount Hook tries to ensure some code only runs “on mount”:',
  'Custom “lifecycle” Hooks like useMount don’t fit well into the React paradigm. For example, this code example has a mistake (it doesn’t “react” to roomId or serverUrl changes), but the linter won’t warn you about it because the linter only checks direct useEffect calls. It won’t know about your Hook.',
  'If you’re writing an Effect, start by using the React API directly:',
  'Then, you can (but don’t have to) extract custom Hooks for different high-level use cases:',
  'A good custom Hook makes the calling code more declarative by constraining what it does. For example, useChatRoom(options) can only connect to the chat room, while useImpressionLog(eventName, extraData) can only send an impression log to the analytics. If your custom Hook API doesn’t constrain the use cases and is very abstract, in the long run it’s likely to introduce more problems than it solves.',
  'Effects are an “escape hatch”: you use them when you need to “step outside React” and when there is no better built-in solution for your use case. With time, the React team’s goal is to reduce the number of the Effects in your app to the minimum by providing more specific solutions to more specific problems. Wrapping your Effects in custom Hooks makes it easier to upgrade your code when these solutions become available.',
  'Let’s return to this example:',
  'In the above example, useOnlineStatus is implemented with a pair of useState and useEffect. However, this isn’t the best possible solution. There is a number of edge cases it doesn’t consider. For example, it assumes that when the component mounts, isOnline is already true, but this may be wrong if the network already went offline. You can use the browser navigator.onLine API to check for that, but using it directly would not work on the server for generating the initial HTML. In short, this code could be improved.',
  'Luckily, React 18 includes a dedicated API called useSyncExternalStore which takes care of all of these problems for you. Here is how your useOnlineStatus Hook, rewritten to take advantage of this new API:',
  'Notice how you didn’t need to change any of the components to make this migration:',
  'This is another reason for why wrapping Effects in custom Hooks is often beneficial:',
  'Similar to a design system, you might find it helpful to start extracting common idioms from your app’s components into custom Hooks. This will keep your components’ code focused on the intent, and let you avoid writing raw Effects very often. Many excellent custom Hooks are maintained by the React community.',
  'We’re still working out the details, but we expect that in the future, you’ll write data fetching like this:',
  'If you use custom Hooks like useData above in your app, it will require fewer changes to migrate to the eventually recommended approach than if you write raw Effects in every component manually. However, the old approach will still work fine, so if you feel happy writing raw Effects, you can continue to do that.',
  'Let’s say you want to implement a fade-in animation from scratch using the browser requestAnimationFrame API. You might start with an Effect that sets up an animation loop. During each frame of the animation, you could change the opacity of the DOM node you hold in a ref until it reaches 1. Your code might start like this:',
  'To make the component more readable, you might extract the logic into a useFadeIn custom Hook:',
  'You could keep the useFadeIn code as is, but you could also refactor it more. For example, you could extract the logic for setting up the animation loop out of useFadeIn into a custom useAnimationLoop Hook:',
  'However, you didn’t have to do that. As with regular functions, ultimately you decide where to draw the boundaries between different parts of your code. You could also take a very different approach. Instead of keeping the logic in the Effect, you could move most of the imperative logic inside a JavaScript class:',
  'Effects let you connect React to external systems. The more coordination between Effects is needed (for example, to chain multiple animations), the more it makes sense to extract that logic out of Effects and Hooks completely like in the sandbox above. Then, the code you extracted becomes the “external system”. This lets your Effects stay simple because they only need to send messages to the system you’ve moved outside React.',
  'The examples above assume that the fade-in logic needs to be written in JavaScript. However, this particular fade-in animation is both simpler and much more efficient to implement with a plain CSS Animation:',
  'Sometimes, you don’t even need a Hook!',
  'This component uses a state variable and an Effect to display a number that increments every second. Extract this logic into a custom Hook called useCounter. Your goal is to make the Counter component implementation look exactly like this:',
  'You’ll need to write your custom Hook in useCounter.js and import it into the Counter.js file.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react/useState
[
  'Is this page useful?',
  'useState is a React Hook that lets you add a state variable to your component.',
  'Call useState at the top level of your component to declare a state variable.',
  'The convention is to name state variables like [something, setSomething] using array destructuring.',
  'See more examples below.',
  'useState returns an array with exactly two values:',
  'The set function returned by useState lets you update the state to a different value and trigger a re-render. You can pass the next state directly, or a function that calculates it from the previous state:',
  'set functions do not have a return value.',
  'The set function only updates the state variable for the next render. If you read the state variable after calling the set function, you will still get the old value that was on the screen before your call.',
  'If the new value you provide is identical to the current state, as determined by an Object.is comparison, React will skip re-rendering the component and its children. This is an optimization. Although in some cases React may still need to call your component before skipping the children, it shouldn’t affect your code.',
  'React batches state updates. It updates the screen after all the event handlers have run and have called their set functions. This prevents multiple re-renders during a single event. In the rare case that you need to force React to update the screen earlier, for example to access the DOM, you can use flushSync.',
  'Calling the set function during rendering is only allowed from within the currently rendering component. React will discard its output and immediately attempt to render it again with the new state. This pattern is rarely needed, but you can use it to store information from the previous renders. See an example below.',
  'In Strict Mode, React will call your updater function twice in order to help you find accidental impurities. This is development-only behavior and does not affect production. If your updater function is pure (as it should be), this should not affect the behavior. The result from one of the calls will be ignored.',
  'Call useState at the top level of your component to declare one or more state variables.',
  'The convention is to name state variables like [something, setSomething] using array destructuring.',
  'useState returns an array with exactly two items:',
  'To update what’s on the screen, call the set function with some next state:',
  'React will store the next state, render your component again with the new values, and update the UI.',
  'Calling the set function does not change the current state in the already executing code:',
  'It only affects what useState will return starting from the next render.',
  'In this example, the count state variable holds a number. Clicking the button increments it.',
  'Suppose the age is 42. This handler calls setAge(age + 1) three times:',
  'However, after one click, age will only be 43 rather than 45! This is because calling the set function does not update the age state variable in the already running code. So each setAge(age + 1) call becomes setAge(43).',
  'To solve this problem, you may pass an updater function to setAge instead of the next state:',
  'Here, a => a + 1 is your updater function. It takes the pending state and calculates the next state from it.',
  'React puts your updater functions in a queue. Then, during the next render, it will call them in the same order:',
  'There are no other queued updates, so React will store 45 as the current state in the end.',
  'By convention, it’s common to name the pending state argument for the first letter of the state variable name, like a for age. However, you may also call it like prevAge or something else that you find clearer.',
  'React may call your updaters twice in development to verify that they are pure.',
  'You might hear a recommendation to always write code like setAge(a => a + 1) if the state you’re setting is calculated from the previous state. There is no harm in it, but it is also not always necessary.',
  'In most cases, there is no difference between these two approaches. React always makes sure that for intentional user actions, like clicks, the age state variable would be updated before the next click. This means there is no risk of a click handler seeing a “stale” age at the beginning of the event handler.',
  'However, if you do multiple updates within the same event, updaters can be helpful. They’re also helpful if accessing the state variable itself is inconvenient (you might run into this when optimizing re-renders).',
  'If you prefer consistency over slightly more verbose syntax, it’s reasonable to always write an updater if the state you’re setting is calculated from the previous state. If it’s calculated from the previous state of some other state variable, you might want to combine them into one object and use a reducer.',
  'This example passes the updater function, so the “+3” button works.',
  'You can put objects and arrays into state. In React, state is considered read-only, so you should replace it rather than mutate your existing objects. For example, if you have a form object in state, don’t mutate it:',
  'Instead, replace the whole object by creating a new one:',
  'Read updating objects in state and updating arrays in state to learn more.',
  'In this example, the form state variable holds an object. Each input has a change handler that calls setForm with the next state of the entire form. The { ...form } spread syntax ensures that the state object is replaced rather than mutated.',
  'React saves the initial state once and ignores it on the next renders.',
  'Although the result of createInitialTodos() is only used for the initial render, you’re still calling this function on every render. This can be wasteful if it’s creating large arrays or performing expensive calculations.',
  'To solve this, you may pass it as an initializer function to useState instead:',
  'Notice that you’re passing createInitialTodos, which is the function itself, and not createInitialTodos(), which is the result of calling it. If you pass a function to useState, React will only call it during initialization.',
  'React may call your initializers twice in development to verify that they are pure.',
  'This example passes the initializer function, so the createInitialTodos function only runs during initialization. It does not run when component re-renders, such as when you type into the input.',
  'You’ll often encounter the key attribute when rendering lists. However, it also serves another purpose.',
  'You can reset a component’s state by passing a different key to a component. In this example, the Reset button changes the version state variable, which we pass as a key to the Form. When the key changes, React re-creates the Form component (and all of its children) from scratch, so its state gets reset.',
  'Read preserving and resetting state to learn more.',
  'Usually, you will update state in event handlers. However, in rare cases you might want to adjust state in response to rendering — for example, you might want to change a state variable when a prop changes.',
  'In most cases, you don’t need this:',
  'In the rare case that none of these apply, there is a pattern you can use to update state based on the values that have been rendered so far, by calling a set function while your component is rendering.',
  'Here’s an example. This CountLabel component displays the count prop passed to it:',
  'Say you want to show whether the counter has increased or decreased since the last change. The count prop doesn’t tell you this — you need to keep track of its previous value. Add the prevCount state variable to track it. Add another state variable called trend to hold whether the count has increased or decreased. Compare prevCount with count, and if they’re not equal, update both prevCount and trend. Now you can show both the current count prop and how it has changed since the last render.',
  'Note that if you call a set function while rendering, it must be inside a condition like prevCount !== count, and there must be a call like setPrevCount(count) inside of the condition. Otherwise, your component would re-render in a loop until it crashes. Also, you can only update the state of the currently rendering component like this. Calling the set function of another component during rendering is an error. Finally, your set call should still update state without mutation — this doesn’t mean you can break other rules of pure functions.',
  'This pattern can be hard to understand and is usually best avoided. However, it’s better than updating state in an effect. When you call the set function during render, React will re-render that component immediately after your component exits with a return statement, and before rendering the children. This way, children don’t need to render twice. The rest of your component function will still execute (and the result will be thrown away). If your condition is below all the Hook calls, you may add an early return; to restart rendering earlier.',
  'Calling the set function does not change state in the running code:',
  'This is because states behaves like a snapshot. Updating state requests another render with the new state value, but does not affect the count JavaScript variable in your already-running event handler.',
  'If you need to use the next state, you can save it in a variable before passing it to the set function:',
  'React will ignore your update if the next state is equal to the previous state, as determined by an Object.is comparison. This usually happens when you change an object or an array in state directly:',
  'You mutated an existing obj object and passed it back to setObj, so React ignored the update. To fix this, you need to ensure that you’re always replacing objects and arrays in state instead of mutating them:',
  'You might get an error that says: Too many re-renders. React limits the number of renders to prevent an infinite loop. Typically, this means that you’re unconditionally setting state during render, so your component enters a loop: render, set state (which causes a render), render, set state (which causes a render), and so on. Very often, this is caused by a mistake in specifying an event handler:',
  'If you can’t find the cause of this error, click on the arrow next to the error in the console and look through the JavaScript stack to find the specific set function call responsible for the error.',
  'In Strict Mode, React will call some of your functions twice instead of once:',
  'This is expected and shouldn’t break your code.',
  'This development-only behavior helps you keep components pure. React uses the result of one of the calls, and ignores the result of the other call. As long as your component, initializer, and updater functions are pure, this shouldn’t affect your logic. However, if they are accidentally impure, this helps you notice the mistakes.',
  'For example, this impure updater function mutates an array in state:',
  'Because React calls your updater function twice, you’ll see the todo was added twice, so you’ll know that there is a mistake. In this example, you can fix the mistake by replacing the array instead of mutating it:',
  'Now that this updater function is pure, calling it an extra time doesn’t make a difference in behavior. This is why React calling it twice helps you find mistakes. Only component, initializer, and updater functions need to be pure. Event handlers don’t need to be pure, so React will never call your event handlers twice.',
  'Read keeping components pure to learn more.',
  'You can’t put a function into state like this:',
  'Because you’re passing a function, React assumes that someFunction is an initializer function, and that someOtherFunction is an updater function, so it tries to call them and store the result. To actually store a function, you have to put () => before them in both cases. Then React will store the functions you pass.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react/hooks
[
  'Is this page useful?',
  'Hooks let you use different React features from your components. You can either use the built-in Hooks or combine them to build your own. This page lists all built-in Hooks in React.',
  'State lets a component “remember” information like user input. For example, a form component can use state to store the input value, while an image gallery component can use state to store the selected image index.',
  'To add state to a component, use one of these Hooks:',
  'Context lets a component receive information from distant parents without passing it as props. For example, your app’s top-level component can pass the current UI theme to all components below, no matter how deep.',
  'Refs let a component hold some information that isn’t used for rendering, like a DOM node or a timeout ID. Unlike with state, updating a ref does not re-render your component. Refs are an “escape hatch” from the React paradigm. They are useful when you need to work with non-React systems, such as the built-in browser APIs.',
  'Effects let a component connect to and synchronize with external systems. This includes dealing with network, browser DOM, animations, widgets written using a different UI library, and other non-React code.',
  'Effects are an “escape hatch” from the React paradigm. Don’t use Effects to orchestrate the data flow of your application. If you’re not interacting with an external system, you might not need an Effect.',
  'There are two rarely used variations of useEffect with differences in timing:',
  'A common way to optimize re-rendering performance is to skip unnecessary work. For example, you can tell React to reuse a cached calculation or to skip a re-render if the data has not changed since the previous render.',
  'To skip calculations and unnecessary re-rendering, use one of these Hooks:',
  'Sometimes, you can’t skip re-rendering because the screen actually needs to update. In that case, you can improve performance by separating blocking updates that must be synchronous (like typing into an input) from non-blocking updates which don’t need to block the user interface (like updating a chart).',
  'To prioritize rendering, use one of these Hooks:',
  'Resources can be accessed by a component without having them as part of their state. For example, a component can read a message from a Promise or read styling information from a context.',
  'To read a value from a resource, use this Hook:',
  'These Hooks are mostly useful to library authors and aren’t commonly used in the application code.',
  'You can also define your own custom Hooks as JavaScript functions.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react/use
[
  'Is this page useful?',
  'The use Hook is currently only available in React’s Canary and experimental channels. Learn more about React’s release channels here.',
  'use is a React Hook that lets you read the value of a resource like a Promise or context.',
  'Call use in your component to read the value of a resource like a Promise or context.',
  'Unlike all other React Hooks, use can be called within loops and conditional statements like if. Like other React Hooks, the function that calls use must be a Component or Hook.',
  'When called with a Promise, the use Hook integrates with Suspense and error boundaries. The component calling use suspends while the Promise passed to use is pending. If the component that calls use is wrapped in a Suspense boundary, the fallback will be displayed.  Once the Promise is resolved, the Suspense fallback is replaced by the rendered components using the data returned by the use Hook. If the Promise passed to use is rejected, the fallback of the nearest Error Boundary will be displayed.',
  'See more examples below.',
  'The use Hook returns the value that was read from the resource like the resolved value of a Promise or context.',
  'When a context is passed to use, it works similarly to useContext. While useContext must be called at the top level of your component, use can be called inside conditionals like if and loops like for. use is preferred over useContext because it is more flexible.',
  'use returns the context value for the context you passed. To determine the context value, React searches the component tree and finds the closest context provider above for that particular context.',
  'To pass context to a Button, wrap it or one of its parent components into the corresponding context provider.',
  'It doesn’t matter how many layers of components there are between the provider and the Button. When a Button anywhere inside of Form calls use(ThemeContext), it will receive "dark" as the value.',
  'Unlike useContext, use can be called in conditionals and loops like if.',
  'use is called from inside a if statement, allowing you to conditionally read values from a Context.',
  'Like useContext, use(context) always looks for the closest context provider above the component that calls it. It searches upwards and does not consider context providers in the component from which you’re calling use(context).',
  'Data can be streamed from the server to the client by passing a Promise as a prop from a Server Component to a Client Component.',
  'The Client Component then takes the Promise it received as a prop and passes it to the use Hook. This allows the Client Component to read the value from the Promise that was initially created by the Server Component.',
  'Because Message is wrapped in Suspense, the fallback will be displayed until the Promise is resolved. When the Promise is resolved, the value will be read by the use Hook and the Message component will replace the Suspense fallback.',
  'When passing a Promise from a Server Component to a Client Component, its resolved value must be serializable to pass between server and client. Data types like functions aren’t serializable and cannot be the resolved value of such a Promise.',
  'A Promise can be passed from a Server Component to a Client Component and resolved in the Client Component with the use Hook. You can also resolve the Promise in a Server Component with await and pass the required data to the Client Component as a prop.',
  'But using await in a Server Component will block its rendering until the await statement is finished. Passing a Promise from a Server Component to a Client Component prevents the Promise from blocking the rendering of the Server Component.',
  'In some cases a Promise passed to use could be rejected. You can handle rejected Promises by either:',
  'use cannot be called in a try-catch block. Instead of a try-catch block wrap your component in an Error Boundary, or provide an alternative value to use with the Promise’s .catch method.',
  'If you’d like to display an error to your users when a Promise is rejected, you can use an error boundary. To use an error boundary, wrap the component where you are calling the use Hook in an error boundary. If the Promise passed to use is rejected the fallback for the error boundary will be displayed.',
  'If you’d like to provide an alternative value when the Promise passed to use is rejected you can use the Promise’s catch method.',
  'To use the Promise’s catch method, call catch on the Promise object. catch takes a single argument: a function that takes an error message as an argument. Whatever is returned by the function passed to catch will be used as the resolved value of the Promise.',
  'You are either calling use outside of a React component or Hook function, or calling use in a try–catch block. If you are calling use inside a try–catch block, wrap your component in an error boundary, or call the Promise’s catch to catch the error and resolve the Promise with another value. See these examples.',
  'If you are calling use outside a React component or Hook function, move the use call to a React component or Hook function.',
  'Instead, call use outside any component closures, where the function that calls use is a component or Hook.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react/useCallback
[
  'Is this page useful?',
  'useCallback is a React Hook that lets you cache a function definition between re-renders.',
  'Call useCallback at the top level of your component to cache a function definition between re-renders:',
  'See more examples below.',
  'fn: The function value that you want to cache. It can take any arguments and return any values. React will return (not call!) your function back to you during the initial render. On next renders, React will give you the same function again if the dependencies have not changed since the last render. Otherwise, it will give you the function that you have passed during the current render, and store it in case it can be reused later. React will not call your function. The function is returned to you so you can decide when and whether to call it.',
  'dependencies: The list of all reactive values referenced inside of the fn code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like [dep1, dep2, dep3]. React will compare each dependency with its previous value using the Object.is comparison algorithm.',
  'On the initial render, useCallback returns the fn function you have passed.',
  'During subsequent renders, it will either return an already stored fn  function from the last render (if the dependencies haven’t changed), or return the fn function you have passed during this render.',
  'When you optimize rendering performance, you will sometimes need to cache the functions that you pass to child components. Let’s first look at the syntax for how to do this, and then see in which cases it’s useful.',
  'To cache a function between re-renders of your component, wrap its definition into the useCallback Hook:',
  'You need to pass two things to useCallback:',
  'On the initial render, the returned function you’ll get from useCallback will be the function you passed.',
  'On the following renders, React will compare the dependencies with the dependencies you passed during the previous render. If none of the dependencies have changed (compared with Object.is), useCallback will return the same function as before. Otherwise, useCallback will return the function you passed on this render.',
  'In other words, useCallback caches a function between re-renders until its dependencies change.',
  'Let’s walk through an example to see when this is useful.',
  'Say you’re passing a handleSubmit function down from the ProductPage to the ShippingForm component:',
  'You’ve noticed that toggling the theme prop freezes the app for a moment, but if you remove <ShippingForm /> from your JSX, it feels fast. This tells you that it’s worth trying to optimize the ShippingForm component.',
  'By default, when a component re-renders, React re-renders all of its children recursively. This is why, when ProductPage re-renders with a different theme, the ShippingForm component also re-renders. This is fine for components that don’t require much calculation to re-render. But if you verified a re-render is slow, you can tell ShippingForm to skip re-rendering when its props are the same as on last render by wrapping it in memo:',
  'With this change, ShippingForm will skip re-rendering if all of its props are the same as on the last render. This is when caching a function becomes important! Let’s say you defined handleSubmit without useCallback:',
  'In JavaScript, a function () {} or () => {} always creates a different function, similar to how the {} object literal always creates a new object. Normally, this wouldn’t be a problem, but it means that ShippingForm props will never be the same, and your memo optimization won’t work. This is where useCallback comes in handy:',
  'By wrapping handleSubmit in useCallback, you ensure that it’s the same function between the re-renders (until dependencies change). You don’t have to wrap a function in useCallback unless you do it for some specific reason. In this example, the reason is that you pass it to a component wrapped in memo, and this lets it skip re-rendering. There are other reasons you might need useCallback which are described further on this page.',
  'You should only rely on useCallback as a performance optimization. If your code doesn’t work without it, find the underlying problem and fix it first. Then you may add useCallback back.',
  'You will often see useMemo alongside useCallback. They are both useful when you’re trying to optimize a child component. They let you memoize (or, in other words, cache) something you’re passing down:',
  'The difference is in what they’re letting you cache:',
  'If you’re already familiar with useMemo, you might find it helpful to think of useCallback as this:',
  'Read more about the difference between useMemo and useCallback.',
  'If your app is like this site, and most interactions are coarse (like replacing a page or an entire section), memoization is usually unnecessary. On the other hand, if your app is more like a drawing editor, and most interactions are granular (like moving shapes), then you might find memoization very helpful.',
  'Caching a function with useCallback  is only valuable in a few cases:',
  'There is no benefit to wrapping a function in useCallback in other cases. There is no significant harm to doing that either, so some teams choose to not think about individual cases, and memoize as much as possible. The downside is that code becomes less readable. Also, not all memoization is effective: a single value that’s “always new” is enough to break memoization for an entire component.',
  'Note that useCallback does not prevent creating the function. You’re always creating a function (and that’s fine!), but React ignores it and gives you back a cached function if nothing changed.',
  'In practice, you can make a lot of memoization unnecessary by following a few principles:',
  'If a specific interaction still feels laggy, use the React Developer Tools profiler to see which components benefit the most from memoization, and add memoization where needed. These principles make your components easier to debug and understand, so it’s good to follow them in any case. In long term, we’re researching doing memoization automatically to solve this once and for all.',
  'In this example, the ShippingForm component is artificially slowed down so that you can see what happens when a React component you’re rendering is genuinely slow. Try incrementing the counter and toggling the theme.',
  'Incrementing the counter feels slow because it forces the slowed down ShippingForm to re-render. That’s expected because the counter has changed, and so you need to reflect the user’s new choice on the screen.',
  'Next, try toggling the theme. Thanks to useCallback together with memo, it’s fast despite the artificial slowdown! ShippingForm skipped re-rendering because the handleSubmit function has not changed. The handleSubmit function has not changed because both productId and referrer (your useCallback dependencies) haven’t changed since last render.',
  'Sometimes, you might need to update state based on previous state from a memoized callback.',
  'This handleAddTodo function specifies todos as a dependency because it computes the next todos from it:',
  'You’ll usually want memoized functions to have as few dependencies as possible. When you read some state only to calculate the next state, you can remove that dependency by passing an updater function instead:',
  'Here, instead of making todos a dependency and reading it inside, you pass an instruction about how to update the state (todos => [...todos, newTodo]) to React. Read more about updater functions.',
  'Sometimes, you might want to call a function from inside an Effect:',
  'This creates a problem. Every reactive value must be declared as a dependency of your Effect. However, if you declare createOptions as a dependency, it will cause your Effect to constantly reconnect to the chat room:',
  'To solve this, you can wrap the function you need to call from an Effect into useCallback:',
  'This ensures that the createOptions function is the same between re-renders if the roomId is the same. However, it’s even better to remove the need for a function dependency. Move your function inside the Effect:',
  'Now your code is simpler and doesn’t need useCallback. Learn more about removing Effect dependencies.',
  'If you’re writing a custom Hook, it’s recommended to wrap any functions that it returns into useCallback:',
  'This ensures that the consumers of your Hook can optimize their own code when needed.',
  'Make sure you’ve specified the dependency array as a second argument!',
  'If you forget the dependency array, useCallback will return a new function every time:',
  'This is the corrected version passing the dependency array as a second argument:',
  'If this doesn’t help, then the problem is that at least one of your dependencies is different from the previous render. You can debug this problem by manually logging your dependencies to the console:',
  'You can then right-click on the arrays from different re-renders in the console and select “Store as a global variable” for both of them. Assuming the first one got saved as temp1 and the second one got saved as temp2, you can then use the browser console to check whether each dependency in both arrays is the same:',
  'When you find which dependency is breaking memoization, either find a way to remove it, or memoize it as well.',
  'Suppose the Chart component is wrapped in memo. You want to skip re-rendering every Chart in the list when the ReportList component re-renders. However, you can’t call useCallback in a loop:',
  'Instead, extract a component for an individual item, and put useCallback there:',
  'Alternatively, you could remove useCallback in the last snippet and instead wrap Report itself in memo. If the item prop does not change, Report will skip re-rendering, so Chart will skip re-rendering too:',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react/useContext
[
  'Is this page useful?',
  'useContext is a React Hook that lets you read and subscribe to context from your component.',
  'Call useContext at the top level of your component to read and subscribe to context.',
  'See more examples below.',
  'useContext returns the context value for the calling component. It is determined as the value passed to the closest SomeContext.Provider above the calling component in the tree. If there is no such provider, then the returned value will be the defaultValue you have passed to createContext for that context. The returned value is always up-to-date. React automatically re-renders components that read some context if it changes.',
  'Call useContext at the top level of your component to read and subscribe to context.',
  'useContext returns the context value for the context you passed. To determine the context value, React searches the component tree and finds the closest context provider above for that particular context.',
  'To pass context to a Button, wrap it or one of its parent components into the corresponding context provider:',
  'It doesn’t matter how many layers of components there are between the provider and the Button. When a Button anywhere inside of Form calls useContext(ThemeContext), it will receive "dark" as the value.',
  'useContext() always looks for the closest provider above the component that calls it. It searches upwards and does not consider providers in the component from which you’re calling useContext().',
  'Often, you’ll want the context to change over time. To update context, combine it with state. Declare a state variable in the parent component, and pass the current state down as the context value to the provider.',
  "Now any Button inside of the provider will receive the current theme value. If you call setTheme to update the theme value that you pass to the provider, all Button components will re-render with the new 'light' value.",
  'In this example, the MyApp component holds a state variable which is then passed to the ThemeContext provider. Checking the “Dark mode” checkbox updates the state. Changing the provided value re-renders all the components using that context.',
  'Note that value="dark" passes the "dark" string, but value={theme} passes the value of the JavaScript theme variable with JSX curly braces. Curly braces also let you pass context values that aren’t strings.',
  'If React can’t find any providers of that particular context in the parent tree, the context value returned by useContext() will be equal to the default value that you specified when you created that context:',
  'The default value never changes. If you want to update context, use it with state as described above.',
  'Often, instead of null, there is some more meaningful value you can use as a default, for example:',
  'This way, if you accidentally render some component without a corresponding provider, it won’t break. This also helps your components work well in a test environment without setting up a lot of providers in the tests.',
  "In the example below, the “Toggle theme” button is always light because it’s outside any theme context provider and the default context theme value is 'light'. Try editing the default theme to be 'dark'.",
  'You can override the context for a part of the tree by wrapping that part in a provider with a different value.',
  'You can nest and override providers as many times as you need.',
  'Here, the button inside the Footer receives a different context value ("light") than the buttons outside ("dark").',
  'You can pass any values via context, including objects and functions.',
  'Here, the context value is a JavaScript object with two properties, one of which is a function. Whenever MyApp re-renders (for example, on a route update), this will be a different object pointing at a different function, so React will also have to re-render all components deep in the tree that call useContext(AuthContext).',
  'In smaller apps, this is not a problem. However, there is no need to re-render them if the underlying data, like currentUser, has not changed. To help React take advantage of that fact, you may wrap the login function with useCallback and wrap the object creation into useMemo. This is a performance optimization:',
  'As a result of this change, even if MyApp needs to re-render, the components calling useContext(AuthContext) won’t need to re-render unless currentUser has changed.',
  'Read more about useMemo and useCallback.',
  'There are a few common ways that this can happen:',
  'You might have a provider without a value in the tree:',
  'If you forget to specify value, it’s like passing value={undefined}.',
  'You may have also mistakingly used a different prop name by mistake:',
  'In both of these cases you should see a warning from React in the console. To fix them, call the prop value:',
  'Note that the default value from your createContext(defaultValue) call is only used if there is no matching provider above at all. If there is a <SomeContext.Provider value={undefined}> component somewhere in the parent tree, the component calling useContext(SomeContext) will receive undefined as the context value.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react/useDebugValue
[
  'Is this page useful?',
  'useDebugValue is a React Hook that lets you add a label to a custom Hook in React DevTools.',
  'Call useDebugValue at the top level of your custom Hook to display a readable debug value:',
  'See more examples below.',
  'useDebugValue does not return anything.',
  'Call useDebugValue at the top level of your custom Hook to display a readable debug value for React DevTools.',
  'This gives components calling useOnlineStatus a label like OnlineStatus: "Online" when you inspect them:',
  'Without the useDebugValue call, only the underlying data (in this example, true) would be displayed.',
  'Don’t add debug values to every custom Hook. It’s most valuable for custom Hooks that are part of shared libraries and that have a complex internal data structure that’s difficult to inspect.',
  'You can also pass a formatting function as the second argument to useDebugValue:',
  'Your formatting function will receive the debug value as a parameter and should return a formatted display value. When your component is inspected, React DevTools will call this function and display its result.',
  'This lets you avoid running potentially expensive formatting logic unless the component is actually inspected. For example, if date is a Date value, this avoids calling toDateString() on it for every render.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react/useDeferredValue
[
  'Is this page useful?',
  'useDeferredValue is a React Hook that lets you defer updating a part of the UI.',
  'Call useDeferredValue at the top level of your component to get a deferred version of that value.',
  'See more examples below.',
  'During the initial render, the returned deferred value will be the same as the value you provided. During updates, React will first attempt a re-render with the old value (so it will return the old value), and then try another re-render in background with the new value (so it will return the updated value).',
  'The values you pass to useDeferredValue should either be primitive values (like strings and numbers) or objects created outside of rendering. If you create a new object during rendering and immediately pass it to useDeferredValue, it will be different on every render, causing unnecessary background re-renders.',
  'When useDeferredValue receives a different value (compared with Object.is), in addition to the current render (when it still uses the previous value), it schedules a re-render in the background with the new value. The background re-render is interruptible: if there’s another update to the value, React will restart the background re-render from scratch. For example, if the user is typing into an input faster than a chart receiving its deferred value can re-render, the chart will only re-render after the user stops typing.',
  'useDeferredValue is integrated with <Suspense>. If the background update caused by a new value suspends the UI, the user will not see the fallback. They will see the old deferred value until the data loads.',
  'useDeferredValue does not by itself prevent extra network requests.',
  'There is no fixed delay caused by useDeferredValue itself. As soon as React finishes the original re-render, React will immediately start working on the background re-render with the new deferred value. Any updates caused by events (like typing) will interrupt the background re-render and get prioritized over it.',
  'The background re-render caused by useDeferredValue does not fire Effects until it’s committed to the screen. If the background re-render suspends, its Effects will run after the data loads and the UI updates.',
  'Call useDeferredValue at the top level of your component to defer updating some part of your UI.',
  'During the initial render, the deferred value will be the same as the value you provided.',
  'During updates, the deferred value will “lag behind” the latest value. In particular, React will first re-render without updating the deferred value, and then try to re-render with the newly received value in background.',
  'Let’s walk through an example to see when this is useful.',
  'This example assumes you use a Suspense-enabled data source:',
  'Learn more about Suspense and its limitations.',
  'In this example, the SearchResults component suspends while fetching the search results. Try typing "a", waiting for the results, and then editing it to "ab". The results for "a" get replaced by the loading fallback.',
  'A common alternative UI pattern is to defer updating the list of results and to keep showing the previous results until the new results are ready. Call useDeferredValue to pass a deferred version of the query down:',
  'The query will update immediately, so the input will display the new value. However, the deferredQuery will keep its previous value until the data has loaded, so SearchResults will show the stale results for a bit.',
  'Enter "a" in the example below, wait for the results to load, and then edit the input to "ab". Notice how instead of the Suspense fallback, you now see the stale result list until the new results have loaded:',
  'You can think of it as happening in two steps:',
  'First, React re-renders with the new query ("ab") but with the old deferredQuery (still "a"). The deferredQuery value, which you pass to the result list, is deferred: it “lags behind” the query value.',
  'In background, React tries to re-render with both query and deferredQuery updated to "ab". If this re-render completes, React will show it on the screen. However, if it suspends (the results for "ab" have not loaded yet), React will abandon this rendering attempt, and retry this re-render again after the data has loaded. The user will keep seeing the stale deferred value until the data is ready.',
  'The deferred “background” rendering is interruptible. For example, if you type into the input again, React will abandon it and restart with the new value. React will always use the latest provided value.',
  'Note that there is still a network request per each keystroke. What’s being deferred here is displaying results (until they’re ready), not the network requests themselves. Even if the user continues typing, responses for each keystroke get cached, so pressing Backspace is instant and doesn’t fetch again.',
  'In the example above, there is no indication that the result list for the latest query is still loading. This can be confusing to the user if the new results take a while to load. To make it more obvious to the user that the result list does not match the latest query, you can add a visual indication when the stale result list is displayed:',
  'With this change, as soon as you start typing, the stale result list gets slightly dimmed until the new result list loads. You can also add a CSS transition to delay dimming so that it feels gradual, like in the example below:',
  'You can also apply useDeferredValue as a performance optimization. It is useful when a part of your UI is slow to re-render, there’s no easy way to optimize it, and you want to prevent it from blocking the rest of the UI.',
  'Imagine you have a text field and a component (like a chart or a long list) that re-renders on every keystroke:',
  'First, optimize SlowList to skip re-rendering when its props are the same. To do this, wrap it in memo:',
  'However, this only helps if the SlowList props are the same as during the previous render. The problem you’re facing now is that it’s slow when they’re different, and when you actually need to show different visual output.',
  'Concretely, the main performance problem is that whenever you type into the input, the SlowList receives new props, and re-rendering its entire tree makes the typing feel janky. In this case, useDeferredValue lets you prioritize updating the input (which must be fast) over updating the result list (which is allowed to be slower):',
  'This does not make re-rendering of the SlowList faster. However, it tells React that re-rendering the list can be deprioritized so that it doesn’t block the keystrokes. The list will “lag behind” the input and then “catch up”. Like before, React will attempt to update the list as soon as possible, but will not block the user from typing.',
  'In this example, each item in the SlowList component is artificially slowed down so that you can see how useDeferredValue lets you keep the input responsive. Type into the input and notice that typing feels snappy while the list “lags behind” it.',
  'This optimization requires SlowList to be wrapped in memo. This is because whenever the text changes, React needs to be able to re-render the parent component quickly. During that re-render, deferredText still has its previous value, so SlowList is able to skip re-rendering (its props have not changed). Without memo, it would have to re-render anyway, defeating the point of the optimization.',
  'There are two common optimization techniques you might have used before in this scenario:',
  'While these techniques are helpful in some cases, useDeferredValue is better suited to optimizing rendering because it is deeply integrated with React itself and adapts to the user’s device.',
  'Unlike debouncing or throttling, it doesn’t require choosing any fixed delay. If the user’s device is fast (e.g. powerful laptop), the deferred re-render would happen almost immediately and wouldn’t be noticeable. If the user’s device is slow, the list would “lag behind” the input proportionally to how slow the device is.',
  'Also, unlike with debouncing or throttling, deferred re-renders done by useDeferredValue are interruptible by default. This means that if React is in the middle of re-rendering a large list, but the user makes another keystroke, React will abandon that re-render, handle the keystroke, and then start rendering in background again. By contrast, debouncing and throttling still produce a janky experience because they’re blocking: they merely postpone the moment when rendering blocks the keystroke.',
  'If the work you’re optimizing doesn’t happen during rendering, debouncing and throttling are still useful. For example, they can let you fire fewer network requests. You can also use these techniques together.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react/useEffect
[
  'Is this page useful?',
  'useEffect is a React Hook that lets you synchronize a component with an external system.',
  'Call useEffect at the top level of your component to declare an Effect:',
  'See more examples below.',
  'setup: The function with your Effect’s logic. Your setup function may also optionally return a cleanup function. When your component is added to the DOM, React will run your setup function. After every re-render with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values. After your component is removed from the DOM, React will run your cleanup function.',
  'optional dependencies: The list of all reactive values referenced inside of the setup code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like [dep1, dep2, dep3]. React will compare each dependency with its previous value using the Object.is comparison. If you omit this argument, your Effect will re-run after every re-render of the component. See the difference between passing an array of dependencies, an empty array, and no dependencies at all.',
  'useEffect returns undefined.',
  'useEffect is a Hook, so you can only call it at the top level of your component or your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a new component and move the state into it.',
  'If you’re not trying to synchronize with some external system, you probably don’t need an Effect.',
  'When Strict Mode is on, React will run one extra development-only setup+cleanup cycle before the first real setup. This is a stress-test that ensures that your cleanup logic “mirrors” your setup logic and that it stops or undoes whatever the setup is doing. If this causes a problem, implement the cleanup function.',
  'If some of your dependencies are objects or functions defined inside the component, there is a risk that they will cause the Effect to re-run more often than needed. To fix this, remove unnecessary object and function dependencies. You can also extract state updates and non-reactive logic outside of your Effect.',
  'If your Effect wasn’t caused by an interaction (like a click), React will generally let the browser paint the updated screen first before running your Effect. If your Effect is doing something visual (for example, positioning a tooltip), and the delay is noticeable (for example, it flickers), replace useEffect with useLayoutEffect.',
  'Even if your Effect was caused by an interaction (like a click), the browser may repaint the screen before processing the state updates inside your Effect. Usually, that’s what you want. However, if you must block the browser from repainting the screen, you need to replace useEffect with useLayoutEffect.',
  'Effects only run on the client. They don’t run during server rendering.',
  'Some components need to stay connected to the network, some browser API, or a third-party library, while they are displayed on the page. These systems aren’t controlled by React, so they are called external.',
  'To connect your component to some external system, call useEffect at the top level of your component:',
  'You need to pass two arguments to useEffect:',
  'React calls your setup and cleanup functions whenever it’s necessary, which may happen multiple times:',
  'Let’s illustrate this sequence for the example above.',
  'When the ChatRoom component above gets added to the page, it will connect to the chat room with the initial serverUrl and roomId. If either serverUrl or roomId change as a result of a re-render (say, if the user picks a different chat room in a dropdown), your Effect will disconnect from the previous room, and connect to the next one. When the ChatRoom component is removed from the page, your Effect will disconnect one last time.',
  'To help you find bugs, in development React runs setup and cleanup one extra time before the setup. This is a stress-test that verifies your Effect’s logic is implemented correctly. If this causes visible issues, your cleanup function is missing some logic. The cleanup function should stop or undo whatever the setup function was doing. The rule of thumb is that the user shouldn’t be able to distinguish between the setup being called once (as in production) and a setup → cleanup → setup sequence (as in development). See common solutions.',
  'Try to write every Effect as an independent process and think about a single setup/cleanup cycle at a time. It shouldn’t matter whether your component is mounting, updating, or unmounting. When your cleanup logic correctly “mirrors” the setup logic, your Effect is resilient to running setup and cleanup as often as needed.',
  'An Effect lets you keep your component synchronized with some external system (like a chat service). Here, external system means any piece of code that’s not controlled by React, such as:',
  'If you’re not connecting to any external system, you probably don’t need an Effect.',
  'In this example, the ChatRoom component uses an Effect to stay connected to an external system defined in chat.js. Press “Open chat” to make the ChatRoom component appear. This sandbox runs in development mode, so there is an extra connect-and-disconnect cycle, as explained here. Try changing the roomId and serverUrl using the dropdown and the input, and see how the Effect re-connects to the chat. Press “Close chat” to see the Effect disconnect one last time.',
  'Effects are an “escape hatch”: you use them when you need to “step outside React” and when there is no better built-in solution for your use case. If you find yourself often needing to manually write Effects, it’s usually a sign that you need to extract some custom Hooks for common behaviors your components rely on.',
  'For example, this useChatRoom custom Hook “hides” the logic of your Effect behind a more declarative API:',
  'Then you can use it from any component like this:',
  'There are also many excellent custom Hooks for every purpose available in the React ecosystem.',
  'Learn more about wrapping Effects in custom Hooks.',
  'This example is identical to one of the earlier examples, but the logic is extracted to a custom Hook.',
  'Sometimes, you want to keep an external system synchronized to some prop or state of your component.',
  'For example, if you have a third-party map widget or a video player component written without React, you can use an Effect to call methods on it that make its state match the current state of your React component. This Effect creates an instance of a MapWidget class defined in map-widget.js. When you change the zoomLevel prop of the Map component, the Effect calls the setZoom() on the class instance to keep it synchronized:',
  'In this example, a cleanup function is not needed because the MapWidget class manages only the DOM node that was passed to it. After the Map React component is removed from the tree, both the DOM node and the MapWidget class instance will be automatically garbage-collected by the browser JavaScript engine.',
  'You can use an Effect to fetch data for your component. Note that if you use a framework, using your framework’s data fetching mechanism will be a lot more efficient than writing Effects manually.',
  'If you want to fetch data from an Effect manually, your code might look like this:',
  'Note the ignore variable which is initialized to false, and is set to true during cleanup. This ensures your code doesn’t suffer from “race conditions”: network responses may arrive in a different order than you sent them.',
  'You can also rewrite using the async / await syntax, but you still need to provide a cleanup function:',
  'Writing data fetching directly in Effects gets repetitive and makes it difficult to add optimizations like caching and server rendering later. It’s easier to use a custom Hook—either your own or maintained by the community.',
  'Writing fetch calls inside Effects is a popular way to fetch data, especially in fully client-side apps. This is, however, a very manual approach and it has significant downsides:',
  'This list of downsides is not specific to React. It applies to fetching data on mount with any library. Like with routing, data fetching is not trivial to do well, so we recommend the following approaches:',
  'You can continue fetching data directly in Effects if neither of these approaches suit you.',
  'Notice that you can’t “choose” the dependencies of your Effect. Every reactive value used by your Effect’s code must be declared as a dependency. Your Effect’s dependency list is determined by the surrounding code:',
  'If either serverUrl or roomId change, your Effect will reconnect to the chat using the new values.',
  'Reactive values include props and all variables and functions declared directly inside of your component. Since roomId and serverUrl are reactive values, you can’t remove them from the dependencies. If you try to omit them and your linter is correctly configured for React, the linter will flag this as a mistake you need to fix:',
  'To remove a dependency, you need to “prove” to the linter that it doesn’t need to be a dependency. For example, you can move serverUrl out of your component to prove that it’s not reactive and won’t change on re-renders:',
  'Now that serverUrl is not a reactive value (and can’t change on a re-render), it doesn’t need to be a dependency. If your Effect’s code doesn’t use any reactive values, its dependency list should be empty ([]):',
  'An Effect with empty dependencies doesn’t re-run when any of your component’s props or state change.',
  'If you have an existing codebase, you might have some Effects that suppress the linter like this:',
  'When dependencies don’t match the code, there is a high risk of introducing bugs. By suppressing the linter, you “lie” to React about the values your Effect depends on. Instead, prove they’re unnecessary.',
  'If you specify the dependencies, your Effect runs after the initial render and after re-renders with changed dependencies.',
  'In the below example, serverUrl and roomId are reactive values, so they both must be specified as dependencies. As a result, selecting a different room in the dropdown or editing the server URL input causes the chat to re-connect. However, since message isn’t used in the Effect (and so it isn’t a dependency), editing the message doesn’t re-connect to the chat.',
  'When you want to update state based on previous state from an Effect, you might run into a problem:',
  'Since count is a reactive value, it must be specified in the list of dependencies. However, that causes the Effect to cleanup and setup again every time the count changes. This is not ideal.',
  'To fix this, pass the c => c + 1 state updater to setCount:',
  'Now that you’re passing c => c + 1 instead of count + 1, your Effect no longer needs to depend on count. As a result of this fix, it won’t need to cleanup and setup the interval again every time the count changes.',
  'If your Effect depends on an object or a function created during rendering, it might run too often. For example, this Effect re-connects after every render because the options object is different for every render:',
  'Avoid using an object created during rendering as a dependency. Instead, create the object inside the Effect:',
  'Now that you create the options object inside the Effect, the Effect itself only depends on the roomId string.',
  'With this fix, typing into the input doesn’t reconnect the chat. Unlike an object which gets re-created, a string like roomId doesn’t change unless you set it to another value. Read more about removing dependencies.',
  'If your Effect depends on an object or a function created during rendering, it might run too often. For example, this Effect re-connects after every render because the createOptions function is different for every render:',
  'By itself, creating a function from scratch on every re-render is not a problem. You don’t need to optimize that. However, if you use it as a dependency of your Effect, it will cause your Effect to re-run after every re-render.',
  'Avoid using a function created during rendering as a dependency. Instead, declare it inside the Effect:',
  'Now that you define the createOptions function inside the Effect, the Effect itself only depends on the roomId string. With this fix, typing into the input doesn’t reconnect the chat. Unlike a function which gets re-created, a string like roomId doesn’t change unless you set it to another value. Read more about removing dependencies.',
  'This section describes an experimental API that has not yet been released in a stable version of React.',
  'By default, when you read a reactive value from an Effect, you have to add it as a dependency. This ensures that your Effect “reacts” to every change of that value. For most dependencies, that’s the behavior you want.',
  'However, sometimes you’ll want to read the latest props and state from an Effect without “reacting” to them. For example, imagine you want to log the number of the items in the shopping cart for every page visit:',
  'What if you want to log a new page visit after every url change, but not if only the shoppingCart changes? You can’t exclude shoppingCart from dependencies without breaking the reactivity rules. However, you can express that you don’t want a piece of code to “react” to changes even though it is called from inside an Effect. Declare an Effect Event with the useEffectEvent Hook, and move the code reading shoppingCart inside of it:',
  'Effect Events are not reactive and must always be omitted from dependencies of your Effect. This is what lets you put non-reactive code (where you can read the latest value of some props and state) inside of them. By reading shoppingCart inside of onVisit, you ensure that shoppingCart won’t re-run your Effect.',
  'Read more about how Effect Events let you separate reactive and non-reactive code.',
  'If your app uses server rendering (either directly or via a framework), your component will render in two different environments. On the server, it will render to produce the initial HTML. On the client, React will run the rendering code again so that it can attach your event handlers to that HTML. This is why, for hydration to work, your initial render output must be identical on the client and the server.',
  'In rare cases, you might need to display different content on the client. For example, if your app reads some data from localStorage, it can’t possibly do that on the server. Here is how you could implement this:',
  'While the app is loading, the user will see the initial render output. Then, when it’s loaded and hydrated, your Effect will run and set didMount to true, triggering a re-render. This will switch to the client-only render output. Effects don’t run on the server, so this is why didMount was false during the initial server render.',
  'Use this pattern sparingly. Keep in mind that users with a slow connection will see the initial content for quite a bit of time—potentially, many seconds—so you don’t want to make jarring changes to your component’s appearance. In many cases, you can avoid the need for this by conditionally showing different things with CSS.',
  'When Strict Mode is on, in development, React runs setup and cleanup one extra time before the actual setup.',
  'This is a stress-test that verifies your Effect’s logic is implemented correctly. If this causes visible issues, your cleanup function is missing some logic. The cleanup function should stop or undo whatever the setup function was doing. The rule of thumb is that the user shouldn’t be able to distinguish between the setup being called once (as in production) and a setup → cleanup → setup sequence (as in development).',
  'Read more about how this helps find bugs and how to fix your logic.',
  'First, check that you haven’t forgotten to specify the dependency array:',
  'If you’ve specified the dependency array but your Effect still re-runs in a loop, it’s because one of your dependencies is different on every re-render.',
  'You can debug this problem by manually logging your dependencies to the console:',
  'You can then right-click on the arrays from different re-renders in the console and select “Store as a global variable” for both of them. Assuming the first one got saved as temp1 and the second one got saved as temp2, you can then use the browser console to check whether each dependency in both arrays is the same:',
  'When you find the dependency that is different on every re-render, you can usually fix it in one of these ways:',
  'As a last resort (if these methods didn’t help), wrap its creation with useMemo or useCallback (for functions).',
  'If your Effect runs in an infinite cycle, these two things must be true:',
  'Before you start fixing the problem, ask yourself whether your Effect is connecting to some external system (like DOM, network, a third-party widget, and so on). Why does your Effect need to set state? Does it synchronize with that external system? Or are you trying to manage your application’s data flow with it?',
  'If there is no external system, consider whether removing the Effect altogether would simplify your logic.',
  'If you’re genuinely synchronizing with some external system, think about why and under what conditions your Effect should update the state. Has something changed that affects your component’s visual output? If you need to keep track of some data that isn’t used by rendering, a ref (which doesn’t trigger re-renders) might be more appropriate. Verify your Effect doesn’t update the state (and trigger re-renders) more than needed.',
  'Finally, if your Effect is updating the state at the right time, but there is still a loop, it’s because that state update leads to one of the Effect’s dependencies changing. Read how to debug dependency changes.',
  'The cleanup function runs not only during unmount, but before every re-render with changed dependencies. Additionally, in development, React runs setup+cleanup one extra time immediately after component mounts.',
  'If you have cleanup code without corresponding setup code, it’s usually a code smell:',
  'Your cleanup logic should be “symmetrical” to the setup logic, and should stop or undo whatever setup did:',
  'Learn how the Effect lifecycle is different from the component’s lifecycle.',
  'If your Effect must block the browser from painting the screen, replace useEffect with useLayoutEffect. Note that this shouldn’t be needed for the vast majority of Effects. You’ll only need this if it’s crucial to run your Effect before the browser paint: for example, to measure and position a tooltip before the user sees it.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react/useId
[
  'Is this page useful?',
  'useId is a React Hook for generating unique IDs that can be passed to accessibility attributes.',
  'Call useId at the top level of your component to generate a unique ID:',
  'See more examples below.',
  'useId does not take any parameters.',
  'useId returns a unique ID string associated with this particular useId call in this particular component.',
  'useId is a Hook, so you can only call it at the top level of your component or your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a new component and move the state into it.',
  'useId should not be used to generate keys in a list. Keys should be generated from your data.',
  'Do not call useId to generate keys in a list. Keys should be generated from your data.',
  'Call useId at the top level of your component to generate a unique ID:',
  'You can then pass the generated ID to different attributes:',
  'Let’s walk through an example to see when this is useful.',
  'HTML accessibility attributes like aria-describedby let you specify that two tags are related to each other. For example, you can specify that an element (like an input) is described by another element (like a paragraph).',
  'In regular HTML, you would write it like this:',
  'However, hardcoding IDs like this is not a good practice in React. A component may be rendered more than once on the page—but IDs have to be unique! Instead of hardcoding an ID, generate a unique ID with useId:',
  'Now, even if PasswordField appears multiple times on the screen, the generated IDs won’t clash.',
  'Watch this video to see the difference in the user experience with assistive technologies.',
  'With server rendering, useId requires an identical component tree on the server and the client. If the trees you render on the server and the client don’t match exactly, the generated IDs won’t match.',
  'You might be wondering why useId is better than incrementing a global variable like nextId++.',
  'The primary benefit of useId is that React ensures that it works with server rendering. During server rendering, your components generate HTML output. Later, on the client, hydration attaches your event handlers to the generated HTML. For hydration to work, the client output must match the server HTML.',
  'This is very difficult to guarantee with an incrementing counter because the order in which the Client Components are hydrated may not match the order in which the server HTML was emitted. By calling useId, you ensure that hydration will work, and the output will match between the server and the client.',
  'Inside React, useId is generated from the “parent path” of the calling component. This is why, if the client and the server tree are the same, the “parent path” will match up regardless of rendering order.',
  'If you need to give IDs to multiple related elements, you can call useId to generate a shared prefix for them:',
  'This lets you avoid calling useId for every single element that needs a unique ID.',
  'If you render multiple independent React applications on a single page, pass identifierPrefix as an option to your createRoot or hydrateRoot calls. This ensures that the IDs generated by the two different apps never clash because every identifier generated with useId will start with the distinct prefix you’ve specified.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react/useImperativeHandle
[
  'Is this page useful?',
  'useImperativeHandle is a React Hook that lets you customize the handle exposed as a ref.',
  'Call useImperativeHandle at the top level of your component to customize the ref handle it exposes:',
  'See more examples below.',
  'ref: The ref you received as the second argument from the forwardRef render function.',
  'createHandle: A function that takes no arguments and returns the ref handle you want to expose. That ref handle can have any type. Usually, you will return an object with the methods you want to expose.',
  'optional dependencies: The list of all reactive values referenced inside of the createHandle code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like [dep1, dep2, dep3]. React will compare each dependency with its previous value using the Object.is comparison. If a re-render resulted in a change to some dependency, or if you omitted this argument, your createHandle function will re-execute, and the newly created handle will be assigned to the ref.',
  'useImperativeHandle returns undefined.',
  'By default, components don’t expose their DOM nodes to parent components. For example, if you want the parent component of MyInput to have access to the <input> DOM node, you have to opt in with forwardRef:',
  'With the code above, a ref to MyInput will receive the <input> DOM node. However, you can expose a custom value instead. To customize the exposed handle, call useImperativeHandle at the top level of your component:',
  'Note that in the code above, the ref is no longer forwarded to the <input>.',
  'For example, suppose you don’t want to expose the entire <input> DOM node, but you want to expose two of its methods: focus and scrollIntoView. To do this, keep the real browser DOM in a separate ref. Then use useImperativeHandle to expose a handle with only the methods that you want the parent component to call:',
  'Now, if the parent component gets a ref to MyInput, it will be able to call the focus and scrollIntoView methods on it. However, it will not have full access to the underlying <input> DOM node.',
  'The methods you expose via an imperative handle don’t have to match the DOM methods exactly. For example, this Post component exposes a scrollAndFocusAddComment method via an imperative handle. This lets the parent Page scroll the list of comments and focus the input field when you click the button:',
  'Do not overuse refs. You should only use refs for imperative behaviors that you can’t express as props: for example, scrolling to a node, focusing a node, triggering an animation, selecting text, and so on.',
  'If you can express something as a prop, you should not use a ref. For example, instead of exposing an imperative handle like { open, close } from a Modal component, it is better to take isOpen as a prop like <Modal isOpen={isOpen} />. Effects can help you expose imperative behaviors via props.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react/useInsertionEffect
[
  'Is this page useful?',
  'useInsertionEffect is for CSS-in-JS library authors. Unless you are working on a CSS-in-JS library and need a place to inject the styles, you probably want useEffect or useLayoutEffect instead.',
  'useInsertionEffect allows inserting elements into the DOM before any layout effects fire.',
  'Call useInsertionEffect to insert styles before any effects fire that may need to read layout:',
  'See more examples below.',
  'setup: The function with your Effect’s logic. Your setup function may also optionally return a cleanup function. When your component is added to the DOM, but before any layout effects fire, React will run your setup function. After every re-render with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values. When your component is removed from the DOM, React will run your cleanup function.',
  'optional dependencies: The list of all reactive values referenced inside of the setup code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like [dep1, dep2, dep3]. React will compare each dependency with its previous value using the Object.is comparison algorithm. If you don’t specify the dependencies at all, your Effect will re-run after every re-render of the component.',
  'useInsertionEffect returns undefined.',
  'Traditionally, you would style React components using plain CSS.',
  'Some teams prefer to author styles directly in JavaScript code instead of writing CSS files. This usually requires using a CSS-in-JS library or a tool. There are three common approaches to CSS-in-JS:',
  'If you use CSS-in-JS, we recommend a combination of the first two approaches (CSS files for static styles, inline styles for dynamic styles). We don’t recommend runtime <style> tag injection for two reasons:',
  'The first problem is not solvable, but useInsertionEffect helps you solve the second problem.',
  'Call useInsertionEffect to insert the styles before any layout effects fire:',
  'Similarly to useEffect, useInsertionEffect does not run on the server. If you need to collect which CSS rules have been used on the server, you can do it during rendering:',
  'Read more about upgrading CSS-in-JS libraries with runtime injection to useInsertionEffect.',
  'If you insert styles during rendering and React is processing a non-blocking update, the browser will recalculate the styles every single frame while rendering a component tree, which can be extremely slow.',
  'useInsertionEffect is better than inserting styles during useLayoutEffect or useEffect because it ensures that by the time other Effects run in your components, the <style> tags have already been inserted. Otherwise, layout calculations in regular Effects would be wrong due to outdated styles.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react/useLayoutEffect
[
  'Is this page useful?',
  'useLayoutEffect can hurt performance. Prefer useEffect when possible.',
  'useLayoutEffect is a version of useEffect that fires before the browser repaints the screen.',
  'Call useLayoutEffect to perform the layout measurements before the browser repaints the screen:',
  'See more examples below.',
  'setup: The function with your Effect’s logic. Your setup function may also optionally return a cleanup function. Before your component is added to the DOM, React will run your setup function. After every re-render with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values. Before your component is removed from the DOM, React will run your cleanup function.',
  'optional dependencies: The list of all reactive values referenced inside of the setup code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like [dep1, dep2, dep3]. React will compare each dependency with its previous value using the Object.is comparison. If you omit this argument, your Effect will re-run after every re-render of the component.',
  'useLayoutEffect returns undefined.',
  'useLayoutEffect is a Hook, so you can only call it at the top level of your component or your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a component and move the Effect there.',
  'When Strict Mode is on, React will run one extra development-only setup+cleanup cycle before the first real setup. This is a stress-test that ensures that your cleanup logic “mirrors” your setup logic and that it stops or undoes whatever the setup is doing. If this causes a problem, implement the cleanup function.',
  'If some of your dependencies are objects or functions defined inside the component, there is a risk that they will cause the Effect to re-run more often than needed. To fix this, remove unnecessary object and function dependencies. You can also extract state updates and non-reactive logic outside of your Effect.',
  'Effects only run on the client. They don’t run during server rendering.',
  'The code inside useLayoutEffect and all state updates scheduled from it block the browser from repainting the screen. When used excessively, this makes your app slow. When possible, prefer useEffect.',
  'Most components don’t need to know their position and size on the screen to decide what to render. They only return some JSX. Then the browser calculates their layout (position and size) and repaints the screen.',
  'Sometimes, that’s not enough. Imagine a tooltip that appears next to some element on hover. If there’s enough space, the tooltip should appear above the element, but if it doesn’t fit, it should appear below. In order to render the tooltip at the right final position, you need to know its height (i.e. whether it fits at the top).',
  'To do this, you need to render in two passes:',
  'All of this needs to happen before the browser repaints the screen. You don’t want the user to see the tooltip moving. Call useLayoutEffect to perform the layout measurements before the browser repaints the screen:',
  'Here’s how this works step by step:',
  'Hover over the buttons below and see how the tooltip adjusts its position depending on whether it fits:',
  'Notice that even though the Tooltip component has to render in two passes (first, with tooltipHeight initialized to 0 and then with the real measured height), you only see the final result. This is why you need useLayoutEffect instead of useEffect for this example. Let’s look at the difference in detail below.',
  'React guarantees that the code inside useLayoutEffect and any state updates scheduled inside it will be processed before the browser repaints the screen. This lets you render the tooltip, measure it, and re-render the tooltip again without the user noticing the first extra render. In other words, useLayoutEffect blocks the browser from painting.',
  'Rendering in two passes and blocking the browser hurts performance. Try to avoid this when you can.',
  'The purpose of useLayoutEffect is to let your component use layout information for rendering:',
  'When you or your framework uses server rendering, your React app renders to HTML on the server for the initial render. This lets you show the initial HTML before the JavaScript code loads.',
  'The problem is that on the server, there is no layout information.',
  'In the earlier example, the useLayoutEffect call in the Tooltip component lets it position itself correctly (either above or below content) depending on the content height. If you tried to render Tooltip as a part of the initial server HTML, this would be impossible to determine. On the server, there is no layout yet! So, even if you rendered it on the server, its position would “jump” on the client after the JavaScript loads and runs.',
  'Usually, components that rely on layout information don’t need to render on the server anyway. For example, it probably doesn’t make sense to show a Tooltip during the initial render. It is triggered by a client interaction.',
  'However, if you’re running into this problem, you have a few different options:',
  'Replace useLayoutEffect with useEffect. This tells React that it’s okay to display the initial render result without blocking the paint (because the original HTML will become visible before your Effect runs).',
  'Alternatively, mark your component as client-only. This tells React to replace its content up to the closest <Suspense> boundary with a loading fallback (for example, a spinner or a glimmer) during server rendering.',
  'Alternatively, you can render a component with useLayoutEffect only after hydration. Keep a boolean isMounted state that’s initialized to false, and set it to true inside a useEffect call. Your rendering logic can then be like return isMounted ? <RealContent /> : <FallbackContent />. On the server and during the hydration, the user will see FallbackContent which should not call useLayoutEffect. Then React will replace it with RealContent which runs on the client only and can include useLayoutEffect calls.',
  'If you synchronize your component with an external data store and rely on useLayoutEffect for different reasons than measuring layout, consider useSyncExternalStore instead which supports server rendering.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react/useMemo
[
  'Is this page useful?',
  'useMemo is a React Hook that lets you cache the result of a calculation between re-renders.',
  'Call useMemo at the top level of your component to cache a calculation between re-renders:',
  'See more examples below.',
  'calculateValue: The function calculating the value that you want to cache. It should be pure, should take no arguments, and should return a value of any type. React will call your function during the initial render. On next renders, React will return the same value again if the dependencies have not changed since the last render. Otherwise, it will call calculateValue, return its result, and store it so it can be reused later.',
  'dependencies: The list of all reactive values referenced inside of the calculateValue code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like [dep1, dep2, dep3]. React will compare each dependency with its previous value using the Object.is comparison.',
  'On the initial render, useMemo returns the result of calling calculateValue with no arguments.',
  'During next renders, it will either return an already stored value from the last render (if the dependencies haven’t changed), or call calculateValue again, and return the result that calculateValue has returned.',
  'Caching return values like this is also known as memoization, which is why this Hook is called useMemo.',
  'To cache a calculation between re-renders, wrap it in a useMemo call at the top level of your component:',
  'You need to pass two things to useMemo:',
  'On the initial render, the value you’ll get from useMemo will be the result of calling your calculation.',
  'On every subsequent render, React will compare the dependencies with the dependencies you passed during the last render. If none of the dependencies have changed (compared with Object.is), useMemo will return the value you already calculated before. Otherwise, React will re-run your calculation and return the new value.',
  'In other words, useMemo caches a calculation result between re-renders until its dependencies change.',
  'Let’s walk through an example to see when this is useful.',
  'By default, React will re-run the entire body of your component every time that it re-renders. For example, if this TodoList updates its state or receives new props from its parent, the filterTodos function will re-run:',
  'Usually, this isn’t a problem because most calculations are very fast. However, if you’re filtering or transforming a large array, or doing some expensive computation, you might want to skip doing it again if data hasn’t changed. If both todos and tab are the same as they were during the last render, wrapping the calculation in useMemo like earlier lets you reuse visibleTodos you’ve already calculated before.',
  'This type of caching is called memoization.',
  'You should only rely on useMemo as a performance optimization. If your code doesn’t work without it, find the underlying problem and fix it first. Then you may add useMemo to improve performance.',
  'In general, unless you’re creating or looping over thousands of objects, it’s probably not expensive. If you want to get more confidence, you can add a console log to measure the time spent in a piece of code:',
  'Perform the interaction you’re measuring (for example, typing into the input). You will then see logs like filter array: 0.15ms in your console. If the overall logged time adds up to a significant amount (say, 1ms or more), it might make sense to memoize that calculation. As an experiment, you can then wrap the calculation in useMemo to verify whether the total logged time has decreased for that interaction or not:',
  'useMemo won’t make the first render faster. It only helps you skip unnecessary work on updates.',
  'Keep in mind that your machine is probably faster than your users’ so it’s a good idea to test the performance with an artificial slowdown. For example, Chrome offers a CPU Throttling option for this.',
  'Also note that measuring performance in development will not give you the most accurate results. (For example, when Strict Mode is on, you will see each component render twice rather than once.) To get the most accurate timings, build your app for production and test it on a device like your users have.',
  'If your app is like this site, and most interactions are coarse (like replacing a page or an entire section), memoization is usually unnecessary. On the other hand, if your app is more like a drawing editor, and most interactions are granular (like moving shapes), then you might find memoization very helpful.',
  'Optimizing with useMemo  is only valuable in a few cases:',
  'There is no benefit to wrapping a calculation in useMemo in other cases. There is no significant harm to doing that either, so some teams choose to not think about individual cases, and memoize as much as possible. The downside of this approach is that code becomes less readable. Also, not all memoization is effective: a single value that’s “always new” is enough to break memoization for an entire component.',
  'In practice, you can make a lot of memoization unnecessary by following a few principles:',
  'If a specific interaction still feels laggy, use the React Developer Tools profiler to see which components would benefit the most from memoization, and add memoization where needed. These principles make your components easier to debug and understand, so it’s good to follow them in any case. In the long term, we’re researching doing granular memoization automatically to solve this once and for all.',
  'In this example, the filterTodos implementation is artificially slowed down so that you can see what happens when some JavaScript function you’re calling during rendering is genuinely slow. Try switching the tabs and toggling the theme.',
  'Switching the tabs feels slow because it forces the slowed down filterTodos to re-execute. That’s expected because the tab has changed, and so the entire calculation needs to re-run. (If you’re curious why it runs twice, it’s explained here.)',
  'Toggle the theme. Thanks to useMemo, it’s fast despite the artificial slowdown! The slow filterTodos call was skipped because both todos and tab (which you pass as dependencies to useMemo) haven’t changed since the last render.',
  'In some cases, useMemo can also help you optimize performance of re-rendering child components. To illustrate this, let’s say this TodoList component passes the visibleTodos as a prop to the child List component:',
  'You’ve noticed that toggling the theme prop freezes the app for a moment, but if you remove <List /> from your JSX, it feels fast. This tells you that it’s worth trying to optimize the List component.',
  'By default, when a component re-renders, React re-renders all of its children recursively. This is why, when TodoList re-renders with a different theme, the List component also re-renders. This is fine for components that don’t require much calculation to re-render. But if you’ve verified that a re-render is slow, you can tell List to skip re-rendering when its props are the same as on last render by wrapping it in memo:',
  'With this change, List will skip re-rendering if all of its props are the same as on the last render. This is where caching the calculation becomes important! Imagine that you calculated visibleTodos without useMemo:',
  'In the above example, the filterTodos function always creates a different array, similar to how the {} object literal always creates a new object. Normally, this wouldn’t be a problem, but it means that List props will never be the same, and your memo optimization won’t work. This is where useMemo comes in handy:',
  'By wrapping the visibleTodos calculation in useMemo, you ensure that it has the same value between the re-renders (until dependencies change). You don’t have to wrap a calculation in useMemo unless you do it for some specific reason. In this example, the reason is that you pass it to a component wrapped in memo, and this lets it skip re-rendering. There are a few other reasons to add useMemo which are described further on this page.',
  'Instead of wrapping List in memo, you could wrap the <List /> JSX node itself in useMemo:',
  'The behavior would be the same. If the visibleTodos haven’t changed, List won’t be re-rendered.',
  'A JSX node like <List items={visibleTodos} /> is an object like { type: List, props: { items: visibleTodos } }. Creating this object is very cheap, but React doesn’t know whether its contents is the same as last time or not. This is why by default, React will re-render the List component.',
  'However, if React sees the same exact JSX as during the previous render, it won’t try to re-render your component. This is because JSX nodes are immutable. A JSX node object could not have changed over time, so React knows it’s safe to skip a re-render. However, for this to work, the node has to actually be the same object, not merely look the same in code. This is what useMemo does in this example.',
  'Manually wrapping JSX nodes into useMemo is not convenient. For example, you can’t do this conditionally. This is usually why you would wrap components with memo instead of wrapping JSX nodes.',
  'In this example, the List component is artificially slowed down so that you can see what happens when a React component you’re rendering is genuinely slow. Try switching the tabs and toggling the theme.',
  'Switching the tabs feels slow because it forces the slowed down List to re-render. That’s expected because the tab has changed, and so you need to reflect the user’s new choice on the screen.',
  'Next, try toggling the theme. Thanks to useMemo together with memo, it’s fast despite the artificial slowdown! The List skipped re-rendering because the visibleTodos array has not changed since the last render. The visibleTodos array has not changed because both todos and tab (which you pass as dependencies to useMemo) haven’t changed since the last render.',
  'Suppose you have a calculation that depends on an object created directly in the component body:',
  'Depending on an object like this defeats the point of memoization. When a component re-renders, all of the code directly inside the component body runs again. The lines of code creating the searchOptions object will also run on every re-render. Since searchOptions is a dependency of your useMemo call, and it’s different every time, React knows the dependencies are different, and recalculate searchItems every time.',
  'To fix this, you could memoize the searchOptions object itself before passing it as a dependency:',
  'In the example above, if the text did not change, the searchOptions object also won’t change. However, an even better fix is to move the searchOptions object declaration inside of the useMemo calculation function:',
  'Now your calculation depends on text directly (which is a string and can’t “accidentally” become different).',
  'Suppose the Form component is wrapped in memo. You want to pass a function to it as a prop:',
  'Just as {} creates a different object, function declarations like function() {} and expressions like () => {} produce a different function on every re-render. By itself, creating a new function is not a problem. This is not something to avoid! However, if the Form component is memoized, presumably you want to skip re-rendering it when no props have changed. A prop that is always different would defeat the point of memoization.',
  'To memoize a function with useMemo, your calculation function would have to return another function:',
  'This looks clunky! Memoizing functions is common enough that React has a built-in Hook specifically for that. Wrap your functions into useCallback instead of useMemo to avoid having to write an extra nested function:',
  'The two examples above are completely equivalent. The only benefit to useCallback is that it lets you avoid writing an extra nested function inside. It doesn’t do anything else. Read more about useCallback.',
  'In Strict Mode, React will call some of your functions twice instead of once:',
  'This is expected and shouldn’t break your code.',
  'This development-only behavior helps you keep components pure. React uses the result of one of the calls, and ignores the result of the other call. As long as your component and calculation functions are pure, this shouldn’t affect your logic. However, if they are accidentally impure, this helps you notice and fix the mistake.',
  'For example, this impure calculation function mutates an array you received as a prop:',
  'React calls your function twice, so you’d notice the todo is added twice. Your calculation shouldn’t change any existing objects, but it’s okay to change any new objects you created during the calculation. For example, if the filterTodos function always returns a different array, you can mutate that array instead:',
  'Read keeping components pure to learn more about purity.',
  'Also, check out the guides on updating objects and updating arrays without mutation.',
  'This code doesn’t work:',
  'In JavaScript, () => { starts the arrow function body, so the { brace is not a part of your object. This is why it doesn’t return an object, and leads to mistakes. You could fix it by adding parentheses like ({ and }):',
  'However, this is still confusing and too easy for someone to break by removing the parentheses.',
  'To avoid this mistake, write a return statement explicitly:',
  'Make sure you’ve specified the dependency array as a second argument!',
  'If you forget the dependency array, useMemo will re-run the calculation every time:',
  'This is the corrected version passing the dependency array as a second argument:',
  'If this doesn’t help, then the problem is that at least one of your dependencies is different from the previous render. You can debug this problem by manually logging your dependencies to the console:',
  'You can then right-click on the arrays from different re-renders in the console and select “Store as a global variable” for both of them. Assuming the first one got saved as temp1 and the second one got saved as temp2, you can then use the browser console to check whether each dependency in both arrays is the same:',
  'When you find which dependency breaks memoization, either find a way to remove it, or memoize it as well.',
  'Suppose the Chart component is wrapped in memo. You want to skip re-rendering every Chart in the list when the ReportList component re-renders. However, you can’t call useMemo in a loop:',
  'Instead, extract a component for each item and memoize data for individual items:',
  'Alternatively, you could remove useMemo and instead wrap Report itself in memo. If the item prop does not change, Report will skip re-rendering, so Chart will skip re-rendering too:',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react/useOptimistic
[
  'Is this page useful?',
  'The useOptimistic Hook is currently only available in React’s Canary and experimental channels. Learn more about React’s release channels here.',
  'useOptimistic is a React Hook that lets you optimistically update the UI.',
  'useOptimistic is a React Hook that lets you show a different state while an async action is underway. It accepts some state as an argument and returns a copy of that state that can be different during the duration of an async action such as a network request. You provide a function that takes the current state and the input to the action, and returns the optimistic state to be used while the action is pending.',
  'This state is called the “optimistic” state because it is usually used to immediately present the user with the result of performing an action, even though the action actually takes time to complete.',
  'See more examples below.',
  'The useOptimistic Hook provides a way to optimistically update the user interface before a background operation, like a network request, completes. In the context of forms, this technique helps to make apps feel more responsive. When a user submits a form, instead of waiting for the server’s response to reflect the changes, the interface is immediately updated with the expected outcome.',
  'For example, when a user types a message into the form and hits the “Send” button, the useOptimistic Hook allows the message to immediately appear in the list with a “Sending…” label, even before the message is actually sent to a server. This “optimistic” approach gives the impression of speed and responsiveness. The form then attempts to truly send the message in the background. Once the server confirms the message has been received, the “Sending…” label is removed.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react/useReducer
[
  'Is this page useful?',
  'useReducer is a React Hook that lets you add a reducer to your component.',
  'Call useReducer at the top level of your component to manage its state with a reducer.',
  'See more examples below.',
  'useReducer returns an array with exactly two values:',
  'The dispatch function returned by useReducer lets you update the state to a different value and trigger a re-render. You need to pass the action as the only argument to the dispatch function:',
  'React will set the next state to the result of calling the reducer function you’ve provided with the current state and the action you’ve passed to dispatch.',
  'dispatch functions do not have a return value.',
  'The dispatch function only updates the state variable for the next render. If you read the state variable after calling the dispatch function, you will still get the old value that was on the screen before your call.',
  'If the new value you provide is identical to the current state, as determined by an Object.is comparison, React will skip re-rendering the component and its children. This is an optimization. React may still need to call your component before ignoring the result, but it shouldn’t affect your code.',
  'React batches state updates. It updates the screen after all the event handlers have run and have called their set functions. This prevents multiple re-renders during a single event. In the rare case that you need to force React to update the screen earlier, for example to access the DOM, you can use flushSync.',
  'Call useReducer at the top level of your component to manage state with a reducer.',
  'useReducer returns an array with exactly two items:',
  'To update what’s on the screen, call dispatch with an object representing what the user did, called an action:',
  'React will pass the current state and the action to your reducer function. Your reducer will calculate and return the next state. React will store that next state, render your component with it, and update the UI.',
  'useReducer is very similar to useState, but it lets you move the state update logic from event handlers into a single function outside of your component. Read more about choosing between useState and useReducer.',
  'A reducer function is declared like this:',
  'Then you need to fill in the code that will calculate and return the next state. By convention, it is common to write it as a switch statement. For each case in the switch, calculate and return some next state.',
  'Actions can have any shape. By convention, it’s common to pass objects with a type property identifying the action. It should include the minimal necessary information that the reducer needs to compute the next state.',
  'The action type names are local to your component. Each action describes a single interaction, even if that leads to multiple changes in data. The shape of the state is arbitrary, but usually it’ll be an object or an array.',
  'Read extracting state logic into a reducer to learn more.',
  'State is read-only. Don’t modify any objects or arrays in state:',
  'Instead, always return new objects from your reducer:',
  'Read updating objects in state and updating arrays in state to learn more.',
  'In this example, the reducer manages a state object with two fields: name and age.',
  'React saves the initial state once and ignores it on the next renders.',
  'Although the result of createInitialState(username) is only used for the initial render, you’re still calling this function on every render. This can be wasteful if it’s creating large arrays or performing expensive calculations.',
  'To solve this, you may pass it as an initializer function to useReducer as the third argument instead:',
  'Notice that you’re passing createInitialState, which is the function itself, and not createInitialState(), which is the result of calling it. This way, the initial state does not get re-created after initialization.',
  'In the above example, createInitialState takes a username argument. If your initializer doesn’t need any information to compute the initial state, you may pass null as the second argument to useReducer.',
  'This example passes the initializer function, so the createInitialState function only runs during initialization. It does not run when component re-renders, such as when you type into the input.',
  'Calling the dispatch function does not change state in the running code:',
  'This is because states behaves like a snapshot. Updating state requests another render with the new state value, but does not affect the state JavaScript variable in your already-running event handler.',
  'If you need to guess the next state value, you can calculate it manually by calling the reducer yourself:',
  'React will ignore your update if the next state is equal to the previous state, as determined by an Object.is comparison. This usually happens when you change an object or an array in state directly:',
  'You mutated an existing state object and returned it, so React ignored the update. To fix this, you need to ensure that you’re always updating objects in state and updating arrays in state instead of mutating them:',
  'Make sure that every case branch copies all of the existing fields when returning the new state:',
  'Without ...state above, the returned next state would only contain the age field and nothing else.',
  'If your state unexpectedly becomes undefined, you’re likely forgetting to return state in one of the cases, or your action type doesn’t match any of the case statements. To find why, throw an error outside the switch:',
  'You can also use a static type checker like TypeScript to catch such mistakes.',
  'You might get an error that says: Too many re-renders. React limits the number of renders to prevent an infinite loop. Typically, this means that you’re unconditionally dispatching an action during render, so your component enters a loop: render, dispatch (which causes a render), render, dispatch (which causes a render), and so on. Very often, this is caused by a mistake in specifying an event handler:',
  'If you can’t find the cause of this error, click on the arrow next to the error in the console and look through the JavaScript stack to find the specific dispatch function call responsible for the error.',
  'In Strict Mode, React will call your reducer and initializer functions twice. This shouldn’t break your code.',
  'This development-only behavior helps you keep components pure. React uses the result of one of the calls, and ignores the result of the other call. As long as your component, initializer, and reducer functions are pure, this shouldn’t affect your logic. However, if they are accidentally impure, this helps you notice the mistakes.',
  'For example, this impure reducer function mutates an array in state:',
  'Because React calls your reducer function twice, you’ll see the todo was added twice, so you’ll know that there is a mistake. In this example, you can fix the mistake by replacing the array instead of mutating it:',
  'Now that this reducer function is pure, calling it an extra time doesn’t make a difference in behavior. This is why React calling it twice helps you find mistakes. Only component, initializer, and reducer functions need to be pure. Event handlers don’t need to be pure, so React will never call your event handlers twice.',
  'Read keeping components pure to learn more.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react/useRef
[
  'Is this page useful?',
  'useRef is a React Hook that lets you reference a value that’s not needed for rendering.',
  'Call useRef at the top level of your component to declare a ref.',
  'See more examples below.',
  'useRef returns an object with a single property:',
  'On the next renders, useRef will return the same object.',
  'Call useRef at the top level of your component to declare one or more refs.',
  'useRef returns a ref object with a single current property initially set to the initial value you provided.',
  'On the next renders, useRef will return the same object. You can change its current property to store information and read it later. This might remind you of state, but there is an important difference.',
  'Changing a ref does not trigger a re-render. This means refs are perfect for storing information that doesn’t affect the visual output of your component. For example, if you need to store an interval ID and retrieve it later, you can put it in a ref. To update the value inside the ref, you need to manually change its current property:',
  'Later, you can read that interval ID from the ref so that you can call clear that interval:',
  'By using a ref, you ensure that:',
  'Changing a ref does not trigger a re-render, so refs are not appropriate for storing information you want to display on the screen. Use state for that instead. Read more about choosing between useRef and useState.',
  'This component uses a ref to keep track of how many times the button was clicked. Note that it’s okay to use a ref instead of state here because the click count is only read and written in an event handler.',
  'If you show {ref.current} in the JSX, the number won’t update on click. This is because setting ref.current does not trigger a re-render. Information that’s used for rendering should be state instead.',
  'Do not write or read ref.current during rendering.',
  'React expects that the body of your component behaves like a pure function:',
  'Reading or writing a ref during rendering breaks these expectations.',
  'You can read or write refs from event handlers or effects instead.',
  'If you have to read or write something during rendering, use state instead.',
  'When you break these rules, your component might still work, but most of the newer features we’re adding to React will rely on these expectations. Read more about keeping your components pure.',
  'It’s particularly common to use a ref to manipulate the DOM. React has built-in support for this.',
  'First, declare a ref object with an initial value of null:',
  'Then pass your ref object as the ref attribute to the JSX of the DOM node you want to manipulate:',
  'After React creates the DOM node and puts it on the screen, React will set the current property of your ref object to that DOM node. Now you can access the <input>’s DOM node and call methods like focus():',
  'React will set the current property back to null when the node is removed from the screen.',
  'Read more about manipulating the DOM with refs.',
  'In this example, clicking the button will focus the input:',
  'React saves the initial ref value once and ignores it on the next renders.',
  'Although the result of new VideoPlayer() is only used for the initial render, you’re still calling this function on every render. This can be wasteful if it’s creating expensive objects.',
  'To solve it, you may initialize the ref like this instead:',
  'Normally, writing or reading ref.current during render is not allowed. However, it’s fine in this case because the result is always the same, and the condition only executes during initialization so it’s fully predictable.',
  'If you use a type checker and don’t want to always check for null, you can try a pattern like this instead:',
  'Here, the playerRef itself is nullable. However, you should be able to convince your type checker that there is no case in which getPlayer() returns null. Then use getPlayer() in your event handlers.',
  'If you try to pass a ref to your own component like this:',
  'You might get an error in the console:',
  'By default, your own components don’t expose refs to the DOM nodes inside them.',
  'To fix this, find the component that you want to get a ref to:',
  'And then wrap it in forwardRef like this:',
  'Then the parent component can get a ref to it.',
  'Read more about accessing another component’s DOM nodes.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react/useSyncExternalStore
[
  'Is this page useful?',
  'useSyncExternalStore is a React Hook that lets you subscribe to an external store.',
  'Call useSyncExternalStore at the top level of your component to read a value from an external data store.',
  'It returns the snapshot of the data in the store. You need to pass two functions as arguments:',
  'See more examples below.',
  'subscribe: A function that takes a single callback argument and subscribes it to the store. When the store changes, it should invoke the provided callback. This will cause the component to re-render. The subscribe function should return a function that cleans up the subscription.',
  'getSnapshot: A function that returns a snapshot of the data in the store that’s needed by the component. While the store has not changed, repeated calls to getSnapshot must return the same value. If the store changes and the returned value is different (as compared by Object.is), React re-renders the component.',
  'optional getServerSnapshot: A function that returns the initial snapshot of the data in the store. It will be used only during server rendering and during hydration of server-rendered content on the client. The server snapshot must be the same between the client and the server, and is usually serialized and passed from the server to the client. If you omit this argument, rendering the component on the server will throw an error.',
  'The current snapshot of the store which you can use in your rendering logic.',
  'The store snapshot returned by getSnapshot must be immutable. If the underlying store has mutable data, return a new immutable snapshot if the data has changed. Otherwise, return a cached last snapshot.',
  'If a different subscribe function is passed during a re-render, React will re-subscribe to the store using the newly passed subscribe function. You can prevent this by declaring subscribe outside the component.',
  'If the store is mutated during a non-blocking transition update, React will fall back to performing that update as blocking. Specifically, for every transition update, React will call getSnapshot a second time just before applying changes to the DOM. If it returns a different value than when it was called originally, React will restart the update from scratch, this time applying it as a blocking update, to ensure that every component on screen is reflecting the same version of the store.',
  'It’s not recommended to suspend a render based on a store value returned by useSyncExternalStore. The reason is that mutations to the external store cannot be marked as non-blocking transition updates, so they will trigger the nearest Suspense fallback, replacing already-rendered content on screen with a loading spinner, which typically makes a poor UX.',
  'For example, the following are discouraged:',
  'Most of your React components will only read data from their props, state, and context. However, sometimes a component needs to read some data from some store outside of React that changes over time. This includes:',
  'Call useSyncExternalStore at the top level of your component to read a value from an external data store.',
  'It returns the snapshot of the data in the store. You need to pass two functions as arguments:',
  'React will use these functions to keep your component subscribed to the store and re-render it on changes.',
  'For example, in the sandbox below, todosStore is implemented as an external store that stores data outside of React. The TodosApp component connects to that external store with the useSyncExternalStore Hook.',
  'When possible, we recommend using built-in React state with useState and useReducer instead. The useSyncExternalStore API is mostly useful if you need to integrate with existing non-React code.',
  'Another reason to add useSyncExternalStore is when you want to subscribe to some value exposed by the browser that changes over time. For example, suppose that you want your component to display whether the network connection is active. The browser exposes this information via a property called navigator.onLine.',
  'This value can change without React’s knowledge, so you should read it with useSyncExternalStore.',
  'To implement the getSnapshot function, read the current value from the browser API:',
  'Next, you need to implement the subscribe function. For example, when navigator.onLine changes, the browser fires the online and offline events on the window object. You need to subscribe the callback argument to the corresponding events, and then return a function that cleans up the subscriptions:',
  'Now React knows how to read the value from the external navigator.onLine API and how to subscribe to its changes. Disconnect your device from the network and notice that the component re-renders in response:',
  'Usually you won’t write useSyncExternalStore directly in your components. Instead, you’ll typically call it from your own custom Hook. This lets you use the same external store from different components.',
  'For example, this custom useOnlineStatus Hook tracks whether the network is online:',
  'Now different components can call useOnlineStatus without repeating the underlying implementation:',
  'If your React app uses server rendering, your React components will also run outside the browser environment to generate the initial HTML. This creates a few challenges when connecting to an external store:',
  'To solve these issues, pass a getServerSnapshot function as the third argument to useSyncExternalStore:',
  'The getServerSnapshot function is similar to getSnapshot, but it runs only in two situations:',
  'This lets you provide the initial snapshot value which will be used before the app becomes interactive. If there is no meaningful initial value for the server rendering, omit this argument to force rendering on the client.',
  'Make sure that getServerSnapshot returns the same exact data on the initial client render as it returned on the server. For example, if getServerSnapshot returned some prepopulated store content on the server, you need to transfer this content to the client. One way to do this is to emit a <script> tag during server rendering that sets a global like window.MY_STORE_DATA, and read from that global on the client in getServerSnapshot. Your external store should provide instructions on how to do that.',
  'This error means your getSnapshot function returns a new object every time it’s called, for example:',
  'React will re-render the component if getSnapshot return value is different from the last time. This is why, if you always return a different value, you will enter an infinite loop and get this error.',
  'Your getSnapshot object should only return a different object if something has actually changed. If your store contains immutable data, you can return that data directly:',
  'If your store data is mutable, your getSnapshot function should return an immutable snapshot of it. This means it does need to create new objects, but it shouldn’t do this for every single call. Instead, it should store the last calculated snapshot, and return the same snapshot as the last time if the data in the store has not changed. How you determine whether mutable data has changed depends on your mutable store.',
  'This subscribe function is defined inside a component so it is different on every re-render:',
  'React will resubscribe to your store if you pass a different subscribe function between re-renders. If this causes performance issues and you’d like to avoid resubscribing, move the subscribe function outside:',
  'Alternatively, wrap subscribe into useCallback to only resubscribe when some argument changes:',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react/useTransition
[
  'Is this page useful?',
  'useTransition is a React Hook that lets you update the state without blocking the UI.',
  'Call useTransition at the top level of your component to mark some state updates as transitions.',
  'See more examples below.',
  'useTransition does not take any parameters.',
  'useTransition returns an array with exactly two items:',
  'The startTransition function returned by useTransition lets you mark a state update as a transition.',
  'startTransition does not return anything.',
  'useTransition is a Hook, so it can only be called inside components or custom Hooks. If you need to start a transition somewhere else (for example, from a data library), call the standalone startTransition instead.',
  'You can wrap an update into a transition only if you have access to the set function of that state. If you want to start a transition in response to some prop or a custom Hook value, try useDeferredValue instead.',
  'The function you pass to startTransition must be synchronous. React immediately executes this function, marking all state updates that happen while it executes as transitions. If you try to perform more state updates later (for example, in a timeout), they won’t be marked as transitions.',
  'A state update marked as a transition will be interrupted by other state updates. For example, if you update a chart component inside a transition, but then start typing into an input while the chart is in the middle of a re-render, React will restart the rendering work on the chart component after handling the input update.',
  'Transition updates can’t be used to control text inputs.',
  'If there are multiple ongoing transitions, React currently batches them together. This is a limitation that will likely be removed in a future release.',
  'Call useTransition at the top level of your component to mark state updates as non-blocking transitions.',
  'useTransition returns an array with exactly two items:',
  'You can then mark a state update as a transition like this:',
  'Transitions let you keep the user interface updates responsive even on slow devices.',
  'With a transition, your UI stays responsive in the middle of a re-render. For example, if the user clicks a tab but then change their mind and click another tab, they can do that without waiting for the first re-render to finish.',
  'In this example, the “Posts” tab is artificially slowed down so that it takes at least a second to render.',
  'Click “Posts” and then immediately click “Contact”. Notice that this interrupts the slow render of “Posts”. The “Contact” tab shows immediately. Because this state update is marked as a transition, a slow re-render did not freeze the user interface.',
  'You can update a parent component’s state from the useTransition call, too. For example, this TabButton component wraps its onClick logic in a transition:',
  'Because the parent component updates its state inside the onClick event handler, that state update gets marked as a transition. This is why, like in the earlier example, you can click on “Posts” and then immediately click “Contact”. Updating the selected tab is marked as a transition, so it does not block user interactions.',
  'You can use the isPending boolean value returned by useTransition to indicate to the user that a transition is in progress. For example, the tab button can have a special “pending” visual state:',
  'Notice how clicking “Posts” now feels more responsive because the tab button itself updates right away:',
  'In this example, the PostsTab component fetches some data using a Suspense-enabled data source. When you click the “Posts” tab, the PostsTab component suspends, causing the closest loading fallback to appear:',
  'Hiding the entire tab container to show a loading indicator leads to a jarring user experience. If you add useTransition to TabButton, you can instead indicate display the pending state in the tab button instead.',
  'Notice that clicking “Posts” no longer replaces the entire tab container with a spinner:',
  'Read more about using transitions with Suspense.',
  'Transitions will only “wait” long enough to avoid hiding already revealed content (like the tab container). If the Posts tab had a nested <Suspense> boundary, the transition would not “wait” for it.',
  'If you’re building a React framework or a router, we recommend marking page navigations as transitions.',
  'This is recommended for two reasons:',
  'Here is a tiny simplified router example using transitions for navigations.',
  'Suspense-enabled routers are expected to wrap the navigation updates into transitions by default.',
  'Error Boundary for useTransition is currently only available in React’s canary and experimental channels. Learn more about React’s release channels here.',
  'If a function passed to startTransition throws an error, you can display an error to your user with an error boundary. To use an error boundary, wrap the component where you are calling the useTransition in an error boundary. Once the function passed to startTransition errors, the fallback for the error boundary will be displayed.',
  'You can’t use a transition for a state variable that controls an input:',
  'This is because transitions are non-blocking, but updating an input in response to the change event should happen synchronously. If you want to run a transition in response to typing, you have two options:',
  'When you wrap a state update in a transition, make sure that it happens during the startTransition call:',
  'The function you pass to startTransition must be synchronous.',
  'You can’t mark an update as a transition like this:',
  'Instead, you could do this:',
  'Similarly, you can’t mark an update as a transition like this:',
  'However, this works instead:',
  'You can’t call useTransition outside a component because it’s a Hook. In this case, use the standalone startTransition method instead. It works the same way, but it doesn’t provide the isPending indicator.',
  'If you run this code, it will print 1, 2, 3:',
  'It is expected to print 1, 2, 3. The function you pass to startTransition does not get delayed. Unlike with the browser setTimeout, it does not run the callback later. React executes your function immediately, but any state updates scheduled while it is running are marked as transitions. You can imagine that it works like this:',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react/components
[
  'Is this page useful?',
  'React exposes a few built-in components that you can use in your JSX.',
  'You can also define your own components as JavaScript functions.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react/Fragment
[
  'Is this page useful?',
  '<Fragment>, often used via <>...</> syntax, lets you group elements without a wrapper node.',
  'Wrap elements in <Fragment> to group them together in situations where you need a single element. Grouping elements in Fragment has no effect on the resulting DOM; it is the same as if the elements were not grouped. The empty JSX tag <></> is shorthand for <Fragment></Fragment> in most cases.',
  "If you want to pass key to a Fragment, you can’t use the <>...</> syntax. You have to explicitly import Fragment from 'react' and render <Fragment key={yourKey}>...</Fragment>.",
  'React does not reset state when you go from rendering <><Child /></> to [<Child />] or back, or when you go from rendering <><Child /></> to <Child /> and back. This only works a single level deep: for example, going from <><><Child /></></> to <Child /> resets the state. See the precise semantics here.',
  'Use Fragment, or the equivalent <>...</> syntax, to group multiple elements together. You can use it to put multiple elements in any place where a single element can go. For example, a component can only return one element, but by using a Fragment you can group multiple elements together and then return them as a group:',
  'Fragments are useful because grouping elements with a Fragment has no effect on layout or styles, unlike if you wrapped the elements in another container like a DOM element. If you inspect this example with the browser tools, you’ll see that all <h1> and <article> DOM nodes appear as siblings without wrappers around them:',
  'The example above is equivalent to importing Fragment from React:',
  'Usually you won’t need this unless you need to pass a key to your Fragment.',
  'Like any other element, you can assign Fragment elements to variables, pass them as props, and so on:',
  'You can use Fragment to group text together with components:',
  'Here’s a situation where you need to write Fragment explicitly instead of using the <></> syntax. When you render multiple elements in a loop, you need to assign a key to each element. If the elements within the loop are Fragments, you need to use the normal JSX element syntax in order to provide the key attribute:',
  'You can inspect the DOM to verify that there are no wrapper elements around the Fragment children:',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react/Profiler
[
  'Is this page useful?',
  '<Profiler> lets you measure rendering performance of a React tree programmatically.',
  'Wrap a component tree in a <Profiler> to measure its rendering performance.',
  'React will call your onRender callback with information about what was rendered.',
  'Wrap the <Profiler> component around a React tree to measure its rendering performance.',
  'It requires two props: an id (string) and an onRender callback (function) which React calls any time a component within the tree “commits” an update.',
  'Profiling adds some additional overhead, so it is disabled in the production build by default. To opt into production profiling, you need to enable a special production build with profiling enabled.',
  '<Profiler> lets you gather measurements programmatically. If you’re looking for an interactive profiler, try the Profiler tab in React Developer Tools. It exposes similar functionality as a browser extension.',
  'You can use multiple <Profiler> components to measure different parts of your application:',
  'You can also nest <Profiler> components:',
  'Although <Profiler> is a lightweight component, it should be used only when necessary. Each use adds some CPU and memory overhead to an application.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react/StrictMode
[
  'Is this page useful?',
  '<StrictMode> lets you find common bugs in your components early during development.',
  'Use StrictMode to enable additional development behaviors and warnings for the component tree inside:',
  'See more examples below.',
  'Strict Mode enables the following development-only behaviors:',
  'StrictMode accepts no props.',
  'Strict Mode enables extra development-only checks for the entire component tree inside the <StrictMode> component. These checks help you find common bugs in your components early in the development process.',
  'To enable Strict Mode for your entire app, wrap your root component with <StrictMode> when you render it:',
  'We recommend wrapping your entire app in Strict Mode, especially for newly created apps. If you use a framework that calls createRoot for you, check its documentation for how to enable Strict Mode.',
  'Although the Strict Mode checks only run in development, they help you find bugs that already exist in your code but can be tricky to reliably reproduce in production. Strict Mode lets you fix bugs before your users report them.',
  'Strict Mode enables the following checks in development:',
  'All of these checks are development-only and do not impact the production build.',
  'You can also enable Strict Mode for any part of your application:',
  'In this example, Strict Mode checks will not run against the Header and Footer components. However, they will run on Sidebar and Content, as well as all of the components inside them, no matter how deep.',
  'React assumes that every component you write is a pure function. This means that React components you write must always return the same JSX given the same inputs (props, state, and context).',
  'Components breaking this rule behave unpredictably and cause bugs. To help you find accidentally impure code, Strict Mode calls some of your functions (only the ones that should be pure) twice in development. This includes:',
  'If a function is pure, running it twice does not change its behavior because a pure function produces the same result every time. However, if a function is impure (for example, it mutates the data it receives), running it twice tends to be noticeable (that’s what makes it impure!) This helps you spot and fix the bug early.',
  'Here is an example to illustrate how double rendering in Strict Mode helps you find bugs early.',
  'This StoryTray component takes an array of stories and adds one last “Create Story” item at the end:',
  'There is a mistake in the code above. However, it is easy to miss because the initial output appears correct.',
  'This mistake will become more noticeable if the StoryTray component re-renders multiple times. For example, let’s make the StoryTray re-render with a different background color whenever you hover over it:',
  'Notice how every time you hover over the StoryTray component, “Create Story” gets added to the list again. The intention of the code was to add it once at the end. But StoryTray directly modifies the stories array from the props. Every time StoryTray renders, it adds “Create Story” again at the end of the same array. In other words, StoryTray is not a pure function—running it multiple times produces different results.',
  'To fix this problem, you can make a copy of the array, and modify that copy instead of the original one:',
  'This would make the StoryTray function pure. Each time it is called, it would only modify a new copy of the array, and would not affect any external objects or variables. This solves the bug, but you had to make the component re-render more often before it became obvious that something is wrong with its behavior.',
  'In the original example, the bug wasn’t obvious. Now let’s wrap the original (buggy) code in <StrictMode>:',
  'Strict Mode always calls your rendering function twice, so you can see the mistake right away (“Create Story” appears twice). This lets you notice such mistakes early in the process. When you fix your component to render in Strict Mode, you also fix many possible future production bugs like the hover functionality from before:',
  'Without Strict Mode, it was easy to miss the bug until you added more re-renders. Strict Mode made the same bug appear right away. Strict Mode helps you find bugs before you push them to your team and to your users.',
  'Read more about keeping components pure.',
  'If you have React DevTools installed, any console.log calls during the second render call will appear slightly dimmed. React DevTools also offers a setting (off by default) to suppress them completely.',
  'Strict Mode can also help find bugs in Effects.',
  'Every Effect has some setup code and may have some cleanup code. Normally, React calls setup when the component mounts (is added to the screen) and calls cleanup when the component unmounts (is removed from the screen). React then calls cleanup and setup again if its dependencies changed since the last render.',
  'When Strict Mode is on, React will also run one extra setup+cleanup cycle in development for every Effect. This may feel surprising, but it helps reveal subtle bugs that are hard to catch manually.',
  'Here is an example to illustrate how re-running Effects in Strict Mode helps you find bugs early.',
  'Consider this example that connects a component to a chat:',
  'There is an issue with this code, but it might not be immediately clear.',
  'To make the issue more obvious, let’s implement a feature. In the example below, roomId is not hardcoded. Instead, the user can select the roomId that they want to connect to from a dropdown. Click “Open chat” and then select different chat rooms one by one. Keep track of the number of active connections in the console:',
  'You’ll notice that the number of open connections always keeps growing. In a real app, this would cause performance and network problems. The issue is that your Effect is missing a cleanup function:',
  'Now that your Effect “cleans up” after itself and destroys the outdated connections, the leak is solved. However, notice that the problem did not become visible until you’ve added more features (the select box).',
  'In the original example, the bug wasn’t obvious. Now let’s wrap the original (buggy) code in <StrictMode>:',
  'With Strict Mode, you immediately see that there is a problem (the number of active connections jumps to 2). Strict Mode runs an extra setup+cleanup cycle for every Effect. This Effect has no cleanup logic, so it creates an extra connection but doesn’t destroy it. This is a hint that you’re missing a cleanup function.',
  'Strict Mode lets you notice such mistakes early in the process. When you fix your Effect by adding a cleanup function in Strict Mode, you also fix many possible future production bugs like the select box from before:',
  'Notice how the active connection count in the console doesn’t keep growing anymore.',
  'Without Strict Mode, it was easy to miss that your Effect needed cleanup. By running setup → cleanup → setup instead of setup for your Effect in development, Strict Mode made the missing cleanup logic more noticeable.',
  'Read more about implementing Effect cleanup.',
  'React warns if some component anywhere inside a <StrictMode> tree uses one of these deprecated APIs:',
  'These APIs are primarily used in older class components so they rarely appear in modern apps.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react/Suspense
[
  'Is this page useful?',
  '<Suspense> lets you display a fallback until its children have finished loading.',
  'You can wrap any part of your application with a Suspense boundary:',
  'React will display your loading fallback until all the code and data needed by the children has been loaded.',
  'In the example below, the Albums component suspends while fetching the list of albums. Until it’s ready to render, React switches the closest Suspense boundary above to show the fallback—your Loading component. Then, when the data loads, React hides the Loading fallback and renders the Albums component with data.',
  'Only Suspense-enabled data sources will activate the Suspense component. They include:',
  'Suspense does not detect when data is fetched inside an Effect or event handler.',
  'The exact way you would load data in the Albums component above depends on your framework. If you use a Suspense-enabled framework, you’ll find the details in its data fetching documentation.',
  'Suspense-enabled data fetching without the use of an opinionated framework is not yet supported. The requirements for implementing a Suspense-enabled data source are unstable and undocumented. An official API for integrating data sources with Suspense will be released in a future version of React.',
  'By default, the whole tree inside Suspense is treated as a single unit. For example, even if only one of these components suspends waiting for some data, all of them together will be replaced by the loading indicator:',
  'Then, after all of them are ready to be displayed, they will all appear together at once.',
  'In the example below, both Biography and Albums fetch some data. However, because they are grouped under a single Suspense boundary, these components always “pop in” together at the same time.',
  'Components that load data don’t have to be direct children of the Suspense boundary. For example, you can move Biography and Albums into a new Details component. This doesn’t change the behavior. Biography and Albums share the same closest parent Suspense boundary, so their reveal is coordinated together.',
  'When a component suspends, the closest parent Suspense component shows the fallback. This lets you nest multiple Suspense components to create a loading sequence. Each Suspense boundary’s fallback will be filled in as the next level of content becomes available. For example, you can give the album list its own fallback:',
  'With this change, displaying the Biography doesn’t need to “wait” for the Albums to load.',
  'The sequence will be:',
  'Suspense boundaries let you coordinate which parts of your UI should always “pop in” together at the same time, and which parts should progressively reveal more content in a sequence of loading states. You can add, move, or delete Suspense boundaries in any place in the tree without affecting the rest of your app’s behavior.',
  'Don’t put a Suspense boundary around every component. Suspense boundaries should not be more granular than the loading sequence that you want the user to experience. If you work with a designer, ask them where the loading states should be placed—it’s likely that they’ve already included them in their design wireframes.',
  'In this example, the SearchResults component suspends while fetching the search results. Type "a", wait for the results, and then edit it to "ab". The results for "a" will get replaced by the loading fallback.',
  'A common alternative UI pattern is to defer updating the list and to keep showing the previous results until the new results are ready. The useDeferredValue Hook lets you pass a deferred version of the query down:',
  'The query will update immediately, so the input will display the new value. However, the deferredQuery will keep its previous value until the data has loaded, so SearchResults will show the stale results for a bit.',
  'To make it more obvious to the user, you can add a visual indication when the stale result list is displayed:',
  'Enter "a" in the example below, wait for the results to load, and then edit the input to "ab". Notice how instead of the Suspense fallback, you now see the dimmed stale result list until the new results have loaded:',
  'Both deferred values and transitions let you avoid showing Suspense fallback in favor of inline indicators. Transitions mark the whole update as non-urgent so they are typically used by frameworks and router libraries for navigation. Deferred values, on the other hand, are mostly useful in application code where you want to mark a part of UI as non-urgent and let it “lag behind” the rest of the UI.',
  'When a component suspends, the closest parent Suspense boundary switches to showing the fallback. This can lead to a jarring user experience if it was already displaying some content. Try pressing this button:',
  'When you pressed the button, the Router component rendered ArtistPage instead of IndexPage. A component inside ArtistPage suspended, so the closest Suspense boundary started showing the fallback. The closest Suspense boundary was near the root, so the whole site layout got replaced by BigSpinner.',
  'To prevent this, you can mark the navigation state update as a transition with startTransition:',
  'This tells React that the state transition is not urgent, and it’s better to keep showing the previous page instead of hiding any already revealed content. Now clicking the button “waits” for the Biography to load:',
  'A transition doesn’t wait for all content to load. It only waits long enough to avoid hiding already revealed content. For example, the website Layout was already revealed, so it would be bad to hide it behind a loading spinner. However, the nested Suspense boundary around Albums is new, so the transition doesn’t wait for it.',
  'Suspense-enabled routers are expected to wrap the navigation updates into transitions by default.',
  'In the above example, once you click the button, there is no visual indication that a navigation is in progress. To add an indicator, you can replace startTransition with useTransition which gives you a boolean isPending value. In the example below, it’s used to change the website header styling while a transition is happening:',
  'During a transition, React will avoid hiding already revealed content. However, if you navigate to a route with different parameters, you might want to tell React it is different content. You can express this with a key:',
  'Imagine you’re navigating within a user’s profile page, and something suspends. If that update is wrapped in a transition, it will not trigger the fallback for already visible content. That’s the expected behavior.',
  'However, now imagine you’re navigating between two different user profiles. In that case, it makes sense to show the fallback. For example, one user’s timeline is different content from another user’s timeline. By specifying a key, you ensure that React treats different users’ profiles as different components, and resets the Suspense boundaries during navigation. Suspense-integrated routers should do this automatically.',
  'If you use one of the streaming server rendering APIs (or a framework that relies on them), React will also use your <Suspense> boundaries to handle errors on the server. If a component throws an error on the server, React will not abort the server render. Instead, it will find the closest <Suspense> component above it and include its fallback (such as a spinner) into the generated server HTML. The user will see a spinner at first.',
  'On the client, React will attempt to render the same component again. If it errors on the client too, React will throw the error and display the closest error boundary. However, if it does not error on the client, React will not display the error to the user since the content was eventually displayed successfully.',
  'You can use this to opt out some components from rendering on the server. To do this, throw an error in the server environment and then wrap them in a <Suspense> boundary to replace their HTML with fallbacks:',
  'The server HTML will include the loading indicator. It will be replaced by the Chat component on the client.',
  'Replacing visible UI with a fallback creates a jarring user experience. This can happen when an update causes a component to suspend, and the nearest Suspense boundary is already showing content to the user.',
  'To prevent this from happening, mark the update as non-urgent using startTransition. During a transition, React will wait until enough data has loaded to prevent an unwanted fallback from appearing:',
  'This will avoid hiding existing content. However, any newly rendered Suspense boundaries will still immediately display fallbacks to avoid blocking the UI and let the user see the content as it becomes available.',
  'React will only prevent unwanted fallbacks during non-urgent updates. It will not delay a render if it’s the result of an urgent update. You must opt in with an API like startTransition or useDeferredValue.',
  'If your router is integrated with Suspense, it should wrap its updates into startTransition automatically.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react/apis
[
  'Is this page useful?',
  'In addition to Hooks and Components, the react package exports a few other APIs that are useful for defining components. This page lists all the remaining modern React APIs.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react/cache
[
  'Is this page useful?',
  'cache is only for use with React Server Components. See frameworks that support React Server Components.',
  'cache is only available in React’s Canary and experimental channels. Please ensure you understand the limitations before using cache in production. Learn more about React’s release channels here.',
  'cache lets you cache the result of a data fetch or computation.',
  'Call cache outside of any components to create a version of the function with caching.',
  'When getMetrics is first called with data, getMetrics will call calculateMetrics(data) and store the result in cache. If getMetrics is called again with the same data, it will return the cached result instead of calling calculateMetrics(data) again.',
  'See more examples below.',
  'cache returns a cached version of fn with the same type signature. It does not call fn in the process.',
  'When calling cachedFn with given arguments, it first checks if a cached result exists in the cache. If a cached result exists, it returns the result. If not, it calls fn with the arguments, stores the result in the cache, and returns the result. The only time fn is called is when there is a cache miss.',
  'The optimization of caching return values based on inputs is known as memoization. We refer to the function returned from cache as a memoized function.',
  'Use cache to skip duplicate work.',
  'If the same user object is rendered in both Profile and TeamReport, the two components can share work and only call calculateUserMetrics once for that user.',
  'Assume Profile is rendered first. It will call getUserMetrics, and check if there is a cached result. Since it is the first time getUserMetrics is called with that user, there will be a cache miss. getUserMetrics will then call calculateUserMetrics with that user and write the result to cache.',
  'When TeamReport renders its list of users and reaches the same user object, it will call getUserMetrics and read the result from cache.',
  'To access the same cache, components must call the same memoized function.',
  'In the above example, Precipitation and Temperature each call cache to create a new memoized function with their own cache look-up. If both components render for the same cityData, they will do duplicate work to call calculateWeekReport.',
  'In addition, Temperature creates a new memoized function each time the component is rendered which doesn’t allow for any cache sharing.',
  'To maximize cache hits and reduce work, the two components should call the same memoized function to access the same cache. Instead, define the memoized function in a dedicated module that can be import-ed across components.',
  'Here, both components call the same memoized function exported from ./getWeekReport.js to read and write to the same cache.',
  'To share a snapshot of data between components, call cache with a data-fetching function like fetch. When multiple components make the same data fetch, only one request is made and the data returned is cached and shared across components. All components refer to the same snapshot of data across the server render.',
  'If AnimatedWeatherCard and MinimalWeatherCard both render for the same city, they will receive the same snapshot of data from the memoized function.',
  'If AnimatedWeatherCard and MinimalWeatherCard supply different city arguments to getTemperature, then fetchTemperature will be called twice and each call site will receive different data.',
  'The city acts as a cache key.',
  'Asynchronous rendering is only supported for Server Components.',
  'By caching a long-running data fetch, you can kick off asynchronous work prior to rendering the component.',
  'When rendering Page, the component calls getUser but note that it doesn’t use the returned data. This early getUser call kicks off the asynchronous database query that occurs while Page is doing other computational work and rendering children.',
  'When rendering Profile, we call getUser again. If the initial getUser call has already returned and cached the user data, when Profile asks and waits for this data, it can simply read from the cache without requiring another remote procedure call. If the  initial data request hasn’t been completed, preloading data in this pattern reduces delay in data-fetching.',
  'When evaluating an asynchronous function, you will receive a Promise for that work. The promise holds the state of that work (pending, fulfilled, failed) and its eventual settled result.',
  'In this example, the asynchronous function fetchData returns a promise that is awaiting the fetch.',
  'In calling getData the first time, the promise returned from fetchData is cached. Subsequent look-ups will then return the same promise.',
  'Notice that the first getData call does not await whereas the second does. await is a JavaScript operator that will wait and return the settled result of the promise. The first getData call simply initiates the fetch to cache the promise for the second getData to look-up.',
  'If by the second call the promise is still pending, then await will pause for the result. The optimization is that while we wait on the fetch, React can continue with computational work, thus reducing the wait time for the second call.',
  'If the promise is already settled, either to an error or the fulfilled result, await will return that value immediately. In both outcomes, there is a performance benefit.',
  'React only provides cache access to the memoized function in a component. When calling getUser outside of a component, it will still evaluate the function but not read or update the cache.',
  'This is because cache access is provided through a context which is only accessible from a component.',
  'All mentioned APIs offer memoization but the difference is what they’re intended to memoize, who can access the cache, and when their cache is invalidated.',
  'In general, you should use useMemo for caching a expensive computation in a Client Component across renders. As an example, to memoize a transformation of data within a component.',
  'In this example, App renders two WeatherReports with the same record. Even though both components do the same work, they cannot share work. useMemo’s cache is only local to the component.',
  'However, useMemo does ensure that if App re-renders and the record object doesn’t change, each component instance would skip work and use the memoized value of avgTemp. useMemo will only cache the last computation of avgTemp with the given dependencies.',
  'In general, you should use cache in Server Components to memoize work that can be shared across components.',
  'Re-writing the previous example to use cache, in this case the second instance of WeatherReport will be able to skip duplicate work and read from the same cache as the first WeatherReport. Another difference from the previous example is that cache is also recommended for memoizing data fetches, unlike useMemo which should only be used for computations.',
  'At this time, cache should only be used in Server Components and the cache will be invalidated across server requests.',
  'You should use memo to prevent a component re-rendering if its props are unchanged.',
  'In this example, both MemoWeatherReport components will call calculateAvg when first rendered. However, if App re-renders, with no changes to record, none of the props have changed and MemoWeatherReport will not re-render.',
  'Compared to useMemo, memo memoizes the component render based on props vs. specific computations. Similar to useMemo, the memoized component only caches the last render with the last prop values. Once the props change, the cache invalidates and the component re-renders.',
  'See prior mentioned pitfalls',
  'If none of the above apply, it may be a problem with how React checks if something exists in cache.',
  'If your arguments are not primitives (ex. objects, functions, arrays), ensure you’re passing the same object reference.',
  'When calling a memoized function, React will look up the input arguments to see if a result is already cached. React will use shallow equality of the arguments to determine if there is a cache hit.',
  'In this case the two MapMarkers look like they’re doing the same work and calling calculateNorm with the same value of {x: 10, y: 10, z:10}. Even though the objects contain the same values, they are not the same object reference as each component creates its own props object.',
  'React will call Object.is on the input to verify if there is a cache hit.',
  'One way to address this could be to pass the vector dimensions to calculateNorm. This works because the dimensions themselves are primitives.',
  'Another solution may be to pass the vector object itself as a prop to the component. We’ll need to pass the same object to both component instances.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react/createContext
[
  'Is this page useful?',
  'createContext lets you create a context that components can provide or read.',
  'Call createContext outside of any components to create a context.',
  'See more examples below.',
  'createContext returns a context object.',
  'The context object itself does not hold any information. It represents which context other components read or provide. Typically, you will use SomeContext.Provider in components above to specify the context value, and call useContext(SomeContext) in components below to read it. The context object has a few properties:',
  'Wrap your components into a context provider to specify the value of this context for all components inside:',
  'Before useContext existed, there was an older way to read context:',
  'Although this older way still works, but newly written code should read context with useContext() instead:',
  'Context lets components pass information deep down without explicitly passing props.',
  'Call createContext outside any components to create one or more contexts.',
  'createContext returns a context object. Components can read context by passing it to useContext():',
  'By default, the values they receive will be the default values you have specified when creating the contexts. However, by itself this isn’t useful because the default values never change.',
  'Context is useful because you can provide other, dynamic values from your components:',
  'Now the Page component and any components inside it, no matter how deep, will “see” the passed context values. If the passed context values change, React will re-render the components reading the context as well.',
  'Read more about reading and providing context and see examples.',
  'Often, components in different files will need access to the same context. This is why it’s common to declare contexts in a separate file. Then you can use the export statement to make context available for other files:',
  'Components declared in other files can then use the import statement to read or provide this context:',
  'This works similar to importing and exporting components.',
  'Code like this specifies the default context value:',
  'This value never changes. React only uses this value as a fallback if it can’t find a matching provider above.',
  'To make context change over time, add state and wrap components in a context provider.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react/forwardRef
[
  'Is this page useful?',
  'forwardRef lets your component expose a DOM node to parent component with a ref.',
  'Call forwardRef() to let your component receive a ref and forward it to a child component:',
  'See more examples below.',
  'forwardRef returns a React component that you can render in JSX. Unlike React components defined as plain functions, a component returned by forwardRef is also able to receive a ref prop.',
  'forwardRef accepts a render function as an argument. React calls this function with props and ref:',
  'props: The props passed by the parent component.',
  'ref:  The ref attribute passed by the parent component. The ref can be an object or a function. If the parent component has not passed a ref, it will be null. You should either pass the ref you receive to another component, or pass it to useImperativeHandle.',
  'forwardRef returns a React component that you can render in JSX. Unlike React components defined as plain functions, the component returned by forwardRef is able to take a ref prop.',
  'By default, each component’s DOM nodes are private. However, sometimes it’s useful to expose a DOM node to the parent—for example, to allow focusing it. To opt in, wrap your component definition into forwardRef():',
  'You will receive a ref as the second argument after props. Pass it to the DOM node that you want to expose:',
  'This lets the parent Form component access the <input> DOM node exposed by MyInput:',
  'This Form component passes a ref to MyInput. The MyInput component forwards that ref to the <input> browser tag. As a result, the Form component can access that <input> DOM node and call focus() on it.',
  'Keep in mind that exposing a ref to the DOM node inside your component makes it harder to change your component’s internals later. You will typically expose DOM nodes from reusable low-level components like buttons or text inputs, but you won’t do it for application-level components like an avatar or a comment.',
  'Clicking the button will focus the input. The Form component defines a ref and passes it to the MyInput component. The MyInput component forwards that ref to the browser <input>. This lets the Form component focus the <input>.',
  'Instead of forwarding a ref to a DOM node, you can forward it to your own component like MyInput:',
  'If that MyInput component forwards a ref to its <input>, a ref to FormField will give you that <input>:',
  'The Form component defines a ref and passes it to FormField. The FormField component forwards that ref to MyInput, which forwards it to a browser <input> DOM node. This is how Form accesses that DOM node.',
  'Instead of exposing an entire DOM node, you can expose a custom object, called an imperative handle, with a more constrained set of methods. To do this, you’d need to define a separate ref to hold the DOM node:',
  'Pass the ref you received to useImperativeHandle and specify the value you want to expose to the ref:',
  'If some component gets a ref to MyInput, it will only receive your { focus, scrollIntoView } object instead of the DOM node. This lets you limit the information you expose about your DOM node to the minimum.',
  'Read more about using imperative handles.',
  'Do not overuse refs. You should only use refs for imperative behaviors that you can’t express as props: for example, scrolling to a node, focusing a node, triggering an animation, selecting text, and so on.',
  'If you can express something as a prop, you should not use a ref. For example, instead of exposing an imperative handle like { open, close } from a Modal component, it is better to take isOpen as a prop like <Modal isOpen={isOpen} />. Effects can help you expose imperative behaviors via props.',
  'This usually means that you forgot to actually use the ref that you received.',
  'For example, this component doesn’t do anything with its ref:',
  'To fix it, pass the ref down to a DOM node or another component that can accept a ref:',
  'The ref to MyInput could also be null if some of the logic is conditional:',
  'If showInput is false, then the ref won’t be forwarded to any node, and a ref to MyInput will remain empty. This is particularly easy to miss if the condition is hidden inside another component, like Panel in this example:',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react/lazy
[
  'Is this page useful?',
  'lazy lets you defer loading component’s code until it is rendered for the first time.',
  'Call lazy outside your components to declare a lazy-loaded React component:',
  'See more examples below.',
  'lazy returns a React component you can render in your tree. While the code for the lazy component is still loading, attempting to render it will suspend. Use <Suspense> to display a loading indicator while it’s loading.',
  'load receives no parameters.',
  'You need to return a Promise or some other thenable (a Promise-like object with a then method). It needs to eventually resolve to an object whose .default property is a valid React component type, such as a function, memo, or a forwardRef component.',
  'Usually, you import components with the static import declaration:',
  'To defer loading this component’s code until it’s rendered for the first time, replace this import with:',
  'This code relies on dynamic import(), which might require support from your bundler or framework. Using this pattern requires that the lazy component you’re importing was exported as the default export.',
  'Now that your component’s code loads on demand, you also need to specify what should be displayed while it is loading. You can do this by wrapping the lazy component or any of its parents into a <Suspense> boundary:',
  'In this example, the code for MarkdownPreview won’t be loaded until you attempt to render it. If MarkdownPreview hasn’t loaded yet, Loading will be shown in its place. Try ticking the checkbox:',
  'This demo loads with an artificial delay. The next time you untick and tick the checkbox, Preview will be cached, so there will be no loading state. To see the loading state again, click “Reset” on the sandbox.',
  'Learn more about managing loading states with Suspense.',
  'Do not declare lazy components inside other components:',
  'Instead, always declare them at the top level of your module:',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react/memo
[
  'Is this page useful?',
  'memo lets you skip re-rendering a component when its props are unchanged.',
  'Wrap a component in memo to get a memoized version of that component. This memoized version of your component will usually not be re-rendered when its parent component is re-rendered as long as its props have not changed. But React may still re-render it: memoization is a performance optimization, not a guarantee.',
  'See more examples below.',
  'Component: The component that you want to memoize. The memo does not modify this component, but returns a new, memoized component instead. Any valid React component, including functions and forwardRef components, is accepted.',
  'optional arePropsEqual: A function that accepts two arguments: the component’s previous props, and its new props. It should return true if the old and new props are equal: that is, if the component will render the same output and behave in the same way with the new props as with the old. Otherwise it should return false. Usually, you will not specify this function. By default, React will compare each prop with Object.is.',
  'memo returns a new React component. It behaves the same as the component provided to memo except that React will not always re-render it when its parent is being re-rendered unless its props have changed.',
  'React normally re-renders a component whenever its parent re-renders. With memo, you can create a component that React will not re-render when its parent re-renders so long as its new props are the same as the old props. Such a component is said to be memoized.',
  'To memoize a component, wrap it in memo and use the value that it returns in place of your original component:',
  'A React component should always have pure rendering logic. This means that it must return the same output if its props, state, and context haven’t changed. By using memo, you are telling React that your component complies with this requirement, so React doesn’t need to re-render as long as its props haven’t changed. Even with memo, your component will re-render if its own state changes or if a context that it’s using changes.',
  'In this example, notice that the Greeting component re-renders whenever name is changed (because that’s one of its props), but not when address is changed (because it’s not passed to Greeting as a prop):',
  'You should only rely on memo as a performance optimization. If your code doesn’t work without it, find the underlying problem and fix it first. Then you may add memo to improve performance.',
  'If your app is like this site, and most interactions are coarse (like replacing a page or an entire section), memoization is usually unnecessary. On the other hand, if your app is more like a drawing editor, and most interactions are granular (like moving shapes), then you might find memoization very helpful.',
  'Optimizing with memo  is only valuable when your component re-renders often with the same exact props, and its re-rendering logic is expensive. If there is no perceptible lag when your component re-renders, memo is unnecessary. Keep in mind that memo is completely useless if the props passed to your component are always different, such as if you pass an object or a plain function defined during rendering. This is why you will often need useMemo and useCallback together with memo.',
  'There is no benefit to wrapping a component in memo in other cases. There is no significant harm to doing that either, so some teams choose to not think about individual cases, and memoize as much as possible. The downside of this approach is that code becomes less readable. Also, not all memoization is effective: a single value that’s “always new” is enough to break memoization for an entire component.',
  'In practice, you can make a lot of memoization unnecessary by following a few principles:',
  'If a specific interaction still feels laggy, use the React Developer Tools profiler to see which components would benefit the most from memoization, and add memoization where needed. These principles make your components easier to debug and understand, so it’s good to follow them in any case. In the long term, we’re researching doing granular memoization automatically to solve this once and for all.',
  'Even when a component is memoized, it will still re-render when its own state changes. Memoization only has to do with props that are passed to the component from its parent.',
  'If you set a state variable to its current value, React will skip re-rendering your component even without memo. You may still see your component function being called an extra time, but the result will be discarded.',
  'Even when a component is memoized, it will still re-render when a context that it’s using changes. Memoization only has to do with props that are passed to the component from its parent.',
  'To make your component re-render only when a part of some context changes, split your component in two. Read what you need from the context in the outer component, and pass it down to a memoized child as a prop.',
  'When you use memo, your component re-renders whenever any prop is not shallowly equal to what it was previously. This means that React compares every prop in your component with its previous value using the Object.is comparison. Note that Object.is(3, 3) is true, but Object.is({}, {}) is false.',
  'To get the most out of memo, minimize the times that the props change. For example, if the prop is an object, prevent the parent component from re-creating that object every time by using useMemo:',
  'A better way to minimize props changes is to make sure the component accepts the minimum necessary information in its props. For example, it could accept individual values instead of a whole object:',
  'Even individual values can sometimes be projected to ones that change less frequently. For example, here a component accepts a boolean indicating the presence of a value rather than the value itself:',
  'When you need to pass a function to memoized component, either declare it outside your component so that it never changes, or useCallback to cache its definition between re-renders.',
  'In rare cases it may be infeasible to minimize the props changes of a memoized component. In that case, you can provide a custom comparison function, which React will use to compare the old and new props instead of using shallow equality. This function is passed as a second argument to memo. It should return true only if the new props would result in the same output as the old props; otherwise it should return false.',
  'If you do this, use the Performance panel in your browser developer tools to make sure that your comparison function is actually faster than re-rendering the component. You might be surprised.',
  'When you do performance measurements, make sure that React is running in the production mode.',
  'If you provide a custom arePropsEqual implementation, you must compare every prop, including functions. Functions often close over the props and state of parent components. If you return true when oldProps.onClick !== newProps.onClick, your component will keep “seeing” the props and state from a previous render inside its onClick handler, leading to very confusing bugs.',
  'Avoid doing deep equality checks inside arePropsEqual unless you are 100% sure that the data structure you’re working with has a known limited depth. Deep equality checks can become incredibly slow and can freeze your app for many seconds if someone changes the data structure later.',
  'React compares old and new props by shallow equality: that is, it considers whether each new prop is reference-equal to the old prop. If you create a new object or array each time the parent is re-rendered, even if the individual elements are each the same, React will still consider it to be changed. Similarly, if you create a new function when rendering the parent component, React will consider it to have changed even if the function has the same definition. To avoid this, simplify props or memoize props in the parent component.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react/startTransition
[
  'Is this page useful?',
  'startTransition lets you update the state without blocking the UI.',
  'The startTransition function lets you mark a state update as a transition.',
  'See more examples below.',
  'startTransition does not return anything.',
  'startTransition does not provide a way to track whether a transition is pending. To show a pending indicator while the transition is ongoing, you need useTransition instead.',
  'You can wrap an update into a transition only if you have access to the set function of that state. If you want to start a transition in response to some prop or a custom Hook return value, try useDeferredValue instead.',
  'The function you pass to startTransition must be synchronous. React immediately executes this function, marking all state updates that happen while it executes as transitions. If you try to perform more state updates later (for example, in a timeout), they won’t be marked as transitions.',
  'A state update marked as a transition will be interrupted by other state updates. For example, if you update a chart component inside a transition, but then start typing into an input while the chart is in the middle of a re-render, React will restart the rendering work on the chart component after handling the input state update.',
  'Transition updates can’t be used to control text inputs.',
  'If there are multiple ongoing transitions, React currently batches them together. This is a limitation that will likely be removed in a future release.',
  'You can mark a state update as a transition by wrapping it in a startTransition call:',
  'Transitions let you keep the user interface updates responsive even on slow devices.',
  'With a transition, your UI stays responsive in the middle of a re-render. For example, if the user clicks a tab but then change their mind and click another tab, they can do that without waiting for the first re-render to finish.',
  'startTransition is very similar to useTransition, except that it does not provide the isPending flag to track whether a transition is ongoing. You can call startTransition when useTransition is not available. For example, startTransition works outside components, such as from a data library.',
  'Learn about transitions and see examples on the useTransition page.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react/experimental_taintObjectReference
[
  'Is this page useful?',
  'This API is experimental and is not available in a stable version of React yet.',
  'You can try it by upgrading React packages to the most recent experimental version:',
  'Experimental versions of React may contain bugs. Don’t use them in production.',
  'This API is only available inside React Server Components.',
  'taintObjectReference lets you prevent a specific object instance from being passed to a Client Component like a user object.',
  'To prevent passing a key, hash or token, see taintUniqueValue.',
  'Call taintObjectReference with an object to register it with React as something that should not be allowed to be passed to the Client as is:',
  'See more examples below.',
  'message: The message you want to display if the object gets passed to a Client Component. This message will be displayed as a part of the Error that will be thrown if the object gets passed to a Client Component.',
  'object: The object to be tainted. Functions and class instances can be passed to taintObjectReference as object. Functions and classes are already blocked from being passed to Client Components but the React’s default error message will be replaced by what you defined in message. When a specific instance of a Typed Array is passed to taintObjectReference as object, any other copies of the Typed Array will not be tainted.',
  'experimental_taintObjectReference returns undefined.',
  'Do not rely on just tainting for security. Tainting an object doesn’t prevent leaking of every possible derived value. For example, the clone of a tainted object will create a new untained object. Using data from a tainted object (e.g. {secret: taintedObj.secret}) will create a new value or object that is not tainted. Tainting is a layer of protection; a secure app will have multiple layers of protection, well designed APIs, and isolation patterns.',
  'A Client Component should never accept objects that carry sensitive data. Ideally, the data fetching functions should not expose data that the current user should not have access to. Sometimes mistakes happen during refactoring. To protect against these mistakes happening down the line we can “taint” the user object in our data API.',
  'Now whenever anyone tries to pass this object to a Client Component, an error will be thrown with the passed in error message instead.',
  'If you’re running a Server Components environment that has access to sensitive data, you have to be careful not to pass objects straight through:',
  'Ideally, the getUser should not expose data that the current user should not have access to. To prevent passing the user object to a Client Component down the line we can “taint” the user object:',
  'Now if anyone tries to pass the user object to a Client Component, an error will be thrown with the passed in error message.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react/experimental_taintUniqueValue
[
  'Is this page useful?',
  'This API is experimental and is not available in a stable version of React yet.',
  'You can try it by upgrading React packages to the most recent experimental version:',
  'Experimental versions of React may contain bugs. Don’t use them in production.',
  'This API is only available inside React Server Components.',
  'taintUniqueValue lets you prevent unique values from being passed to Client Components like passwords, keys, or tokens.',
  'To prevent passing an object containing sensitive data, see taintObjectReference.',
  'Call taintUniqueValue with a password, token, key or hash to register it with React as something that should not be allowed to be passed to the Client as is:',
  'See more examples below.',
  'message: The message you want to display if value is passed to a Client Component. This message will be displayed as a part of the Error that will be thrown if value is passed to a Client Component.',
  'lifetime: Any object that indicates how long value should be tainted. value will be blocked from being sent to any Client Component while this object still exists. For example, passing globalThis blocks the value for the lifetime of an app. lifetime is typically an object whose properties contains value.',
  'value: A string, bigint or TypedArray. value must be a unique sequence of characters or bytes with high entropy such as a cryptographic token, private key, hash, or a long password. value will be blocked from being sent to any Client Component.',
  'experimental_taintUniqueValue returns undefined.',
  'To ensure that sensitive information such as passwords, session tokens, or other unique values do not inadvertently get passed to Client Components, the taintUniqueValue function provides a layer of protection. When a value is tainted, any attempt to pass it to a Client Component will result in an error.',
  'The lifetime argument defines the duration for which the value remains tainted. For values that should remain tainted indefinitely, objects like globalThis or process can serve as the lifetime argument. These objects have a lifespan that spans the entire duration of your app’s execution.',
  'If the tainted value’s lifespan is tied to a object, the lifetime should be the object that encapsulates the value. This ensures the tainted value remains protected for the lifetime of the encapsulating object.',
  'In this example, the user object serves as the lifetime argument. If this object gets stored in a global cache or is accessible by another request, the session token remains tainted.',
  'Do not rely solely on tainting for security. Tainting a value doesn’t block every possible derived value. For example, creating a new value by upper casing a tainted string will not taint the new value.',
  'In this example, the constant password is tainted. Then password is used to create a new value uppercasePassword by calling the toUpperCase method on password. The newly created uppercasePassword is not tainted.',
  'Other similar ways of deriving new values from tainted values like concatenating it into a larger string, converting it to base64, or returning a substring create untained values.',
  'Tainting only protects against simple mistakes like explicitly passing secret values to the client. Mistakes in calling the taintUniqueValue like using a global store outside of React, without the corresponding lifetime object, can cause the tainted value to become untainted. Tainting is a layer of protection; a secure app will have multiple layers of protection, well designed APIs, and isolation patterns.',
  'If you’re running a Server Components environment that has access to private keys or passwords such as database passwords, you have to be careful not to pass that to a Client Component.',
  'This example would leak the secret API token to the client. If this API token can be used to access data this particular user shouldn’t have access to, it could lead to a data breach.',
  'Ideally, secrets like this are abstracted into a single helper file that can only be imported by trusted data utilities on the server. The helper can even be tagged with server-only to ensure that this file isn’t imported on the client.',
  'Sometimes mistakes happen during refactoring and not all of your colleagues might know about this.\n' +
    'To protect against this mistakes happening down the line we can “taint” the actual password:',
  'Now whenever anyone tries to pass this password to a Client Component, or send the password to a Client Component with a Server Action, a error will be thrown with message you defined when you called taintUniqueValue.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react/directives
[
  'Is this page useful?',
  'These directives are needed only if you’re using React Server Components or building a library compatible with them.',
  'Directives provide instructions to bundlers compatible with React Server Components.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react/use-client
[
  'Is this page useful?',
  "'use client' is needed only if you’re using React Server Components or building a library compatible with them.",
  "'use client' lets you mark what code runs on the client.",
  "Add 'use client' at the top of a file to mark the module and its transitive dependencies as client code.",
  "When a file marked with 'use client' is imported from a Server Component, compatible bundlers will treat the module import as a boundary between server-run and client-run code.",
  "As dependencies of RichTextEditor, formatDate and Button will also be evaluated on the client regardless of whether their modules contain a 'use client' directive. Note that a single module may be evaluated on the server when imported from server code and on the client when imported from client code.",
  'In a React app, components are often split into separate files, or modules.',
  "For apps that use React Server Components, the app is server-rendered by default. 'use client' introduces a server-client boundary in the module dependency tree, effectively creating a subtree of Client modules.",
  'To better illustrate this, consider the following React Server Components app.',
  "In the module dependency tree of this example app, the 'use client' directive in InspirationGenerator.js marks that module and all of its transitive dependencies as Client modules. The subtree starting at InspirationGenerator.js is now marked as Client modules.",
  "'use client' segments the module dependency tree of the React Server Components app, marking InspirationGenerator.js and all of its dependencies as client-rendered.",
  'During render, the framework will server-render the root component and continue through the render tree, opting-out of evaluating any code imported from client-marked code.',
  'The server-rendered portion of the render tree is then sent to the client. The client, with its client code downloaded, then completes rendering the rest of the tree.',
  'The render tree for the React Server Components app. InspirationGenerator and its child component FancyText are components exported from client-marked code and considered Client Components.',
  'We introduce the following definitions:',
  'Working through the example app, App, FancyText and Copyright are all server-rendered and considered Server Components. As InspirationGenerator.js and its transitive dependencies are marked as client code, the component InspirationGenerator and its child component FancyText are Client Components.',
  'By the above definitions, the component FancyText is both a Server and Client Component, how can that be?',
  'First, let’s clarify that the term “component” is not very precise. Here are just two ways “component” can be understood:',
  'Often, the imprecision is not important when explaining concepts, but in this case it is.',
  'When we talk about Server or Client Components, we are referring to component usages.',
  "Back to the question of FancyText, we see that the component definition does not have a 'use client' directive and it has two usages.",
  "The usage of FancyText as a child of App, marks that usage as a Server Component. When FancyText is imported and called under InspirationGenerator, that usage of FancyText is a Client Component as InspirationGenerator contains a 'use client' directive.",
  'This means that the component definition for FancyText will both be evaluated on the server and also downloaded by the client to render its Client Component usage.',
  'Because Copyright is rendered as a child of the Client Component InspirationGenerator, you might be surprised that it is a Server Component.',
  "Recall that 'use client' defines the boundary between server and client code on the module dependency tree, not the render tree.",
  "'use client' defines the boundary between server and client code on the module dependency tree.",
  "In the module dependency tree, we see that App.js imports and calls Copyright from the Copyright.js module. As Copyright.js does not contain a 'use client' directive, the component usage is rendered on the server. App is rendered on the server as it is the root component.",
  'Client Components can render Server Components because you can pass JSX as props. In this case, InspirationGenerator receives Copyright as children. However, the InspirationGenerator module never directly imports the Copyright module nor calls the component, all of that is done by App. In fact, the Copyright component is fully executed before InspirationGenerator starts rendering.',
  'The takeaway is that a parent-child render relationship between components does not guarantee the same render environment.',
  "With 'use client', you can determine when components are Client Components. As Server Components are default, here is a brief overview of the advantages and limitations to Server Components to determine when you need to mark something as client rendered.",
  'For simplicity, we talk about Server Components, but the same principles apply to all code in your app that is server run.',
  'As in any React app, parent components pass data to child components. As they are rendered in different environments, passing data from a Server Component to a Client Component requires extra consideration.',
  'Prop values passed from a Server Component to Client Component must be serializable.',
  'Serializable props include:',
  'Notably, these are not supported:',
  "As Counter requires both the useState Hook and event handlers to increment or decrement the value, this component must be a Client Component and will require a 'use client' directive at the top.",
  'In contrast, a component that renders UI without interaction will not need to be a Client Component.',
  "For example, Counter’s parent component, CounterContainer, does not require 'use client' as it is not interactive and does not use state. In addition, CounterContainer must be a Server Component as it reads from the local file system on the server, which is possible only in a Server Component.",
  'There are also components that don’t use any server or client-only features and can be agnostic to where they render. In our earlier example, FancyText is one such component.',
  "In this case, we don’t add the 'use client' directive, resulting in FancyText’s output (rather than its source code) to be sent to the browser when referenced from a Server Component. As demonstrated in the earlier Inspirations app example, FancyText is used as both a Server or Client Component, depending on where it is imported and used.",
  'But if FancyText’s HTML output was large relative to its source code (including dependencies), it might be more efficient to force it to always be a Client Component. Components that return a long SVG path string are one case where it may be more efficient to force a component to be a Client Component.',
  'Your React app may use client-specific APIs, such as the browser’s APIs for web storage, audio and video manipulation, and device hardware, among others.',
  'In this example, the component uses DOM APIs to manipulate a canvas element. Since those APIs are only available in the browser, it must be marked as a Client Component.',
  'Often in a React app, you’ll leverage third-party libraries to handle common UI patterns or logic.',
  'These libraries may rely on component Hooks or client APIs. Third-party components that use any of the following React APIs must run on the client:',
  "If these libraries have been updated to be compatible with React Server Components, then they will already include 'use client' markers of their own, allowing you to use them directly from your Server Components. If a library hasn’t been updated, or if a component needs props like event handlers that can only be specified on the client, you may need to add your own Client Component file in between the third-party Client Component and your Server Component where you’d like to use it.",
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react/use-server
[
  'Is this page useful?',
  "'use server' is needed only if you’re using React Server Components or building a library compatible with them.",
  "'use server' marks server-side functions that can be called from client-side code.",
  "Add 'use server' at the top of an async function body to mark the function as callable by the client. We call these functions Server Actions.",
  'When calling a Server Action on the client, it will make a network request to the server that includes a serialized copy of any arguments passed. If the Server Action returns a value, that value will be serialized and returned to the client.',
  "Instead of individually marking functions with 'use server', you can add the directive to the top of a file to mark all exports within that file as Server Actions that can be used anywhere, including imported in client code.",
  'Arguments to Server Actions are fully client-controlled. For security, always treat them as untrusted input, and make sure to validate and escape arguments as appropriate.',
  'In any Server Action, make sure to validate that the logged-in user is allowed to perform that action.',
  'To prevent sending sensitive data from a Server Action, there are experimental taint APIs to prevent unique values and objects from being passed to client code.',
  'See experimental_taintUniqueValue and experimental_taintObjectReference.',
  'As client code calls the Server Action over the network, any arguments passed will need to be serializable.',
  'Here are supported types for Server Action arguments:',
  'Notably, these are not supported:',
  'Supported serializable return values are the same as serializable props for a boundary Client Component.',
  'The most common use case of Server Actions will be calling server functions that mutate data. On the browser, the HTML form element is the traditional approach for a user to submit a mutation. With React Server Components, React introduces first-class support for Server Actions in forms.',
  'Here is a form that allows a user to request a username.',
  'In this example requestUsername is a Server Action passed to a <form>. When a user submits this form, there is a network request to the server function requestUsername. When calling a Server Action in a form, React will supply the form’s FormData as the first argument to the Server Action.',
  'By passing a Server Action to the form action, React can progressively enhance the form. This means that forms can be submitted before the JavaScript bundle is loaded.',
  'In the username request form, there might be the chance that a username is not available. requestUsername should tell us if it fails or not.',
  'To update the UI based on the result of a Server Action while supporting progressive enhancement, use useFormState.',
  'Note that like most Hooks, useFormState can only be called in client code.',
  'Server Actions are exposed server endpoints and can be called anywhere in client code.',
  'When using a Server Action outside of a form, call the Server Action in a transition, which allows you to display a loading indicator, show optimistic state updates, and handle unexpected errors. Forms will automatically wrap Server Actions in transitions.',
  'To read a Server Action return value, you’ll need to await the promise returned.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react-dom/hooks
[
  'Is this page useful?',
  'The react-dom package contains Hooks that are only supported for web applications (which run in the browser DOM environment). These Hooks are not supported in non-browser environments like iOS, Android, or Windows applications. If you are looking for Hooks that are supported in web browsers and other environments see the React Hooks page. This page lists all the Hooks in the react-dom package.',
  'Form Hooks are currently only available in React’s canary and experimental channels. Learn more about React’s release channels here.',
  'Forms let you create interactive controls for submitting information.  To manage forms in your components, use one of these Hooks:',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react-dom/hooks/useFormState
[
  'Is this page useful?',
  'The useFormState Hook is currently only available in React’s Canary and experimental channels. Learn more about release channels here. In addition, you need to use a framework that supports React Server Components to get the full benefit of useFormState.',
  'useFormState is a Hook that allows you to update state based on the result of a form action.',
  'Call useFormState at the top level of your component to create component state that is updated when a form action is invoked. You pass useFormState an existing form action function as well as an initial state, and it returns a new action that you use in your form, along with the latest form state. The latest form state is also passed to the function that you provided.',
  'The form state is the value returned by the action when the form was last submitted. If the form has not yet been submitted, it is the initial state that you pass.',
  'If used with a Server Action, useFormState allows the server’s response from submitting the form to be shown even before hydration has completed.',
  'See more examples below.',
  'useFormState returns an array with exactly two values:',
  'Call useFormState at the top level of your component to access the return value of an action from the last time a form was submitted.',
  'useFormState returns an array with exactly two items:',
  'When the form is submitted, the action function that you provided will be called. Its return value will become the new current state of the form.',
  'The action that you provide will also receive a new first argument, namely the current state of the form. The first time the form is submitted, this will be the initial state you provided, while with subsequent submissions, it will be the return value from the last time the action was called. The rest of the arguments are the same as if useFormState had not been used',
  'To display messages such as an error message or toast that’s returned by a Server Action, wrap the action in a call to useFormState.',
  'When you wrap an action with useFormState, it gets an extra argument as its first argument. The submitted form data is therefore its second argument instead of its first as it would usually be. The new first argument that gets added is the current state of the form.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react-dom/hooks/useFormStatus
[
  'Is this page useful?',
  'The useFormStatus Hook is currently only available in React’s Canary and experimental channels. Learn more about React’s release channels here.',
  'useFormStatus is a Hook that gives you status information of the last form submission.',
  'The useFormStatus Hook provides status information of the last form submission.',
  'To get status information, the Submit component must be rendered within a <form>. The Hook returns information like the pending property which tells you if the form is actively submitting.',
  'In the above example, Submit uses this information to disable <button> presses while the form is submitting.',
  'See more examples below.',
  'useFormStatus does not take any parameters.',
  'A status object with the following properties:',
  'pending: A boolean. If true, this means the parent <form> is pending submission. Otherwise, false.',
  'data: An object implementing the FormData interface that contains the data the parent <form> is submitting. If there is no active submission or no parent <form>, it will be null.',
  "method: A string value of either 'get' or 'post'. This represents whether the parent <form> is submitting with either a GET or POST HTTP method. By default, a <form> will use the GET method and can be specified by the method property.",
  'To display a pending state while a form is submitting, you can call the useFormStatus Hook in a component rendered in a <form> and read the pending property returned.',
  'Here, we use the pending property to indicate the form is submitting.',
  'The useFormStatus Hook only returns status information for a parent <form> and not for any <form> rendered in the same component calling the Hook, or child components.',
  'Instead call useFormStatus from inside a component that is located inside <form>.',
  'You can use the data property of the status information returned from useFormStatus to display what data is being submitted by the user.',
  'Here, we have a form where users can request a username. We can use useFormStatus to display a temporary status message confirming what username they have requested.',
  'useFormStatus will only return status information for a parent <form>.',
  'If the component that calls useFormStatus is not nested in a <form>, status.pending will always return false. Verify useFormStatus is called in a component that is a child of a <form> element.',
  'useFormStatus will not track the status of a <form> rendered in the same component. See Pitfall for more details.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react-dom/components
[
  'Is this page useful?',
  'React supports all of the browser built-in HTML and SVG components.',
  'All of the built-in browser components support some props and events.',
  'This includes React-specific props like ref and dangerouslySetInnerHTML.',
  'These built-in browser components accept user input:',
  'They are special in React because passing the value prop to them makes them controlled.',
  'React supports all built-in browser HTML components. This includes:',
  'Similar to the DOM standard, React uses a camelCase convention for prop names. For example, you’ll write tabIndex instead of tabindex. You can convert existing HTML to JSX with an online converter.',
  'If you render a tag with a dash, like <my-element>, React will assume you want to render a custom HTML element. In React, rendering custom elements works differently from rendering built-in browser tags:',
  'If you render a built-in browser HTML element with an is attribute, it will also be treated as a custom element.',
  'A future version of React will include more comprehensive support for custom elements.',
  'You can try it by upgrading React packages to the most recent experimental version:',
  'Experimental versions of React may contain bugs. Don’t use them in production.',
  'React supports all built-in browser SVG components. This includes:',
  'Similar to the DOM standard, React uses a camelCase convention for prop names. For example, you’ll write tabIndex instead of tabindex. You can convert existing SVG to JSX with an online converter.',
  'Namespaced attributes also have to be written without the colon:',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react-dom/components/common
[
  'Is this page useful?',
  'All built-in browser components, such as <div>, support some common props and events.',
  'See more examples below.',
  'These special React props are supported for all built-in components:',
  'children: A React node (an element, a string, a number, a portal, an empty node like null, undefined and booleans, or an array of other React nodes). Specifies the content inside the component. When you use JSX, you will usually specify the children prop implicitly by nesting tags like <div><span /></div>.',
  "dangerouslySetInnerHTML: An object of the form { __html: '<p>some html</p>' } with a raw HTML string inside. Overrides the innerHTML property of the DOM node and displays the passed HTML inside. This should be used with extreme caution! If the HTML inside isn’t trusted (for example, if it’s based on user data), you risk introducing an XSS vulnerability. Read more about using dangerouslySetInnerHTML.",
  'ref: A ref object from useRef or createRef, or a ref callback function, or a string for legacy refs. Your ref will be filled with the DOM element for this node. Read more about manipulating the DOM with refs.',
  'suppressContentEditableWarning: A boolean. If true, suppresses the warning that React shows for elements that both have children and contentEditable={true} (which normally do not work together). Use this if you’re building a text input library that manages the contentEditable content manually.',
  'suppressHydrationWarning: A boolean. If you use server rendering, normally there is a warning when the server and the client render different content. In some rare cases (like timestamps), it is very hard or impossible to guarantee an exact match. If you set suppressHydrationWarning to true, React will not warn you about mismatches in the attributes and the content of that element. It only works one level deep, and is intended to be used as an escape hatch. Don’t overuse it. Read about suppressing hydration errors.',
  "style: An object with CSS styles, for example { fontWeight: 'bold', margin: 20 }. Similarly to the DOM style property, the CSS property names need to be written as camelCase, for example fontWeight instead of font-weight. You can pass strings or numbers as values. If you pass a number, like width: 100, React will automatically append px (“pixels”) to the value unless it’s a unitless property. We recommend using style only for dynamic styles where you don’t know the style values ahead of time. In other cases, applying plain CSS classes with className is more efficient. Read more about className and style.",
  'These standard DOM props are also supported for all built-in components:',
  'You can also pass custom attributes as props, for example mycustomprop="someValue". This can be useful when integrating with third-party libraries. The custom attribute name must be lowercase and must not start with on. The value will be converted to a string. If you pass null or undefined, the custom attribute will be removed.',
  'These events fire only for the <form> elements:',
  'These events fire only for the <dialog> elements. Unlike browser events, they bubble in React:',
  'These events fire only for the <details> elements. Unlike browser events, they bubble in React:',
  'These events fire for <img>, <iframe>, <object>, <embed>, <link>, and SVG <image> elements. Unlike browser events, they bubble in React:',
  'These events fire for resources like <audio> and <video>. Unlike browser events, they bubble in React:',
  'Instead of a ref object (like the one returned by useRef), you may pass a function to the ref attribute.',
  'See an example of using the ref callback.',
  'When the <div> DOM node is added to the screen, React will call your ref callback with the DOM node as the argument. When that <div> DOM node is removed, React will call your ref callback with null.',
  'React will also call your ref callback whenever you pass a different ref callback. In the above example, (node) => { ... } is a different function on every render. When your component re-renders, the previous function will be called with null as the argument, and the next function will be called with the DOM node.',
  'Do not return anything from the ref callback.',
  'Your event handlers will receive a React event object. It is also sometimes known as a “synthetic event”.',
  'It conforms to the same standard as the underlying DOM events, but fixes some browser inconsistencies.',
  'Some React events do not map directly to the browser’s native events. For example in onMouseLeave, e.nativeEvent will point to a mouseout event. The specific mapping is not part of the public API and may change in the future. If you need the underlying browser event for some reason, read it from e.nativeEvent.',
  'React event objects implement some of the standard Event properties:',
  'Additionally, React event objects provide these properties:',
  'React event objects implement some of the standard Event methods:',
  'Additionally, React event objects provide these methods:',
  'An event handler type for the CSS animation events.',
  'An event handler type for the Clipboard API events.',
  'e: A React event object with these extra ClipboardEvent properties:',
  'An event handler type for the input method editor (IME) events.',
  'An event handler type for the HTML Drag and Drop API events.',
  'e: A React event object with these extra DragEvent properties:',
  'It also includes the inherited MouseEvent properties:',
  'It also includes the inherited UIEvent properties:',
  'An event handler type for the focus events.',
  'See an example.',
  'e: A React event object with these extra FocusEvent properties:',
  'It also includes the inherited UIEvent properties:',
  'An event handler type for generic events.',
  'An event handler type for the onBeforeInput event.',
  'An event handler type for keyboard events.',
  'See an example.',
  'e: A React event object with these extra KeyboardEvent properties:',
  'It also includes the inherited UIEvent properties:',
  'An event handler type for mouse events.',
  'See an example.',
  'e: A React event object with these extra MouseEvent properties:',
  'It also includes the inherited UIEvent properties:',
  'An event handler type for pointer events.',
  'See an example.',
  'e: A React event object with these extra PointerEvent properties:',
  'It also includes the inherited MouseEvent properties:',
  'It also includes the inherited UIEvent properties:',
  'An event handler type for touch events.',
  'e: A React event object with these extra TouchEvent properties:',
  'It also includes the inherited UIEvent properties:',
  'An event handler type for the CSS transition events.',
  'An event handler type for generic UI events.',
  'An event handler type for the onWheel event.',
  'e: A React event object with these extra WheelEvent properties:',
  'It also includes the inherited MouseEvent properties:',
  'It also includes the inherited UIEvent properties:',
  'In React, you specify a CSS class with className. It works like the class attribute in HTML:',
  'Then you write the CSS rules for it in a separate CSS file:',
  'React does not prescribe how you add CSS files. In the simplest case, you’ll add a <link> tag to your HTML. If you use a build tool or a framework, consult its documentation to learn how to add a CSS file to your project.',
  'Sometimes, the style values depend on data. Use the style attribute to pass some styles dynamically:',
  'In the above example, style={{}} is not a special syntax, but a regular {} object inside the style={ } JSX curly braces. We recommend only using the style attribute when your styles depend on JavaScript variables.',
  'To apply CSS classes conditionally, you need to produce the className string yourself using JavaScript.',
  `For example, className={'row ' + (isSelected ? 'selected': '')} will produce either className="row" or className="row selected" depending on whether isSelected is true.`,
  'To make this more readable, you can use a tiny helper library like classnames:',
  'It is especially convenient if you have multiple conditional classes:',
  'Sometimes, you’ll need to get the browser DOM node associated with a tag in JSX. For example, if you want to focus an <input> when a button is clicked, you need to call focus() on the browser <input> DOM node.',
  'To obtain the browser DOM node for a tag, declare a ref and pass it as the ref attribute to that tag:',
  'React will put the DOM node into inputRef.current after it’s been rendered to the screen.',
  'Read more about manipulating DOM with refs and check out more examples.',
  'For more advanced use cases, the ref attribute also accepts a callback function.',
  'You can pass a raw HTML string to an element like so:',
  'This is dangerous. As with the underlying DOM innerHTML property, you must exercise extreme caution! Unless the markup is coming from a completely trusted source, it is trivial to introduce an XSS vulnerability this way.',
  'For example, if you use a Markdown library that converts Markdown to HTML, you trust that its parser doesn’t contain bugs, and the user only sees their own input, you can display the resulting HTML like this:',
  'To see why rendering arbitrary HTML is dangerous, replace the code above with this:',
  'The code embedded in the HTML will run. A hacker could use this security hole to steal user information or to perform actions on their behalf. Only use dangerouslySetInnerHTML with trusted and sanitized data.',
  'This example shows some common mouse events and when they fire.',
  'This example shows some common pointer events and when they fire.',
  'In React, focus events bubble. You can use the currentTarget and relatedTarget to differentiate if the focusing or blurring events originated from outside of the parent element. The example shows how to detect focusing a child, focusing the parent element, and how to detect focus entering or leaving the whole subtree.',
  'This example shows some common keyboard events and when they fire.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react-dom/components/form
[
  'Is this page useful?',
  'React’s extensions to <form> are currently only available in React’s canary and experimental channels. In stable releases of React <form> works only as a built-in browser HTML component. Learn more about React’s release channels here.',
  'The built-in browser <form> component lets you create interactive controls for submitting information.',
  'To create interactive controls for submitting information, render the built-in browser <form> component.',
  'See more examples below.',
  '<form> supports all common element props.',
  'action: a URL or function. When a URL is passed to action the form will behave like the HTML form component. When a function is passed to action the function will handle the form submission. The function passed to action may be async and will be called with a single argument containing the form data of the submitted form. The action prop can be overridden by a formAction attribute on a <button>, <input type="submit">, or <input type="image"> component.',
  'Pass a function to the action prop of form to run the function when the form is submitted. formData will be passed to the function as an argument so you can access the data submitted by the form. This differs from the conventional HTML action, which only accepts URLs.',
  "Render a <form> with an input and submit button. Pass a Server Action (a function marked with 'use server') to the action prop of form to run the function when the form is submitted.",
  'Passing a Server Action to <form action> allow users to submit forms without JavaScript enabled or before the code has loaded. This is beneficial to users who have a slow connection, device, or have JavaScript disabled and is similar to the way forms work when a URL is passed to the action prop.',
  'You can use hidden form fields to provide data to the <form>’s action. The Server Action will be called with the hidden form field data as an instance of FormData.',
  'In lieu of using hidden form fields to provide data to the <form>’s action, you can call the bind method to supply it with extra arguments. This will bind a new argument (productId) to the function in addition to the formData that is passed as a argument to the function.',
  'When <form> is rendered by a Server Component, and a Server Action is passed to the <form>’s action prop, the form is progressively enhanced.',
  'To display a pending state when a form is being submitted, you can call the useFormStatus Hook in a component rendered in a <form> and read the pending property returned.',
  'Here, we use the pending property to indicate the form is submitting.',
  'To learn more about the useFormStatus Hook see the reference documentation.',
  'The useOptimistic Hook provides a way to optimistically update the user interface before a background operation, like a network request, completes. In the context of forms, this technique helps to make apps feel more responsive. When a user submits a form, instead of waiting for the server’s response to reflect the changes, the interface is immediately updated with the expected outcome.',
  'For example, when a user types a message into the form and hits the “Send” button, the useOptimistic Hook allows the message to immediately appear in the list with a “Sending…” label, even before the message is actually sent to a server. This “optimistic” approach gives the impression of speed and responsiveness. The form then attempts to truly send the message in the background. Once the server confirms the message has been received, the “Sending…” label is removed.',
  'In some cases the function called by a <form>’s action prop throw an error. You can handle these errors by wrapping <form> in an Error Boundary. If the function called by a <form>’s action prop throws an error, the fallback for the error boundary will be displayed.',
  'Displaying a form submission error message before the JavaScript bundle loads for progressive enhancement requires that:',
  'useFormState takes two parameters: a Server Action and an initial state. useFormState returns two values, a state variable and an action. The action returned by useFormState should be passed to the action prop of the form. The state variable returned by useFormState can be used to displayed an error message. The value returned by the Server Action passed to useFormState will be used to update the state variable.',
  'Learn more about updating state from a form action with the useFormState docs',
  'Forms can be designed to handle multiple submission actions based on the button pressed by the user. Each button inside a form can be associated with a distinct action or behavior by setting the formAction prop.',
  'When a user taps a specific button, the form is submitted, and a corresponding action, defined by that button’s attributes and action, is executed. For instance, a form might submit an article for review by default but have a separate button with formAction set to save the article as a draft.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react-dom/components/input
[
  'Is this page useful?',
  'The built-in browser <input> component lets you render different kinds of form inputs.',
  'To display an input, render the built-in browser <input> component.',
  'See more examples below.',
  '<input> supports all common element props.',
  'React’s extensions to the formAction prop are currently only available in React’s Canary and experimental channels. In stable releases of React formAction works only as a built-in browser HTML component. Learn more about React’s release channels here.',
  'formAction: A string or function. Overrides the parent <form action> for type="submit" and type="image". When a URL is passed to action the form will behave like a standard HTML form. When a function is passed to formAction the function will handle the form submission. See <form action>.',
  'You can make an input controlled by passing one of these props:',
  'When you pass either of them, you must also pass an onChange handler that updates the passed value.',
  'These <input> props are only relevant for uncontrolled inputs:',
  'These <input> props are relevant both for uncontrolled and controlled inputs:',
  'To display an input, render an <input> component. By default, it will be a text input. You can pass type="checkbox" for a checkbox, type="radio" for a radio button, or one of the other input types.',
  'Typically, you will place every <input> inside a <label> tag. This tells the browser that this label is associated with that input. When the user clicks the label, the browser will automatically focus the input. It’s also essential for accessibility: a screen reader will announce the label caption when the user focuses the associated input.',
  'If you can’t nest <input> into a <label>, associate them by passing the same ID to <input id> and <label htmlFor>. To avoid conflicts between multiple instances of one component, generate such an ID with useId.',
  'You can optionally specify the initial value for any input. Pass it as the defaultValue string for text inputs. Checkboxes and radio buttons should specify the initial value with the defaultChecked boolean instead.',
  'Add a <form> around your inputs with a <button type="submit"> inside. It will call your <form onSubmit> event handler. By default, the browser will send the form data to the current URL and refresh the page. You can override that behavior by calling e.preventDefault(). Read the form data with new FormData(e.target).',
  'Give a name to every <input>, for example <input name="firstName" defaultValue="Taylor" />. The name you specified will be used as a key in the form data, for example { firstName: "Taylor" }.',
  'By default, any <button> inside a <form> will submit it. This can be surprising! If you have your own custom Button React component, consider returning <button type="button"> instead of <button>. Then, to be explicit, use <button type="submit"> for buttons that are supposed to submit the form.',
  'An input like <input /> is uncontrolled. Even if you pass an initial value like <input defaultValue="Initial text" />, your JSX only specifies the initial value. It does not control what the value should be right now.',
  'To render a controlled input, pass the value prop to it (or checked for checkboxes and radios). React will force the input to always have the value you passed. Usually, you would do this by declaring a state variable:',
  'A controlled input makes sense if you needed state anyway—for example, to re-render your UI on every edit:',
  'It’s also useful if you want to offer multiple ways to adjust the input state (for example, by clicking a button):',
  "The value you pass to controlled components should not be undefined or null. If you need the initial value to be empty (such as with the firstName field below), initialize your state variable to an empty string ('').",
  'If you pass value without onChange, it will be impossible to type into the input. When you control an input by passing some value to it, you force it to always have the value you passed. So if you pass a state variable as a value but forget to update that state variable synchronously during the onChange event handler, React will revert the input after every keystroke back to the value that you specified.',
  'When you use a controlled input, you set the state on every keystroke. If the component containing your state re-renders a large tree, this can get slow. There’s a few ways you can optimize re-rendering performance.',
  'For example, suppose you start with a form that re-renders all page content on every keystroke:',
  'Since <PageContent /> doesn’t rely on the input state, you can move the input state into its own component:',
  'This significantly improves performance because now only SignupForm re-renders on every keystroke.',
  'If there is no way to avoid re-rendering (for example, if PageContent depends on the search input’s value), useDeferredValue lets you keep the controlled input responsive even in the middle of a large re-render.',
  'If you render an input with value but no onChange, you will see an error in the console:',
  'As the error message suggests, if you only wanted to specify the initial value, pass defaultValue instead:',
  'If you want to control this input with a state variable, specify an onChange handler:',
  'If the value is intentionally read-only, add a readOnly prop to suppress the error:',
  'If you render a checkbox with checked but no onChange, you will see an error in the console:',
  'As the error message suggests, if you only wanted to specify the initial value, pass defaultChecked instead:',
  'If you want to control this checkbox with a state variable, specify an onChange handler:',
  'You need to read e.target.checked rather than e.target.value for checkboxes.',
  'If the checkbox is intentionally read-only, add a readOnly prop to suppress the error:',
  'If you control an input, you must update its state variable to the input’s value from the DOM during onChange.',
  'You can’t update it to something other than e.target.value (or e.target.checked for checkboxes):',
  'You also can’t update it asynchronously:',
  'To fix your code, update it synchronously to e.target.value:',
  'If this doesn’t fix the problem, it’s possible that the input gets removed and re-added from the DOM on every keystroke. This can happen if you’re accidentally resetting state on every re-render, for example if the input or one of its parents always receives a different key attribute, or if you nest component function definitions (which is not supported and causes the “inner” component to always be considered a different tree).',
  'If you provide a value to the component, it must remain a string throughout its lifetime.',
  'You cannot pass value={undefined} first and later pass value="some string" because React won’t know whether you want the component to be uncontrolled or controlled. A controlled component should always receive a string value, not null or undefined.',
  "If your value is coming from an API or a state variable, it might be initialized to null or undefined. In that case, either set it to an empty string ('') initially, or pass value={someValue ?? ''} to ensure value is a string.",
  'Similarly, if you pass checked to a checkbox, ensure it’s always a boolean.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react-dom/components/option
[
  'Is this page useful?',
  'The built-in browser <option> component lets you render an option inside a <select> box.',
  'The built-in browser <option> component lets you render an option inside a <select> box.',
  'See more examples below.',
  '<option> supports all common element props.',
  'Additionally, <option> supports these props:',
  'Render a <select> with a list of <option> components inside to display a select box. Give each <option> a value representing the data to be submitted with the form.',
  'Read more about displaying a <select> with a list of <option> components.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react-dom/components/progress
[
  'Is this page useful?',
  'The built-in browser <progress> component lets you render a progress indicator.',
  'To display a progress indicator, render the built-in browser <progress> component.',
  'See more examples below.',
  '<progress> supports all common element props.',
  'Additionally, <progress> supports these props:',
  'To display a progress indicator, render a <progress> component. You can pass a number value between 0 and the max value you specify. If you don’t pass a max value, it will assumed to be 1 by default.',
  'If the operation is not ongoing, pass value={null} to put the progress indicator into an indeterminate state.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react-dom/components/select
[
  'Is this page useful?',
  'The built-in browser <select> component lets you render a select box with options.',
  'To display a select box, render the built-in browser <select> component.',
  'See more examples below.',
  '<select> supports all common element props.',
  'You can make a select box controlled by passing a value prop:',
  'When you pass value, you must also pass an onChange handler that updates the passed value.',
  'If your <select> is uncontrolled, you may pass the defaultValue prop instead:',
  'These <select> props are relevant both for uncontrolled and controlled select boxes:',
  'Render a <select> with a list of <option> components inside to display a select box. Give each <option> a value representing the data to be submitted with the form.',
  'Typically, you will place every <select> inside a <label> tag. This tells the browser that this label is associated with that select box. When the user clicks the label, the browser will automatically focus the select box. It’s also essential for accessibility: a screen reader will announce the label caption when the user focuses the select box.',
  'If you can’t nest <select> into a <label>, associate them by passing the same ID to <select id> and <label htmlFor>. To avoid conflicts between multiple instances of one component, generate such an ID with useId.',
  'By default, the browser will select the first <option> in the list. To select a different option by default, pass that <option>’s value as the defaultValue to the <select> element.',
  'Unlike in HTML, passing a selected attribute to an individual <option> is not supported.',
  'Pass multiple={true} to the <select> to let the user select multiple options. In that case, if you also specify defaultValue to choose the initially selected options, it must be an array.',
  'Add a <form> around your select box with a <button type="submit"> inside. It will call your <form onSubmit> event handler. By default, the browser will send the form data to the current URL and refresh the page. You can override that behavior by calling e.preventDefault(). Read the form data with new FormData(e.target).',
  'Give a name to your <select>, for example <select name="selectedFruit" />. The name you specified will be used as a key in the form data, for example { selectedFruit: "orange" }.',
  'If you use <select multiple={true}>, the FormData you’ll read from the form will include each selected value as a separate name-value pair. Look closely at the console logs in the example above.',
  'By default, any <button> inside a <form> will submit it. This can be surprising! If you have your own custom Button React component, consider returning <button type="button"> instead of <button>. Then, to be explicit, use <button type="submit"> for buttons that are supposed to submit the form.',
  'A select box like <select /> is uncontrolled. Even if you pass an initially selected value like <select defaultValue="orange" />, your JSX only specifies the initial value, not the value right now.',
  'To render a controlled select box, pass the value prop to it. React will force the select box to always have the value you passed. Typically, you will control a select box by declaring a state variable:',
  'This is useful if you want to re-render some part of the UI in response to every selection.',
  'If you pass value without onChange, it will be impossible to select an option. When you control a select box by passing some value to it, you force it to always have the value you passed. So if you pass a state variable as a value but forget to update that state variable synchronously during the onChange event handler, React will revert the select box after every keystroke back to the value that you specified.',
  'Unlike in HTML, passing a selected attribute to an individual <option> is not supported.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react-dom/components/textarea
[
  'Is this page useful?',
  'The built-in browser <textarea> component lets you render a multiline text input.',
  'To display a text area, render the built-in browser <textarea> component.',
  'See more examples below.',
  '<textarea> supports all common element props.',
  'You can make a text area controlled by passing a value prop:',
  'When you pass value, you must also pass an onChange handler that updates the passed value.',
  'If your <textarea> is uncontrolled, you may pass the defaultValue prop instead:',
  'These <textarea> props are relevant both for uncontrolled and controlled text areas:',
  'Render <textarea> to display a text area. You can specify its default size with the rows and cols attributes, but by default the user will be able to resize it. To disable resizing, you can specify resize: none in the CSS.',
  'Typically, you will place every <textarea> inside a <label> tag. This tells the browser that this label is associated with that text area. When the user clicks the label, the browser will focus the text area. It’s also essential for accessibility: a screen reader will announce the label caption when the user focuses the text area.',
  'If you can’t nest <textarea> into a <label>, associate them by passing the same ID to <textarea id> and <label htmlFor>. To avoid conflicts between instances of one component, generate such an ID with useId.',
  'You can optionally specify the initial value for the text area. Pass it as the defaultValue string.',
  'Unlike in HTML, passing initial text like <textarea>Some content</textarea> is not supported.',
  'Add a <form> around your textarea with a <button type="submit"> inside. It will call your <form onSubmit> event handler. By default, the browser will send the form data to the current URL and refresh the page. You can override that behavior by calling e.preventDefault(). Read the form data with new FormData(e.target).',
  'Give a name to your <textarea>, for example <textarea name="postContent" />. The name you specified will be used as a key in the form data, for example { postContent: "Your post" }.',
  'By default, any <button> inside a <form> will submit it. This can be surprising! If you have your own custom Button React component, consider returning <button type="button"> instead of <button>. Then, to be explicit, use <button type="submit"> for buttons that are supposed to submit the form.',
  'A text area like <textarea /> is uncontrolled. Even if you pass an initial value like <textarea defaultValue="Initial text" />, your JSX only specifies the initial value, not the value right now.',
  'To render a controlled text area, pass the value prop to it. React will force the text area to always have the value you passed. Typically, you will control a text area by declaring a state variable:',
  'This is useful if you want to re-render some part of the UI in response to every keystroke.',
  'If you pass value without onChange, it will be impossible to type into the text area. When you control an text area by passing some value to it, you force it to always have the value you passed. So if you pass a state variable as a value but forget to update that state variable synchronously during the onChange event handler, React will revert the text area after every keystroke back to the value that you specified.',
  'If you render a text area with value but no onChange, you will see an error in the console:',
  'As the error message suggests, if you only wanted to specify the initial value, pass defaultValue instead:',
  'If you want to control this text area with a state variable, specify an onChange handler:',
  'If the value is intentionally read-only, add a readOnly prop to suppress the error:',
  'If you control a text area, you must update its state variable to the text area’s value from the DOM during onChange.',
  'You can’t update it to something other than e.target.value:',
  'You also can’t update it asynchronously:',
  'To fix your code, update it synchronously to e.target.value:',
  'If this doesn’t fix the problem, it’s possible that the text area gets removed and re-added from the DOM on every keystroke. This can happen if you’re accidentally resetting state on every re-render. For example, this can happen if the text area or one of its parents always receives a different key attribute, or if you nest component definitions (which is not allowed in React and causes the “inner” component to remount on every render).',
  'If you provide a value to the component, it must remain a string throughout its lifetime.',
  'You cannot pass value={undefined} first and later pass value="some string" because React won’t know whether you want the component to be uncontrolled or controlled. A controlled component should always receive a string value, not null or undefined.',
  "If your value is coming from an API or a state variable, it might be initialized to null or undefined. In that case, either set it to an empty string ('') initially, or pass value={someValue ?? ''} to ensure value is a string.",
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react-dom
[
  'Is this page useful?',
  'The react-dom package contains methods that are only supported for the web applications (which run in the browser DOM environment). They are not supported for React Native.',
  'These APIs can be imported from your components. They are rarely used:',
  'The react-dom package provides two additional entry points:',
  'These APIs will be removed in a future major version of React.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react-dom/createPortal
[
  'Is this page useful?',
  'createPortal lets you render some children into a different part of the DOM.',
  'To create a portal, call createPortal, passing some JSX, and the DOM node where it should be rendered:',
  'See more examples below.',
  'A portal only changes the physical placement of the DOM node. In every other way, the JSX you render into a portal acts as a child node of the React component that renders it. For example, the child can access the context provided by the parent tree, and events bubble up from children to parents according to the React tree.',
  'children: Anything that can be rendered with React, such as a piece of JSX (e.g. <div /> or <SomeComponent />), a Fragment (<>...</>), a string or a number, or an array of these.',
  'domNode: Some DOM node, such as those returned by document.getElementById(). The node must already exist. Passing a different DOM node during an update will cause the portal content to be recreated.',
  'optional key: A unique string or number to be used as the portal’s key.',
  'createPortal returns a React node that can be included into JSX or returned from a React component. If React encounters it in the render output, it will place the provided children inside the provided domNode.',
  'Portals let your components render some of their children into a different place in the DOM. This lets a part of your component “escape” from whatever containers it may be in. For example, a component can display a modal dialog or a tooltip that appears above and outside of the rest of the page.',
  'To create a portal, render the result of createPortal with some JSX and the DOM node where it should go:',
  'React will put the DOM nodes for the JSX you passed inside of the DOM node you provided.',
  'Without a portal, the second <p> would be placed inside the parent <div>, but the portal “teleported” it into the document.body:',
  'Notice how the second paragraph visually appears outside the parent <div> with the border. If you inspect the DOM structure with developer tools, you’ll see that the second <p> got placed directly into the <body>:',
  'A portal only changes the physical placement of the DOM node. In every other way, the JSX you render into a portal acts as a child node of the React component that renders it. For example, the child can access the context provided by the parent tree, and events still bubble up from children to parents according to the React tree.',
  'You can use a portal to create a modal dialog that floats above the rest of the page, even if the component that summons the dialog is inside a container with overflow: hidden or other styles that interfere with the dialog.',
  'In this example, the two containers have styles that disrupt the modal dialog, but the one rendered into a portal is unaffected because, in the DOM, the modal is not contained within the parent JSX elements.',
  'It’s important to make sure that your app is accessible when using portals. For instance, you may need to manage keyboard focus so that the user can move the focus in and out of the portal in a natural way.',
  'Follow the WAI-ARIA Modal Authoring Practices when creating modals. If you use a community package, ensure that it is accessible and follows these guidelines.',
  'Portals can be useful if your React root is only part of a static or server-rendered page that isn’t built with React. For example, if your page is built with a server framework like Rails, you can create areas of interactivity within static areas such as sidebars. Compared with having multiple separate React roots, portals let you treat the app as a single React tree with shared state even though its parts render to different parts of the DOM.',
  'You can also use a portal to manage the content of a DOM node that’s managed outside of React. For example, suppose you’re integrating with a non-React map widget and you want to render React content inside a popup. To do this, declare a popupContainer state variable to store the DOM node you’re going to render into:',
  'When you create the third-party widget, store the DOM node returned by the widget so you can render into it:',
  'This lets you use createPortal to render React content into popupContainer once it becomes available:',
  'Here is a complete example you can play with:',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react-dom/flushSync
[
  'Is this page useful?',
  'Using flushSync is uncommon and can hurt the performance of your app.',
  'flushSync lets you force React to flush any updates inside the provided callback synchronously. This ensures that the DOM is updated immediately.',
  'Call flushSync to force React to flush any pending work and update the DOM synchronously.',
  'Most of the time, flushSync can be avoided. Use flushSync as last resort.',
  'See more examples below.',
  'flushSync returns undefined.',
  'When integrating with third-party code such as browser APIs or UI libraries, it may be necessary to force React to flush updates. Use flushSync to force React to flush any state updates inside the callback synchronously:',
  'This ensures that, by the time the next line of code runs, React has already updated the DOM.',
  'Using flushSync is uncommon, and using it often can significantly hurt the performance of your app. If your app only uses React APIs, and does not integrate with third-party libraries, flushSync should be unnecessary.',
  'However, it can be helpful for integrating with third-party code like browser APIs.',
  'Some browser APIs expect results inside of callbacks to be written to the DOM synchronously, by the end of the callback, so the browser can do something with the rendered DOM. In most cases, React handles this for you automatically. But in some cases it may be necessary to force a synchronous update.',
  'For example, the browser onbeforeprint API allows you to change the page immediately before the print dialog opens. This is useful for applying custom print styles that allow the document to display better for printing. In the example below, you use flushSync inside of the onbeforeprint callback to immediately “flush” the React state to the DOM. Then, by the time the print dialog opens, isPrinting displays “yes”:',
  'Without flushSync, the print dialog will display isPrinting as “no”. This is because React batches the updates asynchronously and the print dialog is displayed before the state is updated.',
  'flushSync can significantly hurt performance, and may unexpectedly force pending Suspense boundaries to show their fallback state.',
  'Most of the time, flushSync can be avoided, so use flushSync as a last resort.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react-dom/findDOMNode
[
  'Is this page useful?',
  'This API will be removed in a future major version of React. See the alternatives.',
  'findDOMNode finds the browser DOM node for a React class component instance.',
  'Call findDOMNode to find the browser DOM node for a given React class component instance.',
  'See more examples below.',
  'findDOMNode returns the first closest browser DOM node within the given componentInstance. When a component renders to null, or renders false, findDOMNode returns null. When a component renders to a string, findDOMNode returns a text DOM node containing that value.',
  'A component may return an array or a Fragment with multiple children. In that case findDOMNode, will return the DOM node corresponding to the first non-empty child.',
  'findDOMNode only works on mounted components (that is, components that have been placed in the DOM). If you try to call this on a component that has not been mounted yet (like calling findDOMNode() in render() on a component that has yet to be created), an exception will be thrown.',
  'findDOMNode only returns the result at the time of your call. If a child component renders a different node later, there is no way for you to be notified of this change.',
  'findDOMNode accepts a class component instance, so it can’t be used with function components.',
  'Call findDOMNode with a class component instance (usually, this) to find the DOM node it has rendered.',
  'Here, the input variable will be set to the <input> DOM element. This lets you do something with it. For example, when clicking “Show example” below mounts the input, input.select() selects all text in the input:',
  'Code using findDOMNode is fragile because the connection between the JSX node and the code manipulating the corresponding DOM node is not explicit. For example, try wrapping this <input /> into a <div>:',
  'This will break the code because now, findDOMNode(this) finds the <div> DOM node, but the code expects an <input> DOM node. To avoid these kinds of problems, use createRef to manage a specific DOM node.',
  'In this example, findDOMNode is no longer used. Instead, inputRef = createRef(null) is defined as an instance field on the class. To read the DOM node from it, you can use this.inputRef.current. To attach it to the JSX, you render <input ref={this.inputRef} />. This connects the code using the DOM node to its JSX:',
  'In modern React without class components, the equivalent code would call useRef instead:',
  'Read more about manipulating the DOM with refs.',
  'In this example, findDOMNode(this) finds a DOM node that belongs to another component. The AutoselectingInput renders MyInput, which is your own component that renders a browser <input>.',
  'Notice that calling findDOMNode(this) inside AutoselectingInput still gives you the DOM <input>—even though the JSX for this <input> is hidden inside the MyInput component. This seems convenient for the above example, but it leads to fragile code. Imagine that you wanted to edit MyInput later and add a wrapper <div> around it. This would break the code of AutoselectingInput (which expects to find an <input>).',
  'To replace findDOMNode in this example, the two components need to coordinate:',
  'This version does that, so it no longer needs findDOMNode:',
  'Here is how this code would look like with function components instead of classes:',
  'Sometimes a component needs to know the position and size of its children. This makes it tempting to find the children with findDOMNode(this), and then use DOM methods like getBoundingClientRect for measurements.',
  'There is currently no direct equivalent for this use case, which is why findDOMNode is deprecated but is not yet removed completely from React. In the meantime, you can try rendering a wrapper <div> node around the content as a workaround, and getting a ref to that node. However, extra wrappers can break styling.',
  'This also applies to focusing and scrolling to arbitrary children.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react-dom/hydrate
[
  'Is this page useful?',
  'This API will be removed in a future major version of React.',
  'In React 18, hydrate was replaced by hydrateRoot. Using hydrate in React 18 will warn that your app will behave as if it’s running React 17. Learn more here.',
  'hydrate lets you display React components inside a browser DOM node whose HTML content was previously generated by react-dom/server in React 17 and below.',
  'Call hydrate in React 17 and below to “attach” React to existing HTML that was already rendered by React in a server environment.',
  'React will attach to the HTML that exists inside the domNode, and take over managing the DOM inside it. An app fully built with React will usually only have one hydrate call with its root component.',
  'See more examples below.',
  'reactNode: The “React node” used to render the existing HTML. This will usually be a piece of JSX like <App /> which was rendered with a ReactDOM Server method such as renderToString(<App />) in React 17.',
  'domNode: A DOM element that was rendered as the root element on the server.',
  'optional: callback: A function. If passed, React will call it after your component is hydrated.',
  'hydrate returns null.',
  'Call hydrate to attach a React component into a server-rendered browser DOM node.',
  'Using hydrate() to render a client-only app (an app without server-rendered HTML) is not supported. Use render() (in React 17 and below) or createRoot() (in React 18+) instead.',
  'In React, “hydration” is how React “attaches” to existing HTML that was already rendered by React in a server environment. During hydration, React will attempt to attach event listeners to the existing markup and take over rendering the app on the client.',
  'In apps fully built with React, you will usually only hydrate one “root”, once at startup for your entire app.',
  'Usually you shouldn’t need to call hydrate again or to call it in more places. From this point on, React will be managing the DOM of your application. To update the UI, your components will use state.',
  'For more information on hydration, see the docs for hydrateRoot.',
  'If a single element’s attribute or text content is unavoidably different between the server and the client (for example, a timestamp), you may silence the hydration mismatch warning.',
  'To silence hydration warnings on an element, add suppressHydrationWarning={true}:',
  'This only works one level deep, and is intended to be an escape hatch. Don’t overuse it. Unless it’s text content, React still won’t attempt to patch it up, so it may remain inconsistent until future updates.',
  'If you intentionally need to render something different on the server and the client, you can do a two-pass rendering. Components that render something different on the client can read a state variable like isClient, which you can set to true in an effect:',
  'This way the initial render pass will render the same content as the server, avoiding mismatches, but an additional pass will happen synchronously right after hydration.',
  'This approach makes hydration slower because your components have to render twice. Be mindful of the user experience on slow connections. The JavaScript code may load significantly later than the initial HTML render, so rendering a different UI immediately after hydration may feel jarring to the user.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react-dom/render
[
  'Is this page useful?',
  'This API will be removed in a future major version of React.',
  'In React 18, render was replaced by createRoot. Using render in React 18 will warn that your app will behave as if it’s running React 17. Learn more here.',
  'render renders a piece of JSX (“React node”) into a browser DOM node.',
  'Call render to display a React component inside a browser DOM element.',
  'React will display <App /> in the domNode, and take over managing the DOM inside it.',
  'An app fully built with React will usually only have one render call with its root component.  A page that uses “sprinkles” of React for parts of the page may have as many render calls as needed.',
  'See more examples below.',
  'reactNode: A React node that you want to display. This will usually be a piece of JSX like <App />, but you can also pass a React element constructed with createElement(), a string, a number, null, or undefined.',
  'domNode: A DOM element. React will display the reactNode you pass inside this DOM element. From this moment, React will manage the DOM inside the domNode and update it when your React tree changes.',
  'optional callback: A function. If passed, React will call it after your component is placed into the DOM.',
  'render usually returns null. However, if the reactNode you pass is a class component, then it will return an instance of that component.',
  'In React 18, render was replaced by createRoot. Please use createRoot for React 18 and beyond.',
  'The first time you call render, React will clear all the existing HTML content inside the domNode before rendering the React component into it. If your domNode contains HTML generated by React on the server or during the build, use hydrate() instead, which attaches the event handlers to the existing HTML.',
  'If you call render on the same domNode more than once, React will update the DOM as necessary to reflect the latest JSX you passed. React will decide which parts of the DOM can be reused and which need to be recreated by “matching it up” with the previously rendered tree. Calling render on the same domNode again is similar to calling the set function on the root component: React avoids unnecessary DOM updates.',
  'If your app is fully built with React, you’ll likely have only one render call in your app. (If you use a framework, it might do this call for you.) When you want to render a piece of JSX in a different part of the DOM tree that isn’t a child of your component (for example, a modal or a tooltip), use createPortal instead of render.',
  'Call render to display a React component inside a browser DOM node.',
  'In apps fully built with React, you will usually only do this once at startup—to render the “root” component.',
  'Usually you shouldn’t need to call render again or to call it in more places. From this point on, React will be managing the DOM of your application. To update the UI, your components will use state.',
  'If your page isn’t fully built with React, call render for each top-level piece of UI managed by React.',
  'You can destroy the rendered trees with unmountComponentAtNode().',
  'You can call render more than once on the same DOM node. As long as the component tree structure matches up with what was previously rendered, React will preserve the state. Notice how you can type in the input, which means that the updates from repeated render calls every second are not destructive:',
  'It is uncommon to call render multiple times. Usually, you’ll update state inside your components instead.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react-dom/unmountComponentAtNode
[
  'Is this page useful?',
  'This API will be removed in a future major version of React.',
  'In React 18, unmountComponentAtNode was replaced by root.unmount().',
  'unmountComponentAtNode removes a mounted React component from the DOM.',
  'Call unmountComponentAtNode to remove a mounted React component from the DOM and clean up its event handlers and state.',
  'See more examples below.',
  'unmountComponentAtNode returns true if a component was unmounted and false otherwise.',
  'Call unmountComponentAtNode to remove a mounted React component from a browser DOM node and clean up its event handlers and state.',
  'Occasionally, you may want to “sprinkle” React on an existing page, or a page that is not fully written in React. In those cases, you may need to “stop” the React app, by removing all of the UI, state, and listeners from the DOM node it was rendered to.',
  'In this example, clicking “Render React App” will render a React app. Click “Unmount React App” to destroy it:',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react-dom/client
[
  'Is this page useful?',
  'The react-dom/client APIs let you render React components on the client (in the browser). These APIs are typically used at the top level of your app to initialize your React tree. A framework may call them for you. Most of your components don’t need to import or use them.',
  'React supports all popular browsers, including Internet Explorer 9 and above. Some polyfills are required for older browsers such as IE 9 and IE 10.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react-dom/client/createRoot
[
  'Is this page useful?',
  'createRoot lets you create a root to display React components inside a browser DOM node.',
  'Call createRoot to create a React root for displaying content inside a browser DOM element.',
  'React will create a root for the domNode, and take over managing the DOM inside it. After you’ve created a root, you need to call root.render to display a React component inside of it:',
  'An app fully built with React will usually only have one createRoot call for its root component. A page that uses “sprinkles” of React for parts of the page may have as many separate roots as needed.',
  'See more examples below.',
  'domNode: A DOM element. React will create a root for this DOM element and allow you to call functions on the root, such as render to display rendered React content.',
  'optional options: An object with options for this React root.',
  'createRoot returns an object with two methods: render and unmount.',
  'Call root.render to display a piece of JSX (“React node”) into the React root’s browser DOM node.',
  'React will display <App /> in the root, and take over managing the DOM inside it.',
  'See more examples below.',
  'root.render returns undefined.',
  'The first time you call root.render, React will clear all the existing HTML content inside the React root before rendering the React component into it.',
  'If your root’s DOM node contains HTML generated by React on the server or during the build, use hydrateRoot() instead, which attaches the event handlers to the existing HTML.',
  'If you call render on the same root more than once, React will update the DOM as necessary to reflect the latest JSX you passed. React will decide which parts of the DOM can be reused and which need to be recreated by “matching it up” with the previously rendered tree. Calling render on the same root again is similar to calling the set function on the root component: React avoids unnecessary DOM updates.',
  'Call root.unmount to destroy a rendered tree inside a React root.',
  'An app fully built with React will usually not have any calls to root.unmount.',
  'This is mostly useful if your React root’s DOM node (or any of its ancestors) may get removed from the DOM by some other code. For example, imagine a jQuery tab panel that removes inactive tabs from the DOM. If a tab gets removed, everything inside it (including the React roots inside) would get removed from the DOM as well. In that case, you need to tell React to “stop” managing the removed root’s content by calling root.unmount. Otherwise, the components inside the removed root won’t know to clean up and free up global resources like subscriptions.',
  'Calling root.unmount will unmount all the components in the root and “detach” React from the root DOM node, including removing any event handlers or state in the tree.',
  'root.unmount does not accept any parameters.',
  'root.unmount returns undefined.',
  'Calling root.unmount will unmount all the components in the tree and “detach” React from the root DOM node.',
  'Once you call root.unmount you cannot call root.render again on the same root. Attempting to call root.render on an unmounted root will throw a “Cannot update an unmounted root” error. However, you can create a new root for the same DOM node after the previous root for that node has been unmounted.',
  'If your app is fully built with React, create a single root for your entire app.',
  'Usually, you only need to run this code once at startup. It will:',
  'If your app is fully built with React, you shouldn’t need to create any more roots, or to call root.render again.',
  'From this point on, React will manage the DOM of your entire app. To add more components, nest them inside the App component. When you need to update the UI, each of your components can do this by using state. When you need to display extra content like a modal or a tooltip outside the DOM node, render it with a portal.',
  'When your HTML is empty, the user sees a blank page until the app’s JavaScript code loads and runs:',
  'This can feel very slow! To solve this, you can generate the initial HTML from your components on the server or during the build. Then your visitors can read text, see images, and click links before any of the JavaScript code loads. We recommend using a framework that does this optimization out of the box. Depending on when it runs, this is called server-side rendering (SSR) or static site generation (SSG).',
  'Apps using server rendering or static generation must call hydrateRoot instead of createRoot. React will then hydrate (reuse) the DOM nodes from your HTML instead of destroying and re-creating them.',
  'If your page isn’t fully built with React, you can call createRoot multiple times to create a root for each top-level piece of UI managed by React. You can display different content in each root by calling root.render.',
  'Here, two different React components are rendered into two DOM nodes defined in the index.html file:',
  'You could also create a new DOM node with document.createElement() and add it to the document manually.',
  'To remove the React tree from the DOM node and clean up all the resources used by it, call root.unmount.',
  'This is mostly useful if your React components are inside an app written in a different framework.',
  'You can call render more than once on the same root. As long as the component tree structure matches up with what was previously rendered, React will preserve the state. Notice how you can type in the input, which means that the updates from repeated render calls every second in this example are not destructive:',
  'It is uncommon to call render multiple times. Usually, your components will update state instead.',
  'Make sure you haven’t forgotten to actually render your app into the root:',
  'Until you do that, nothing is displayed.',
  'This error means that whatever you’re passing to createRoot is not a DOM node.',
  'If you’re not sure what’s happening, try logging it:',
  'For example, if domNode is null, it means that getElementById returned null. This will happen if there is no node in the document with the given ID at the time of your call. There may be a few reasons for it:',
  'Another common way to get this error is to write createRoot(<App />) instead of createRoot(domNode).',
  'This error means that whatever you’re passing to root.render is not a React component.',
  'This may happen if you call root.render with Component instead of <Component />:',
  'Or if you pass a function to root.render, instead of the result of calling it:',
  'If your app is server-rendered and includes the initial HTML generated by React, you might notice that creating a root and calling root.render deletes all that HTML, and then re-creates all the DOM nodes from scratch. This can be slower, resets focus and scroll positions, and may lose other user input.',
  'Server-rendered apps must use hydrateRoot instead of createRoot:',
  'Note that its API is different. In particular, usually there will be no further root.render call.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react-dom/client/hydrateRoot
[
  'Is this page useful?',
  'hydrateRoot lets you display React components inside a browser DOM node whose HTML content was previously generated by react-dom/server.',
  'Call hydrateRoot to “attach” React to existing HTML that was already rendered by React in a server environment.',
  'React will attach to the HTML that exists inside the domNode, and take over managing the DOM inside it. An app fully built with React will usually only have one hydrateRoot call with its root component.',
  'See more examples below.',
  'domNode: A DOM element that was rendered as the root element on the server.',
  'reactNode: The “React node” used to render the existing HTML. This will usually be a piece of JSX like <App /> which was rendered with a ReactDOM Server method such as renderToPipeableStream(<App />).',
  'optional options: An object with options for this React root.',
  'hydrateRoot returns an object with two methods: render and unmount.',
  'Call root.render to update a React component inside a hydrated React root for a browser DOM element.',
  'React will update <App /> in the hydrated root.',
  'See more examples below.',
  'root.render returns undefined.',
  'Call root.unmount to destroy a rendered tree inside a React root.',
  'An app fully built with React will usually not have any calls to root.unmount.',
  'This is mostly useful if your React root’s DOM node (or any of its ancestors) may get removed from the DOM by some other code. For example, imagine a jQuery tab panel that removes inactive tabs from the DOM. If a tab gets removed, everything inside it (including the React roots inside) would get removed from the DOM as well. You need to tell React to “stop” managing the removed root’s content by calling root.unmount. Otherwise, the components inside the removed root won’t clean up and free up resources like subscriptions.',
  'Calling root.unmount will unmount all the components in the root and “detach” React from the root DOM node, including removing any event handlers or state in the tree.',
  'root.unmount does not accept any parameters.',
  'root.unmount returns undefined.',
  'Calling root.unmount will unmount all the components in the tree and “detach” React from the root DOM node.',
  'Once you call root.unmount you cannot call root.render again on the root. Attempting to call root.render on an unmounted root will throw a “Cannot update an unmounted root” error.',
  'If your app’s HTML was generated by react-dom/server, you need to hydrate it on the client.',
  'This will hydrate the server HTML inside the browser DOM node with the React component for your app. Usually, you will do it once at startup. If you use a framework, it might do this behind the scenes for you.',
  'To hydrate your app, React will “attach” your components’ logic to the initial generated HTML from the server. Hydration turns the initial HTML snapshot from the server into a fully interactive app that runs in the browser.',
  'You shouldn’t need to call hydrateRoot again or to call it in more places. From this point on, React will be managing the DOM of your application. To update the UI, your components will use state instead.',
  'The React tree you pass to hydrateRoot needs to produce the same output as it did on the server.',
  'This is important for the user experience. The user will spend some time looking at the server-generated HTML before your JavaScript code loads. Server rendering creates an illusion that the app loads faster by showing the HTML snapshot of its output. Suddenly showing different content breaks that illusion. This is why the server render output must match the initial render output on the client.',
  'The most common causes leading to hydration errors include:',
  'React recovers from some hydration errors, but you must fix them like other bugs. In the best case, they’ll lead to a slowdown; in the worst case, event handlers can get attached to the wrong elements.',
  'Apps fully built with React can render the entire document as JSX, including the <html> tag:',
  'To hydrate the entire document, pass the document global as the first argument to hydrateRoot:',
  'If a single element’s attribute or text content is unavoidably different between the server and the client (for example, a timestamp), you may silence the hydration mismatch warning.',
  'To silence hydration warnings on an element, add suppressHydrationWarning={true}:',
  'This only works one level deep, and is intended to be an escape hatch. Don’t overuse it. Unless it’s text content, React still won’t attempt to patch it up, so it may remain inconsistent until future updates.',
  'If you intentionally need to render something different on the server and the client, you can do a two-pass rendering. Components that render something different on the client can read a state variable like isClient, which you can set to true in an Effect:',
  'This way the initial render pass will render the same content as the server, avoiding mismatches, but an additional pass will happen synchronously right after hydration.',
  'This approach makes hydration slower because your components have to render twice. Be mindful of the user experience on slow connections. The JavaScript code may load significantly later than the initial HTML render, so rendering a different UI immediately after hydration may also feel jarring to the user.',
  'After the root has finished hydrating, you can call root.render to update the root React component. Unlike with createRoot, you don’t usually need to do this because the initial content was already rendered as HTML.',
  'If you call root.render at some point after hydration, and the component tree structure matches up with what was previously rendered, React will preserve the state. Notice how you can type in the input, which means that the updates from repeated render calls every second in this example are not destructive:',
  'It is uncommon to call root.render on a hydrated root. Usually, you’ll update state inside one of the components instead.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react-dom/server
[
  'Is this page useful?',
  'The react-dom/server APIs let you render React components to HTML on the server. These APIs are only used on the server at the top level of your app to generate the initial HTML. A framework may call them for you. Most of your components don’t need to import or use them.',
  'These methods are only available in the environments with Node.js Streams:',
  'These methods are only available in the environments with Web Streams, which includes browsers, Deno, and some modern edge runtimes:',
  'These methods can be used in the environments that don’t support streams:',
  'They have limited functionality compared to the streaming APIs.',
  'These APIs will be removed in a future major version of React.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react-dom/server/renderToNodeStream
[
  'Is this page useful?',
  'This API will be removed in a future major version of React. Use renderToPipeableStream instead.',
  'renderToNodeStream renders a React tree to a Node.js Readable Stream.',
  'On the server, call renderToNodeStream to get a Node.js Readable Stream which you can pipe into the response.',
  'On the client, call hydrateRoot to make the server-generated HTML interactive.',
  'See more examples below.',
  'A Node.js Readable Stream that outputs an HTML string.',
  'This method will wait for all Suspense boundaries to complete before returning any output.',
  'As of React 18, this method buffers all of its output, so it doesn’t actually provide any streaming benefits. This is why it’s recommended that you migrate to renderToPipeableStream instead.',
  'The returned stream is a byte stream encoded in utf-8. If you need a stream in another encoding, take a look at a project like iconv-lite, which provides transform streams for transcoding text.',
  'Call renderToNodeStream to get a Node.js Readable Stream which you can pipe to your server response:',
  'The stream will produce the initial non-interactive HTML output of your React components. On the client, you will need to call hydrateRoot to hydrate that server-generated HTML and make it interactive.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react-dom/server/renderToPipeableStream
[
  'Is this page useful?',
  'renderToPipeableStream renders a React tree to a pipeable Node.js Stream.',
  'This API is specific to Node.js. Environments with Web Streams, like Deno and modern edge runtimes, should use renderToReadableStream instead.',
  'Call renderToPipeableStream to render your React tree as HTML into a Node.js Stream.',
  'On the client, call hydrateRoot to make the server-generated HTML interactive.',
  'See more examples below.',
  'reactNode: A React node you want to render to HTML. For example, a JSX element like <App />. It is expected to represent the entire document, so the App component should render the <html> tag.',
  'optional options: An object with streaming options.',
  'renderToPipeableStream returns an object with two methods:',
  'Call renderToPipeableStream to render your React tree as HTML into a Node.js Stream:',
  'Along with the root component, you need to provide a list of bootstrap <script> paths. Your root component should return the entire document including the root <html> tag.',
  'For example, it might look like this:',
  'React will inject the doctype and your bootstrap <script> tags into the resulting HTML stream:',
  'On the client, your bootstrap script should hydrate the entire document with a call to hydrateRoot:',
  'This will attach event listeners to the server-generated HTML and make it interactive.',
  'The final asset URLs (like JavaScript and CSS files) are often hashed after the build. For example, instead of styles.css you might end up with styles.123456.css. Hashing static asset filenames guarantees that every distinct build of the same asset will have a different filename. This is useful because it lets you safely enable long-term caching for static assets: a file with a certain name would never change content.',
  'However, if you don’t know the asset URLs until after the build, there’s no way for you to put them in the source code. For example, hardcoding "/styles.css" into JSX like earlier wouldn’t work. To keep them out of your source code, your root component can read the real filenames from a map passed as a prop:',
  'On the server, render <App assetMap={assetMap} /> and pass your assetMap with the asset URLs:',
  'Since your server is now rendering <App assetMap={assetMap} />, you need to render it with assetMap on the client too to avoid hydration errors. You can serialize and pass assetMap to the client like this:',
  'In the example above, the bootstrapScriptContent option adds an extra inline <script> tag that sets the global window.assetMap variable on the client. This lets the client code read the same assetMap:',
  'Both client and server render App with the same assetMap prop, so there are no hydration errors.',
  'Streaming allows the user to start seeing the content even before all the data has loaded on the server. For example, consider a profile page that shows a cover, a sidebar with friends and photos, and a list of posts:',
  'Imagine that loading data for <Posts /> takes some time. Ideally, you’d want to show the rest of the profile page content to the user without waiting for the posts. To do this, wrap Posts in a <Suspense> boundary:',
  'This tells React to start streaming the HTML before Posts loads its data. React will send the HTML for the loading fallback (PostsGlimmer) first, and then, when Posts finishes loading its data, React will send the remaining HTML along with an inline <script> tag that replaces the loading fallback with that HTML. From the user’s perspective, the page will first appear with the PostsGlimmer, later replaced by the Posts.',
  'You can further nest <Suspense> boundaries to create a more granular loading sequence:',
  'In this example, React can start streaming the page even earlier. Only ProfileLayout and ProfileCover must finish rendering first because they are not wrapped in any <Suspense> boundary. However, if Sidebar, Friends, or Photos need to load some data, React will send the HTML for the BigSpinner fallback instead. Then, as more data becomes available, more content will continue to be revealed until all of it becomes visible.',
  'Streaming does not need to wait for React itself to load in the browser, or for your app to become interactive. The HTML content from the server will get progressively revealed before any of the <script> tags load.',
  'Read more about how streaming HTML works.',
  'Only Suspense-enabled data sources will activate the Suspense component. They include:',
  'Suspense does not detect when data is fetched inside an Effect or event handler.',
  'The exact way you would load data in the Posts component above depends on your framework. If you use a Suspense-enabled framework, you’ll find the details in its data fetching documentation.',
  'Suspense-enabled data fetching without the use of an opinionated framework is not yet supported. The requirements for implementing a Suspense-enabled data source are unstable and undocumented. An official API for integrating data sources with Suspense will be released in a future version of React.',
  'The part of your app outside of any <Suspense> boundaries is called the shell:',
  'It determines the earliest loading state that the user may see:',
  'If you wrap the whole app into a <Suspense> boundary at the root, the shell will only contain that spinner. However, that’s not a pleasant user experience because seeing a big spinner on the screen can feel slower and more annoying than waiting a bit more and seeing the real layout. This is why usually you’ll want to place the <Suspense> boundaries so that the shell feels minimal but complete—like a skeleton of the entire page layout.',
  'The onShellReady callback fires when the entire shell has been rendered. Usually, you’ll start streaming then:',
  'By the time onShellReady fires, components in nested <Suspense> boundaries might still be loading data.',
  'By default, all errors on the server are logged to console. You can override this behavior to log crash reports:',
  'If you provide a custom onError implementation, don’t forget to also log errors to the console like above.',
  'In this example, the shell contains ProfileLayout, ProfileCover, and PostsGlimmer:',
  'If an error occurs while rendering those components, React won’t have any meaningful HTML to send to the client. Override onShellError to send a fallback HTML that doesn’t rely on server rendering as the last resort:',
  'If there is an error while generating the shell, both onError and onShellError will fire. Use onError for error reporting and use onShellError to send the fallback HTML document. Your fallback HTML does not have to be an error page. Instead, you may include an alternative shell that renders your app on the client only.',
  'In this example, the <Posts /> component is wrapped in <Suspense> so it is not a part of the shell:',
  'If an error happens in the Posts component or somewhere inside it, React will try to recover from it:',
  'If retrying rendering Posts on the client also fails, React will throw the error on the client. As with all the errors thrown during rendering, the closest parent error boundary determines how to present the error to the user. In practice, this means that the user will see a loading indicator until it is certain that the error is not recoverable.',
  'If retrying rendering Posts on the client succeeds, the loading fallback from the server will be replaced with the client rendering output. The user will not know that there was a server error. However, the server onError callback and the client onRecoverableError callbacks will fire so that you can get notified about the error.',
  'Streaming introduces a tradeoff. You want to start streaming the page as early as possible so that the user can see the content sooner. However, once you start streaming, you can no longer set the response status code.',
  'By dividing your app into the shell (above all <Suspense> boundaries) and the rest of the content, you’ve already solved a part of this problem. If the shell errors, you’ll get the onShellError callback which lets you set the error status code. Otherwise, you know that the app may recover on the client, so you can send “OK”.',
  'If a component outside the shell (i.e. inside a <Suspense> boundary) throws an error, React will not stop rendering. This means that the onError callback will fire, but you will still get onShellReady instead of onShellError. This is because React will try to recover from that error on the client, as described above.',
  'However, if you’d like, you can use the fact that something has errored to set the status code:',
  'This will only catch errors outside the shell that happened while generating the initial shell content, so it’s not exhaustive. If knowing whether an error occurred for some content is critical, you can move it up into the shell.',
  'You can create your own Error subclasses and use the instanceof operator to check which error is thrown. For example, you can define a custom NotFoundError and throw it from your component. Then your onError, onShellReady, and onShellError callbacks can do something different depending on the error type:',
  'Keep in mind that once you emit the shell and start streaming, you can’t change the status code.',
  'Streaming offers a better user experience because the user can see the content as it becomes available.',
  'However, when a crawler visits your page, or if you’re generating the pages at the build time, you might want to let all of the content load first and then produce the final HTML output instead of revealing it progressively.',
  'You can wait for all the content to load using the onAllReady callback:',
  'A regular visitor will get a stream of progressively loaded content. A crawler will receive the final HTML output after all the data loads. However, this also means that the crawler will have to wait for all data, some of which might be slow to load or error. Depending on your app, you could choose to send the shell to the crawlers too.',
  'You can force the server rendering to “give up” after a timeout:',
  'React will flush the remaining loading fallbacks as HTML, and will attempt to render the rest on the client.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react-dom/server/renderToReadableStream
[
  'Is this page useful?',
  'renderToReadableStream renders a React tree to a Readable Web Stream.',
  'This API depends on Web Streams. For Node.js, use renderToPipeableStream instead.',
  'Call renderToReadableStream to render your React tree as HTML into a Readable Web Stream.',
  'On the client, call hydrateRoot to make the server-generated HTML interactive.',
  'See more examples below.',
  'reactNode: A React node you want to render to HTML. For example, a JSX element like <App />. It is expected to represent the entire document, so the App component should render the <html> tag.',
  'optional options: An object with streaming options.',
  'renderToReadableStream returns a Promise:',
  'The returned stream has an additional property:',
  'Call renderToReadableStream to render your React tree as HTML into a Readable Web Stream:',
  'Along with the root component, you need to provide a list of bootstrap <script> paths. Your root component should return the entire document including the root <html> tag.',
  'For example, it might look like this:',
  'React will inject the doctype and your bootstrap <script> tags into the resulting HTML stream:',
  'On the client, your bootstrap script should hydrate the entire document with a call to hydrateRoot:',
  'This will attach event listeners to the server-generated HTML and make it interactive.',
  'The final asset URLs (like JavaScript and CSS files) are often hashed after the build. For example, instead of styles.css you might end up with styles.123456.css. Hashing static asset filenames guarantees that every distinct build of the same asset will have a different filename. This is useful because it lets you safely enable long-term caching for static assets: a file with a certain name would never change content.',
  'However, if you don’t know the asset URLs until after the build, there’s no way for you to put them in the source code. For example, hardcoding "/styles.css" into JSX like earlier wouldn’t work. To keep them out of your source code, your root component can read the real filenames from a map passed as a prop:',
  'On the server, render <App assetMap={assetMap} /> and pass your assetMap with the asset URLs:',
  'Since your server is now rendering <App assetMap={assetMap} />, you need to render it with assetMap on the client too to avoid hydration errors. You can serialize and pass assetMap to the client like this:',
  'In the example above, the bootstrapScriptContent option adds an extra inline <script> tag that sets the global window.assetMap variable on the client. This lets the client code read the same assetMap:',
  'Both client and server render App with the same assetMap prop, so there are no hydration errors.',
  'Streaming allows the user to start seeing the content even before all the data has loaded on the server. For example, consider a profile page that shows a cover, a sidebar with friends and photos, and a list of posts:',
  'Imagine that loading data for <Posts /> takes some time. Ideally, you’d want to show the rest of the profile page content to the user without waiting for the posts. To do this, wrap Posts in a <Suspense> boundary:',
  'This tells React to start streaming the HTML before Posts loads its data. React will send the HTML for the loading fallback (PostsGlimmer) first, and then, when Posts finishes loading its data, React will send the remaining HTML along with an inline <script> tag that replaces the loading fallback with that HTML. From the user’s perspective, the page will first appear with the PostsGlimmer, later replaced by the Posts.',
  'You can further nest <Suspense> boundaries to create a more granular loading sequence:',
  'In this example, React can start streaming the page even earlier. Only ProfileLayout and ProfileCover must finish rendering first because they are not wrapped in any <Suspense> boundary. However, if Sidebar, Friends, or Photos need to load some data, React will send the HTML for the BigSpinner fallback instead. Then, as more data becomes available, more content will continue to be revealed until all of it becomes visible.',
  'Streaming does not need to wait for React itself to load in the browser, or for your app to become interactive. The HTML content from the server will get progressively revealed before any of the <script> tags load.',
  'Read more about how streaming HTML works.',
  'Only Suspense-enabled data sources will activate the Suspense component. They include:',
  'Suspense does not detect when data is fetched inside an Effect or event handler.',
  'The exact way you would load data in the Posts component above depends on your framework. If you use a Suspense-enabled framework, you’ll find the details in its data fetching documentation.',
  'Suspense-enabled data fetching without the use of an opinionated framework is not yet supported. The requirements for implementing a Suspense-enabled data source are unstable and undocumented. An official API for integrating data sources with Suspense will be released in a future version of React.',
  'The part of your app outside of any <Suspense> boundaries is called the shell:',
  'It determines the earliest loading state that the user may see:',
  'If you wrap the whole app into a <Suspense> boundary at the root, the shell will only contain that spinner. However, that’s not a pleasant user experience because seeing a big spinner on the screen can feel slower and more annoying than waiting a bit more and seeing the real layout. This is why usually you’ll want to place the <Suspense> boundaries so that the shell feels minimal but complete—like a skeleton of the entire page layout.',
  'The async call to renderToReadableStream will resolve to a stream as soon as the entire shell has been rendered. Usually, you’ll start streaming then by creating and returning a response with that stream:',
  'By the time the stream is returned, components in nested <Suspense> boundaries might still be loading data.',
  'By default, all errors on the server are logged to console. You can override this behavior to log crash reports:',
  'If you provide a custom onError implementation, don’t forget to also log errors to the console like above.',
  'In this example, the shell contains ProfileLayout, ProfileCover, and PostsGlimmer:',
  'If an error occurs while rendering those components, React won’t have any meaningful HTML to send to the client. Wrap your renderToReadableStream call in a try...catch to send a fallback HTML that doesn’t rely on server rendering as the last resort:',
  'If there is an error while generating the shell, both onError and your catch block will fire. Use onError for error reporting and use the catch block to send the fallback HTML document. Your fallback HTML does not have to be an error page. Instead, you may include an alternative shell that renders your app on the client only.',
  'In this example, the <Posts /> component is wrapped in <Suspense> so it is not a part of the shell:',
  'If an error happens in the Posts component or somewhere inside it, React will try to recover from it:',
  'If retrying rendering Posts on the client also fails, React will throw the error on the client. As with all the errors thrown during rendering, the closest parent error boundary determines how to present the error to the user. In practice, this means that the user will see a loading indicator until it is certain that the error is not recoverable.',
  'If retrying rendering Posts on the client succeeds, the loading fallback from the server will be replaced with the client rendering output. The user will not know that there was a server error. However, the server onError callback and the client onRecoverableError callbacks will fire so that you can get notified about the error.',
  'Streaming introduces a tradeoff. You want to start streaming the page as early as possible so that the user can see the content sooner. However, once you start streaming, you can no longer set the response status code.',
  'By dividing your app into the shell (above all <Suspense> boundaries) and the rest of the content, you’ve already solved a part of this problem. If the shell errors, your catch block will run which lets you set the error status code. Otherwise, you know that the app may recover on the client, so you can send “OK”.',
  'If a component outside the shell (i.e. inside a <Suspense> boundary) throws an error, React will not stop rendering. This means that the onError callback will fire, but your code will continue running without getting into the catch block. This is because React will try to recover from that error on the client, as described above.',
  'However, if you’d like, you can use the fact that something has errored to set the status code:',
  'This will only catch errors outside the shell that happened while generating the initial shell content, so it’s not exhaustive. If knowing whether an error occurred for some content is critical, you can move it up into the shell.',
  'You can create your own Error subclasses and use the instanceof operator to check which error is thrown. For example, you can define a custom NotFoundError and throw it from your component. Then you can save the error in onError and do something different before returning the response depending on the error type:',
  'Keep in mind that once you emit the shell and start streaming, you can’t change the status code.',
  'Streaming offers a better user experience because the user can see the content as it becomes available.',
  'However, when a crawler visits your page, or if you’re generating the pages at the build time, you might want to let all of the content load first and then produce the final HTML output instead of revealing it progressively.',
  'You can wait for all the content to load by awaiting the stream.allReady Promise:',
  'A regular visitor will get a stream of progressively loaded content. A crawler will receive the final HTML output after all the data loads. However, this also means that the crawler will have to wait for all data, some of which might be slow to load or error. Depending on your app, you could choose to send the shell to the crawlers too.',
  'You can force the server rendering to “give up” after a timeout:',
  'React will flush the remaining loading fallbacks as HTML, and will attempt to render the rest on the client.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react-dom/server/renderToStaticMarkup
[
  'Is this page useful?',
  'renderToStaticMarkup renders a non-interactive React tree to an HTML string.',
  'On the server, call renderToStaticMarkup to render your app to HTML.',
  'It will produce non-interactive HTML output of your React components.',
  'See more examples below.',
  'An HTML string.',
  'renderToStaticMarkup output cannot be hydrated.',
  'renderToStaticMarkup has limited Suspense support. If a component suspends, renderToStaticMarkup immediately sends its fallback as HTML.',
  'renderToStaticMarkup works in the browser, but using it in the client code is not recommended. If you need to render a component to HTML in the browser, get the HTML by rendering it into a DOM node.',
  'Call renderToStaticMarkup to render your app to an HTML string which you can send with your server response:',
  'This will produce the initial non-interactive HTML output of your React components.',
  'This method renders non-interactive HTML that cannot be hydrated.  This is useful if you want to use React as a simple static page generator, or if you’re rendering completely static content like emails.',
  'Interactive apps should use renderToString on the server and hydrateRoot on the client.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react-dom/server/renderToStaticNodeStream
[
  'Is this page useful?',
  'renderToStaticNodeStream renders a non-interactive React tree to a Node.js Readable Stream.',
  'On the server, call renderToStaticNodeStream to get a Node.js Readable Stream.',
  'See more examples below.',
  'The stream will produce non-interactive HTML output of your React components.',
  'A Node.js Readable Stream that outputs an HTML string. The resulting HTML can’t be hydrated on the client.',
  'renderToStaticNodeStream output cannot be hydrated.',
  'This method will wait for all Suspense boundaries to complete before returning any output.',
  'As of React 18, this method buffers all of its output, so it doesn’t actually provide any streaming benefits.',
  'The returned stream is a byte stream encoded in utf-8. If you need a stream in another encoding, take a look at a project like iconv-lite, which provides transform streams for transcoding text.',
  'Call renderToStaticNodeStream to get a Node.js Readable Stream which you can pipe to your server response:',
  'The stream will produce the initial non-interactive HTML output of your React components.',
  'This method renders non-interactive HTML that cannot be hydrated. This is useful if you want to use React as a simple static page generator, or if you’re rendering completely static content like emails.',
  'Interactive apps should use renderToPipeableStream on the server and hydrateRoot on the client.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react-dom/server/renderToString
[
  'Is this page useful?',
  'renderToString does not support streaming or waiting for data. See the alternatives.',
  'renderToString renders a React tree to an HTML string.',
  'On the server, call renderToString to render your app to HTML.',
  'On the client, call hydrateRoot to make the server-generated HTML interactive.',
  'See more examples below.',
  'An HTML string.',
  'renderToString has limited Suspense support. If a component suspends, renderToString immediately sends its fallback as HTML.',
  'renderToString works in the browser, but using it in the client code is not recommended.',
  'Call renderToString to render your app to an HTML string which you can send with your server response:',
  'This will produce the initial non-interactive HTML output of your React components. On the client, you will need to call hydrateRoot to hydrate that server-generated HTML and make it interactive.',
  'renderToString does not support streaming or waiting for data. See the alternatives.',
  'renderToString returns a string immediately, so it does not support streaming or waiting for data.',
  'When possible, we recommend using these fully-featured alternatives:',
  'You can continue using renderToString if your server environment does not support streams.',
  'Sometimes, renderToString is used on the client to convert some component to HTML.',
  'Importing react-dom/server on the client unnecessarily increases your bundle size and should be avoided. If you need to render some component to HTML in the browser, use createRoot and read HTML from the DOM:',
  'The flushSync call is necessary so that the DOM is updated before reading its innerHTML property.',
  'renderToString does not fully support Suspense.',
  'If some component suspends (for example, because it’s defined with lazy or fetches data), renderToString will not wait for its content to resolve. Instead, renderToString will find the closest <Suspense> boundary above it and render its fallback prop in the HTML. The content will not appear until the client code loads.',
  'To solve this, use one of the recommended streaming solutions. They can stream content in chunks as it resolves on the server so that the user sees the page being progressively filled in before the client code loads.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react/legacy
[
  'Is this page useful?',
  'These APIs are exported from the react package, but they are not recommended for use in newly written code. See the linked individual API pages for the suggested alternatives.',
  'These APIs will be removed in a future major version of React.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react/Children
[
  'Is this page useful?',
  'Using Children is uncommon and can lead to fragile code. See common alternatives.',
  'Children lets you manipulate and transform the JSX you received as the children prop.',
  'Call Children.count(children) to count the number of children in the children data structure.',
  'See more examples below.',
  'The number of nodes inside these children.',
  'Call Children.forEach(children, fn, thisArg?) to run some code for each child in the children data structure.',
  'See more examples below.',
  'Children.forEach returns undefined.',
  'Call Children.map(children, fn, thisArg?) to map or transform each child in the children data structure.',
  'See more examples below.',
  'If children is null or undefined, returns the same value.',
  'Otherwise, returns a flat array consisting of the nodes you’ve returned from the fn function. The returned array will contain all nodes you returned except for null and undefined.',
  'Empty nodes (null, undefined, and Booleans), strings, numbers, and React elements count as individual nodes. Arrays don’t count as individual nodes, but their children do. The traversal does not go deeper than React elements: they don’t get rendered, and their children aren’t traversed. Fragments don’t get traversed.',
  'If you return an element or an array of elements with keys from fn, the returned elements’ keys will be automatically combined with the key of the corresponding original item from children. When you return multiple elements from fn in an array, their keys only need to be unique locally amongst each other.',
  'Call Children.only(children) to assert that children represent a single React element.',
  'If children is a valid element, returns that element.',
  'Otherwise, throws an error.',
  'Call Children.toArray(children) to create an array out of the children data structure.',
  'Returns a flat array of elements in children.',
  'To transform the children JSX that your component receives as the children prop, call Children.map:',
  'In the example above, the RowList wraps every child it receives into a <div className="Row"> container. For example, let’s say the parent component passes three <p> tags as the children prop to RowList:',
  'Then, with the RowList implementation above, the final rendered result will look like this:',
  'Children.map is similar to to transforming arrays with map(). The difference is that the children data structure is considered opaque. This means that even if it’s sometimes an array, you should not assume it’s an array or any other particular data type. This is why you should use Children.map if you need to transform it.',
  'In React, the children prop is considered an opaque data structure. This means that you shouldn’t rely on how it is structured. To transform, filter, or count children, you should use the Children methods.',
  'In practice, the children data structure is often represented as an array internally. However, if there is only a single child, then React won’t create an extra array since this would lead to unnecessary memory overhead. As long as you use the Children methods instead of directly introspecting the children prop, your code will not break even if React changes how the data structure is actually implemented.',
  'Even when children is an array, Children.map has useful special behavior. For example, Children.map combines the keys on the returned elements with the keys on the children you’ve passed to it. This ensures the original JSX children don’t “lose” keys even if they get wrapped like in the example above.',
  'The children data structure does not include rendered output of the components you pass as JSX. In the example below, the children received by the RowList only contains two items rather than three:',
  'This is why only two row wrappers are generated in this example:',
  'There is no way to get the rendered output of an inner component like <MoreRows /> when manipulating children. This is why it’s usually better to use one of the alternative solutions.',
  'Call Children.forEach to iterate over each child in the children data structure. It does not return any value and is similar to the array forEach method. You can use it to run custom logic like constructing your own array.',
  'As mentioned earlier, there is no way to get the rendered output of an inner component when manipulating children. This is why it’s usually better to use one of the alternative solutions.',
  'Call Children.count(children) to calculate the number of children.',
  'As mentioned earlier, there is no way to get the rendered output of an inner component when manipulating children. This is why it’s usually better to use one of the alternative solutions.',
  'Call Children.toArray(children) to turn the children data structure into a regular JavaScript array. This lets you manipulate the array with built-in array methods like filter, sort, or reverse.',
  'As mentioned earlier, there is no way to get the rendered output of an inner component when manipulating children. This is why it’s usually better to use one of the alternative solutions.',
  'This section describes alternatives to the Children API (with capital C) that’s imported like this:',
  'Don’t confuse it with using the children prop (lowercase c), which is good and encouraged.',
  'Manipulating children with the Children methods often leads to fragile code. When you pass children to a component in JSX, you don’t usually expect the component to manipulate or transform the individual children.',
  'When you can, try to avoid using the Children methods. For example, if you want every child of RowList to be wrapped in <div className="Row">, export a Row component, and manually wrap every row into it like this:',
  'Unlike using Children.map, this approach does not wrap every child automatically. However, this approach has a significant benefit compared to the earlier example with Children.map because it works even if you keep extracting more components. For example, it still works if you extract your own MoreRows component:',
  'This wouldn’t work with Children.map because it would “see” <MoreRows /> as a single child (and a single row).',
  'You can also explicitly pass an array as a prop. For example, this RowList accepts a rows array as a prop:',
  'Since rows is a regular JavaScript array, the RowList component can use built-in array methods like map on it.',
  'This pattern is especially useful when you want to be able to pass more information as structured data together with children. In the below example, the TabSwitcher component receives an array of objects as the tabs prop:',
  'Unlike passing the children as JSX, this approach lets you associate some extra data like header with each item. Because you are working with the tabs directly, and it is an array, you do not need the Children methods.',
  'Instead of producing JSX for every single item, you can also pass a function that returns JSX, and call that function when necessary. In this example, the App component passes a renderContent function to the TabSwitcher component. The TabSwitcher component calls renderContent only for the selected tab:',
  'A prop like renderContent is called a render prop because it is a prop that specifies how to render a piece of the user interface. However, there is nothing special about it: it is a regular prop which happens to be a function.',
  'Render props are functions, so you can pass information to them. For example, this RowList component passes the id and the index of each row to the renderRow render prop, which uses index to highlight even rows:',
  'This is another example of how parent and child components can cooperate without manipulating the children.',
  'Suppose you pass two children to RowList like this:',
  'If you do Children.count(children) inside RowList, you will get 2. Even if MoreRows renders 10 different items, or if it returns null, Children.count(children) will still be 2. From the RowList’s perspective, it only “sees” the JSX it has received. It does not “see” the internals of the MoreRows component.',
  'The limitation makes it hard to extract a component. This is why alternatives are preferred to using Children.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react/cloneElement
[
  'Is this page useful?',
  'Using cloneElement is uncommon and can lead to fragile code. See common alternatives.',
  'cloneElement lets you create a new React element using another element as a starting point.',
  'Call cloneElement to create a React element based on the element, but with different props and children:',
  'See more examples below.',
  'element: The element argument must be a valid React element. For example, it could be a JSX node like <Something />, the result of calling createElement, or the result of another cloneElement call.',
  'props: The props argument must either be an object or null. If you pass null, the cloned element will retain all of the original element.props. Otherwise, for every prop in the props object, the returned element will “prefer” the value from props over the value from element.props. The rest of the props will be filled from the original element.props. If you pass props.key or props.ref, they will replace the original ones.',
  'optional ...children: Zero or more child nodes. They can be any React nodes, including React elements, strings, numbers, portals, empty nodes (null, undefined, true, and false), and arrays of React nodes. If you don’t pass any ...children arguments, the original element.props.children will be preserved.',
  'cloneElement returns a React element object with a few properties:',
  'Usually, you’ll return the element from your component or make it a child of another element. Although you may read the element’s properties, it’s best to treat every element as opaque after it’s created, and only render it.',
  'Cloning an element does not modify the original element.',
  'You should only pass children as multiple arguments to cloneElement if they are all statically known, like cloneElement(element, null, child1, child2, child3). If your children are dynamic, pass the entire array as the third argument: cloneElement(element, null, listItems). This ensures that React will warn you about missing keys for any dynamic lists. For static lists this is not necessary because they never reorder.',
  'cloneElement makes it harder to trace the data flow, so try the alternatives instead.',
  'To override the props of some React element, pass it to cloneElement with the props you want to override:',
  'Here, the resulting cloned element will be <Row title="Cabbage" isHighlighted={true} />.',
  'Let’s walk through an example to see when it’s useful.',
  'Imagine a List component that renders its children as a list of selectable rows with a “Next” button that changes which row is selected. The List component needs to render the selected Row differently, so it clones every <Row> child that it has received, and adds an extra isHighlighted: true or isHighlighted: false prop:',
  'Let’s say the original JSX received by List looks like this:',
  'By cloning its children, the List can pass extra information to every Row inside. The result looks like this:',
  'Notice how pressing “Next” updates the state of the List, and highlights a different row:',
  'To summarize, the List cloned the <Row /> elements it received and added an extra prop to them.',
  'Cloning children makes it hard to tell how the data flows through your app. Try one of the alternatives.',
  'Instead of using cloneElement, consider accepting a render prop like renderItem. Here, List receives renderItem as a prop. List calls renderItem for every item and passes isHighlighted as an argument:',
  'The renderItem prop is called a “render prop” because it’s a prop that specifies how to render something. For example, you can pass a renderItem implementation that renders a <Row> with the given isHighlighted value:',
  'The end result is the same as with cloneElement:',
  'However, you can clearly trace where the isHighlighted value is coming from.',
  'This pattern is preferred to cloneElement because it is more explicit.',
  'Another alternative to cloneElement is to pass data through context.',
  'For example, you can call createContext to define a HighlightContext:',
  'Your List component can wrap every item it renders into a HighlightContext provider:',
  'With this approach, Row does not need to receive an isHighlighted prop at all. Instead, it reads the context:',
  'This allows the calling component to not know or worry about passing isHighlighted to <Row>:',
  'Instead, List and Row coordinate the highlighting logic through context.',
  'Learn more about passing data through context.',
  'Another approach you can try is to extract the “non-visual” logic into your own Hook, and use the information returned by your Hook to decide what to render. For example, you could write a useList custom Hook like this:',
  'Then you could use it like this:',
  'The data flow is explicit, but the state is inside the useList custom Hook that you can use from any component:',
  'This approach is particularly useful if you want to reuse this logic between different components.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react/Component
[
  'Is this page useful?',
  'We recommend defining components as functions instead of classes. See how to migrate.',
  'Component is the base class for the React components defined as JavaScript classes. Class components are still supported by React, but we don’t recommend using them in new code.',
  'To define a React component as a class, extend the built-in Component class and define a render method:',
  'Only the render method is required, other methods are optional.',
  'See more examples below.',
  'The context of a class component is available as this.context. It is only available if you specify which context you want to receive using static contextType (modern) or static contextTypes (deprecated).',
  'A class component can only read one context at a time.',
  'Reading this.context in class components is equivalent to useContext in function components.',
  'See how to migrate.',
  'The props passed to a class component are available as this.props.',
  'Reading this.props in class components is equivalent to declaring props in function components.',
  'See how to migrate.',
  'This API will be removed in a future major version of React. Use createRef instead.',
  'Lets you access legacy string refs for this component.',
  'The state of a class component is available as this.state. The state field must be an object. Do not mutate the state directly. If you wish to change the state, call setState with the new state.',
  'Defining state in class components is equivalent to calling useState in function components.',
  'See how to migrate.',
  'The constructor runs before your class component mounts (gets added to the screen). Typically, a constructor is only used for two purposes in React. It lets you declare state and bind your class methods to the class instance:',
  'If you use modern JavaScript syntax, constructors are rarely needed. Instead, you can rewrite this code above using the public class field syntax which is supported both by modern browsers and tools like Babel:',
  'A constructor should not contain any side effects or subscriptions.',
  'constructor should not return anything.',
  'Do not run any side effects or subscriptions in the constructor. Instead, use componentDidMount for that.',
  'Inside a constructor, you need to call super(props) before any other statement. If you don’t do that, this.props will be undefined while the constructor runs, which can be confusing and cause bugs.',
  'Constructor is the only place where you can assign this.state directly. In all other methods, you need to use this.setState() instead. Do not call setState in the constructor.',
  'When you use server rendering, the constructor will run on the server too, followed by the render method. However, lifecycle methods like componentDidMount or componentWillUnmount will not run on the server.',
  'When Strict Mode is on, React will call constructor twice in development and then throw away one of the instances. This helps you notice the accidental side effects that need to be moved out of the constructor.',
  'There is no exact equivalent for constructor in function components. To declare state in a function component, call useState. To avoid recalculating the initial state, pass a function to useState.',
  'If you define componentDidCatch, React will call it when some child component (including distant children) throws an error during rendering. This lets you log that error to an error reporting service in production.',
  'Typically, it is used together with static getDerivedStateFromError which lets you update state in response to an error and display an error message to the user. A component with these methods is called an error boundary.',
  'See an example.',
  'error: The error that was thrown. In practice, it will usually be an instance of Error but this is not guaranteed because JavaScript allows to throw any value, including strings or even null.',
  'info: An object containing additional information about the error. Its componentStack field contains a stack trace with the component that threw, as well as the names and source locations of all its parent components. In production, the component names will be minified. If you set up production error reporting, you can decode the component stack using sourcemaps the same way as you would do for regular JavaScript error stacks.',
  'componentDidCatch should not return anything.',
  'In the past, it was common to call setState inside componentDidCatch in order to update the UI and display the fallback error message. This is deprecated in favor of defining static getDerivedStateFromError.',
  "Production and development builds of React slightly differ in the way componentDidCatch handles errors. In development, the errors will bubble up to window, which means that any window.onerror or window.addEventListener('error', callback) will intercept the errors that have been caught by componentDidCatch. In production, instead, the errors will not bubble up, which means any ancestor error handler will only receive errors not explicitly caught by componentDidCatch.",
  'There is no direct equivalent for componentDidCatch in function components yet. If you’d like to avoid creating class components, write a single ErrorBoundary component like above and use it throughout your app. Alternatively, you can use the react-error-boundary package which does that for you.',
  'If you define the componentDidMount method, React will call it when your component is added (mounted) to the screen. This is a common place to start data fetching, set up subscriptions, or manipulate the DOM nodes.',
  'If you implement componentDidMount, you usually need to implement other lifecycle methods to avoid bugs. For example, if componentDidMount reads some state or props, you also have to implement componentDidUpdate to handle their changes, and componentWillUnmount to clean up whatever componentDidMount was doing.',
  'See more examples.',
  'componentDidMount does not take any parameters.',
  'componentDidMount should not return anything.',
  'When Strict Mode is on, in development React will call componentDidMount, then immediately call componentWillUnmount, and then call componentDidMount again. This helps you notice if you forgot to implement componentWillUnmount or if its logic doesn’t fully “mirror” what componentDidMount does.',
  'Although you may call setState immediately in componentDidMount, it’s best to avoid that when you can. It will trigger an extra rendering, but it will happen before the browser updates the screen. This guarantees that even though the render will be called twice in this case, the user won’t see the intermediate state. Use this pattern with caution because it often causes performance issues. In most cases, you should be able to assign the initial state in the constructor instead. It can, however, be necessary for cases like modals and tooltips when you need to measure a DOM node before rendering something that depends on its size or position.',
  'For many use cases, defining componentDidMount, componentDidUpdate, and componentWillUnmount together in class components is equivalent to calling useEffect in function components. In the rare cases where it’s important for the code to run before browser paint, useLayoutEffect is a closer match.',
  'See how to migrate.',
  'If you define the componentDidUpdate method, React will call it immediately after your component has been re-rendered with updated props or state.  This method is not called for the initial render.',
  'You can use it to manipulate the DOM after an update. This is also a common place to do network requests as long as you compare the current props to previous props (e.g. a network request may not be necessary if the props have not changed). Typically, you’d use it together with componentDidMount and componentWillUnmount:',
  'See more examples.',
  'prevProps: Props before the update. Compare prevProps to this.props to determine what changed.',
  'prevState: State before the update. Compare prevState to this.state to determine what changed.',
  'snapshot: If you implemented getSnapshotBeforeUpdate, snapshot will contain the value you returned from that method. Otherwise, it will be undefined.',
  'componentDidUpdate should not return anything.',
  'componentDidUpdate will not get called if shouldComponentUpdate is defined and returns false.',
  'The logic inside componentDidUpdate should usually be wrapped in conditions comparing this.props with prevProps, and this.state with prevState. Otherwise, there’s a risk of creating infinite loops.',
  'Although you may call setState immediately in componentDidUpdate, it’s best to avoid that when you can. It will trigger an extra rendering, but it will happen before the browser updates the screen. This guarantees that even though the render will be called twice in this case, the user won’t see the intermediate state. This pattern often causes performance issues, but it may be necessary for rare cases like modals and tooltips when you need to measure a DOM node before rendering something that depends on its size or position.',
  'For many use cases, defining componentDidMount, componentDidUpdate, and componentWillUnmount together in class components is equivalent to calling useEffect in function components. In the rare cases where it’s important for the code to run before browser paint, useLayoutEffect is a closer match.',
  'See how to migrate.',
  'This API has been renamed from componentWillMount to UNSAFE_componentWillMount. The old name has been deprecated. In a future major version of React, only the new name will work.',
  'Run the rename-unsafe-lifecycles codemod to automatically update your components.',
  'This API has been renamed from componentWillReceiveProps to UNSAFE_componentWillReceiveProps. The old name has been deprecated. In a future major version of React, only the new name will work.',
  'Run the rename-unsafe-lifecycles codemod to automatically update your components.',
  'This API has been renamed from componentWillUpdate to UNSAFE_componentWillUpdate. The old name has been deprecated. In a future major version of React, only the new name will work.',
  'Run the rename-unsafe-lifecycles codemod to automatically update your components.',
  'If you define the componentWillUnmount method, React will call it before your component is removed (unmounted) from the screen. This is a common place to cancel data fetching or remove subscriptions.',
  'The logic inside componentWillUnmount should “mirror” the logic inside componentDidMount. For example, if componentDidMount sets up a subscription, componentWillUnmount should clean up that subscription. If the cleanup logic in your componentWillUnmount reads some props or state, you will usually also need to implement componentDidUpdate to clean up resources (such as subscriptions) corresponding to the old props and state.',
  'See more examples.',
  'componentWillUnmount does not take any parameters.',
  'componentWillUnmount should not return anything.',
  'For many use cases, defining componentDidMount, componentDidUpdate, and componentWillUnmount together in class components is equivalent to calling useEffect in function components. In the rare cases where it’s important for the code to run before browser paint, useLayoutEffect is a closer match.',
  'See how to migrate.',
  'Forces a component to re-render.',
  'Usually, this is not necessary. If your component’s render method only reads from this.props, this.state, or this.context, it will re-render automatically when you call setState inside your component or one of its parents. However, if your component’s render method reads directly from an external data source, you have to tell React to update the user interface when that data source changes. That’s what forceUpdate lets you do.',
  'Try to avoid all uses of forceUpdate and only read from this.props and this.state in render.',
  'forceUpdate does not return anything.',
  'Reading an external data source and forcing class components to re-render in response to its changes with forceUpdate has been superseded by useSyncExternalStore in function components.',
  'This API will be removed in a future major version of React. Use Context.Provider instead.',
  'Lets you specify the values for the legacy context is provided by this component.',
  'If you implement getSnapshotBeforeUpdate, React will call it immediately before React updates the DOM. It enables your component to capture some information from the DOM (e.g. scroll position) before it is potentially changed. Any value returned by this lifecycle method will be passed as a parameter to componentDidUpdate.',
  'For example, you can use it in a UI like a chat thread that needs to preserve its scroll position during updates:',
  'In the above example, it is important to read the scrollHeight property directly in getSnapshotBeforeUpdate. It is not safe to read it in render, UNSAFE_componentWillReceiveProps, or UNSAFE_componentWillUpdate because there is a potential time gap between these methods getting called and React updating the DOM.',
  'prevProps: Props before the update. Compare prevProps to this.props to determine what changed.',
  'prevState: State before the update. Compare prevState to this.state to determine what changed.',
  'You should return a snapshot value of any type that you’d like, or null. The value you returned will be passed as the third argument to componentDidUpdate.',
  'At the moment, there is no equivalent to getSnapshotBeforeUpdate for function components. This use case is very uncommon, but if you have the need for it, for now you’ll have to write a class component.',
  'The render method is the only required method in a class component.',
  'The render method should specify what you want to appear on the screen, for example:',
  'React may call render at any moment, so you shouldn’t assume that it runs at a particular time. Usually, the render method should return a piece of JSX, but a few other return types (like strings) are supported. To calculate the returned JSX, the render method can read this.props, this.state, and this.context.',
  'You should write the render method as a pure function, meaning that it should return the same result if props, state, and context are the same. It also shouldn’t contain side effects (like setting up subscriptions) or interact with the browser APIs. Side effects should happen either in event handlers or methods like componentDidMount.',
  'render does not take any parameters.',
  'render can return any valid React node. This includes React elements such as <div />, strings, numbers, portals, empty nodes (null, undefined, true, and false), and arrays of React nodes.',
  'render should be written as a pure function of props, state, and context. It should not have side effects.',
  'render will not get called if shouldComponentUpdate is defined and returns false.',
  'When Strict Mode is on, React will call render twice in development and then throw away one of the results. This helps you notice the accidental side effects that need to be moved out of the render method.',
  'There is no one-to-one correspondence between the render call and the subsequent componentDidMount or componentDidUpdate call. Some of the render call results may be discarded by React when it’s beneficial.',
  'Call setState to update the state of your React component.',
  'setState enqueues changes to the component state. It tells React that this component and its children need to re-render with the new state. This is the main way you’ll update the user interface in response to interactions.',
  'Calling setState does not change the current state in the already executing code:',
  'It only affects what this.state will return starting from the next render.',
  'You can also pass a function to setState. It lets you update state based on the previous state:',
  ... 109 more items
]
URL:  https://react.dev/reference/react/createElement
[
  'Is this page useful?',
  'createElement lets you create a React element. It serves as an alternative to writing JSX.',
  'Call createElement to create a React element with the given type, props, and children.',
  'See more examples below.',
  "type: The type argument must be a valid React component type. For example, it could be a tag name string (such as 'div' or 'span'), or a React component (a function, a class, or a special component like Fragment).",
  'props: The props argument must either be an object or null. If you pass null, it will be treated the same as an empty object. React will create an element with props matching the props you have passed. Note that ref and key from your props object are special and will not be available as element.props.ref and element.props.key on the returned element. They will be available as element.ref and element.key.',
  'optional ...children: Zero or more child nodes. They can be any React nodes, including React elements, strings, numbers, portals, empty nodes (null, undefined, true, and false), and arrays of React nodes.',
  'createElement returns a React element object with a few properties:',
  'Usually, you’ll return the element from your component or make it a child of another element. Although you may read the element’s properties, it’s best to treat every element as opaque after it’s created, and only render it.',
  'You must treat React elements and their props as immutable and never change their contents after creation. In development, React will freeze the returned element and its props property shallowly to enforce this.',
  "When you use JSX, you must start a tag with a capital letter to render your own custom component. In other words, <Something /> is equivalent to createElement(Something), but <something /> (lowercase) is equivalent to createElement('something') (note it’s a string, so it will be treated as a built-in HTML tag).",
  "You should only pass children as multiple arguments to createElement if they are all statically known, like createElement('h1', {}, child1, child2, child3). If your children are dynamic, pass the entire array as the third argument: createElement('ul', {}, listItems). This ensures that React will warn you about missing keys for any dynamic lists. For static lists this is not necessary because they never reorder.",
  'If you don’t like JSX or can’t use it in your project, you can use createElement as an alternative.',
  'To create an element without JSX, call createElement with some type, props, and children:',
  'The children are optional, and you can pass as many as you need (the example above has three children). This code will display a <h1> header with a greeting. For comparison, here is the same example rewritten with JSX:',
  "To render your own React component, pass a function like Greeting as the type instead of a string like 'h1':",
  'With JSX, it would look like this:',
  'Here is a complete example written with createElement:',
  'And here is the same example written using JSX:',
  'Both coding styles are fine, so you can use whichever one you prefer for your project. The main benefit of using JSX compared to createElement is that it’s easy to see which closing tag corresponds to which opening tag.',
  `An element is a lightweight description of a piece of the user interface. For example, both <Greeting name="Taylor" /> and createElement(Greeting, { name: 'Taylor' }) produce an object like this:`,
  'Note that creating this object does not render the Greeting component or create any DOM elements.',
  'A React element is more like a description—an instruction for React to later render the Greeting component. By returning this object from your App component, you tell React what to do next.',
  'Creating elements is extremely cheap so you don’t need to try to optimize or avoid it.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react/createFactory
[
  'Is this page useful?',
  'This API will be removed in a future major version of React. See the alternatives.',
  'createFactory lets you create a function that produces React elements of a given type.',
  'Call createFactory(type) to create a factory function which produces React elements of a given type.',
  'Then you can use it to create React elements without JSX:',
  'See more examples below.',
  'Returns a factory function. That factory function receives a props object as the first argument, followed by a list of ...children arguments, and returns a React element with the given type, props and children.',
  'Although most React projects use JSX to describe the user interface, JSX is not required. In the past, createFactory used to be one of the ways you could describe the user interface without JSX.',
  "Call createFactory to create a factory function for a specific element type like 'button':",
  'Calling that factory function will produce React elements with the props and children you have provided:',
  'This is how createFactory was used as an alternative to JSX. However, createFactory is deprecated, and you should not call createFactory in any new code. See how to migrate away from createFactory below.',
  'If your project has many createFactory calls, copy this createFactory.js implementation into your project:',
  'This lets you keep all of your code unchanged except the imports.',
  'If you have a few createFactory calls that you don’t mind porting manually, and you don’t want to use JSX, you can replace every call a factory function with a createElement call. For example, you can replace this code:',
  'with this code:',
  'Here is a complete example of using React without JSX:',
  'Finally, you can use JSX instead of createFactory. This is the most common way to use React:',
  "Sometimes, your existing code might pass some variable as a type instead of a constant like 'button':",
  'To do the same in JSX, you need to rename your variable to start with an uppercase letter like Type:',
  'Otherwise React will interpret <type> as a built-in HTML tag because it is lowercase.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react/createRef
[
  'Is this page useful?',
  'createRef is mostly used for class components. Function components typically rely on useRef instead.',
  'createRef creates a ref object which can contain arbitrary value.',
  'Call createRef to declare a ref inside a class component.',
  'See more examples below.',
  'createRef takes no parameters.',
  'createRef returns an object with a single property:',
  'To declare a ref inside a class component, call createRef and assign its result to a class field:',
  'If you now pass ref={this.inputRef} to an <input> in your JSX, React will populate this.inputRef.current with the input DOM node. For example, here is how you make a button that focuses the input:',
  'createRef is mostly used for class components. Function components typically rely on useRef instead.',
  'We recommend using function components instead of class components in new code. If you have some existing class components using createRef, here is how you can convert them. This is the original code:',
  'When you convert this component from a class to a function, replace calls to createRef with calls to useRef:',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react/isValidElement
[
  'Is this page useful?',
  'isValidElement checks whether a value is a React element.',
  'Call isValidElement(value) to check whether value is a React element.',
  'See more examples below.',
  'isValidElement returns true if the value is a React element. Otherwise, it returns false.',
  'Call isValidElement to check if some value is a React element.',
  'React elements are:',
  'For React elements, isValidElement returns true:',
  'Any other values, such as strings, numbers, or arbitrary objects and arrays, are not React elements.',
  'For them, isValidElement returns false:',
  'It is very uncommon to need isValidElement. It’s mostly useful if you’re calling another API that only accepts elements (like cloneElement does) and you want to avoid an error when your argument is not a React element.',
  'Unless you have some very specific reason to add an isValidElement check, you probably don’t need it.',
  'When you write a component, you can return any kind of React node from it:',
  'A React node can be:',
  'Note isValidElement checks whether the argument is a React element, not whether it’s a React node. For example, 42 is not a valid React element. However, it is a perfectly valid React node:',
  'This is why you shouldn’t use isValidElement as a way to check whether something can be rendered.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react/PureComponent
[
  'Is this page useful?',
  'We recommend defining components as functions instead of classes. See how to migrate.',
  'PureComponent is similar to Component but it skips re-renders for same props and state. Class components are still supported by React, but we don’t recommend using them in new code.',
  'To skip re-rendering a class component for same props and state, extend PureComponent instead of Component:',
  'PureComponent is a subclass of Component and supports all the Component APIs. Extending PureComponent is equivalent to defining a custom shouldComponentUpdate method that shallowly compares props and state.',
  'See more examples below.',
  'React normally re-renders a component whenever its parent re-renders. As an optimization, you can create a component that React will not re-render when its parent re-renders so long as its new props and state are the same as the old props and state. Class components can opt into this behavior by extending PureComponent:',
  'A React component should always have pure rendering logic. This means that it must return the same output if its props, state, and context haven’t changed. By using PureComponent, you are telling React that your component complies with this requirement, so React doesn’t need to re-render as long as its props and state haven’t changed. However, your component will still re-render if a context that it’s using changes.',
  'In this example, notice that the Greeting component re-renders whenever name is changed (because that’s one of its props), but not when address is changed (because it’s not passed to Greeting as a prop):',
  'We recommend defining components as functions instead of classes. See how to migrate.',
  'We recommend using function components instead of class components in new code. If you have some existing class components using PureComponent, here is how you can convert them. This is the original code:',
  'When you convert this component from a class to a function, wrap it in memo:',
  'Unlike PureComponent, memo does not compare the new and the old state. In function components, calling the set function with the same state already prevents re-renders by default, even without memo.',
  'How do you like these docs?'
]
URL:  https://react.dev/blog/2022/03/08/react-18-upgrade-guide
[
  'March 08, 2022 by Rick Hanlon',
  'As we shared in the release post, React 18 introduces features powered by our new concurrent renderer, with a gradual adoption strategy for existing applications. In this post, we will guide you through the steps for upgrading to React 18.',
  'Please report any issues you encounter while upgrading to React 18.',
  'For React Native users, React 18 will ship in a future version of React Native. This is because React 18 relies on the New React Native Architecture to benefit from the new capabilities presented in this blogpost. For more information, see the React Conf keynote here.',
  'To install the latest version of React:',
  'Or if you’re using yarn:',
  'When you first install React 18, you will see a warning in the console:',
  'React 18 introduces a new root API which provides better ergonomics for managing roots. The new root API also enables the new concurrent renderer, which allows you to opt-into concurrent features.',
  'We’ve also changed unmountComponentAtNode to root.unmount:',
  'We’ve also removed the callback from render, since it usually does not have the expected result when using Suspense:',
  'There is no one-to-one replacement for the old render callback API — it depends on your use case. See the working group post for Replacing render with createRoot for more information.',
  'Finally, if your app uses server-side rendering with hydration, upgrade hydrate to hydrateRoot:',
  'For more information, see the working group discussion here.',
  'If your app doesn’t work after upgrading, check whether it’s wrapped in <StrictMode>. Strict Mode has gotten stricter in React 18, and not all your components may be resilient to the new checks it adds in development mode. If removing Strict Mode fixes your app, you can remove it during the upgrade, and then add it back (either at the top or for a part of the tree) after you fix the issues that it’s pointing out.',
  'In this release, we’re revamping our react-dom/server APIs to fully support Suspense on the server and Streaming SSR. As part of these changes, we’re deprecating the old Node streaming API, which does not support incremental Suspense streaming on the server.',
  'Using this API will now warn:',
  'Instead, for streaming in Node environments, use:',
  'We’re also introducing a new API to support streaming SSR with Suspense for modern edge runtime environments, such as Deno and Cloudflare workers:',
  'The following APIs will continue working, but with limited support for Suspense:',
  'Finally, this API will continue to work for rendering e-mails:',
  'For more information on the changes to server rendering APIs, see the working group post on Upgrading to React 18 on the server, a deep dive on the new Suspense SSR Architecture, and Shaundai Person’s talk on Streaming Server Rendering with Suspense at React Conf 2021.',
  'If your project uses TypeScript, you will need to update your @types/react and @types/react-dom dependencies to the latest versions. The new types are safer and catch issues that used to be ignored by the type checker. The most notable change is that the children prop now needs to be listed explicitly when defining props, for example:',
  'See the React 18 typings pull request for a full list of type-only changes. It links to example fixes in library types so you can see how to adjust your code. You can use the automated migration script to help port your application code to the new and safer typings faster.',
  'If you find a bug in the typings, please file an issue in the DefinitelyTyped repo.',
  'React 18 adds out-of-the-box performance improvements by doing more batching by default. Batching is when React groups multiple state updates into a single re-render for better performance. Before React 18, we only batched updates inside React event handlers. Updates inside of promises, setTimeout, native event handlers, or any other event were not batched in React by default:',
  'Starting in React 18 with createRoot, all updates will be automatically batched, no matter where they originate from. This means that updates inside of timeouts, promises, native event handlers or any other event will batch the same way as updates inside of React events:',
  'This is a breaking change, but we expect this to result in less work rendering, and therefore better performance in your applications. To opt-out of automatic batching, you can use flushSync:',
  'For more information, see the Automatic batching deep dive.',
  'In the React 18 Working Group we worked with library maintainers to create new APIs needed to support concurrent rendering for use cases specific to their use case in areas like styles, and external stores. To support React 18, some libraries may need to switch to one of the following APIs:',
  'React 18 also introduces new APIs for concurrent rendering such as startTransition, useDeferredValue and useId, which we share more about in the release post.',
  'In the future, we’d like to add a feature that allows React to add and remove sections of the UI while preserving state. For example, when a user tabs away from a screen and back, React should be able to immediately show the previous screen. To do this, React would unmount and remount trees using the same component state as before.',
  'This feature will give React better performance out-of-the-box, but requires components to be resilient to effects being mounted and destroyed multiple times. Most effects will work without any changes, but some effects assume they are only mounted or destroyed once.',
  'To help surface these issues, React 18 introduces a new development-only check to Strict Mode. This new check will automatically unmount and remount every component, whenever a component mounts for the first time, restoring the previous state on the second mount.',
  'Before this change, React would mount the component and create the effects:',
  'With Strict Mode in React 18, React will simulate unmounting and remounting the component in development mode:',
  'For more information, see the Working Group posts for Adding Reusable State to StrictMode and How to support Reusable State in Effects.',
  'When you first update your tests to use createRoot, you may see this warning in your test console:',
  'To fix this, set globalThis.IS_REACT_ACT_ENVIRONMENT to true before running your test:',
  'The purpose of the flag is to tell React that it’s running in a unit test-like environment. React will log helpful warnings if you forget to wrap an update with act.',
  'You can also set the flag to false to tell React that act isn’t needed. This can be useful for end-to-end tests that simulate a full browser environment.',
  'Eventually, we expect testing libraries will configure this for you automatically. For example, the next version of React Testing Library has built-in support for React 18 without any additional configuration.',
  'More background on the act testing API and related changes is available in the working group.',
  'In this release, React is dropping support for Internet Explorer, which is going out of support on June 15, 2022. We’re making this change now because new features introduced in React 18 are built using modern browser features such as microtasks which cannot be adequately polyfilled in IE.',
  'If you need to support Internet Explorer we recommend you stay with React 17.',
  'You can view the full changelog here.',
  'How do you like these docs?'
]
URL:  https://react.dev/blog/2022/03/29/react-v18
[
  'March 29, 2022 by The React Team',
  'React 18 is now available on npm! In our last post, we shared step-by-step instructions for upgrading your app to React 18. In this post, we’ll give an overview of what’s new in React 18, and what it means for the future.',
  'Our latest major version includes out-of-the-box improvements like automatic batching, new APIs like startTransition, and streaming server-side rendering with support for Suspense.',
  'Many of the features in React 18 are built on top of our new concurrent renderer, a behind-the-scenes change that unlocks powerful new capabilities. Concurrent React is opt-in — it’s only enabled when you use a concurrent feature — but we think it will have a big impact on the way people build applications.',
  'We’ve spent years researching and developing support for concurrency in React, and we’ve taken extra care to provide a gradual adoption path for existing users. Last summer, we formed the React 18 Working Group to gather feedback from experts in the community and ensure a smooth upgrade experience for the entire React ecosystem.',
  'In case you missed it, we shared a lot of this vision at React Conf 2021:',
  'Below is a full overview of what to expect in this release, starting with Concurrent Rendering.',
  'For React Native users, React 18 will ship in React Native with the New React Native Architecture. For more information, see the React Conf keynote here.',
  'The most important addition in React 18 is something we hope you never have to think about: concurrency. We think this is largely true for application developers, though the story may be a bit more complicated for library maintainers.',
  'Concurrency is not a feature, per se. It’s a new behind-the-scenes mechanism that enables React to prepare multiple versions of your UI at the same time. You can think of concurrency as an implementation detail — it’s valuable because of the features that it unlocks. React uses sophisticated techniques in its internal implementation, like priority queues and multiple buffering. But you won’t see those concepts anywhere in our public APIs.',
  'When we design APIs, we try to hide implementation details from developers. As a React developer, you focus on what you want the user experience to look like, and React handles how to deliver that experience. So we don’t expect React developers to know how concurrency works under the hood.',
  'However, Concurrent React is more important than a typical implementation detail — it’s a foundational update to React’s core rendering model. So while it’s not super important to know how concurrency works, it may be worth knowing what it is at a high level.',
  'A key property of Concurrent React is that rendering is interruptible. When you first upgrade to React 18, before adding any concurrent features, updates are rendered the same as in previous versions of React — in a single, uninterrupted, synchronous transaction. With synchronous rendering, once an update starts rendering, nothing can interrupt it until the user can see the result on screen.',
  'In a concurrent render, this is not always the case. React may start rendering an update, pause in the middle, then continue later. It may even abandon an in-progress render altogether. React guarantees that the UI will appear consistent even if a render is interrupted. To do this, it waits to perform DOM mutations until the end, once the entire tree has been evaluated. With this capability, React can prepare new screens in the background without blocking the main thread. This means the UI can respond immediately to user input even if it’s in the middle of a large rendering task, creating a fluid user experience.',
  'Another example is reusable state. Concurrent React can remove sections of the UI from the screen, then add them back later while reusing the previous state. For example, when a user tabs away from a screen and back, React should be able to restore the previous screen in the same state it was in before. In an upcoming minor, we’re planning to add a new component called <Offscreen> that implements this pattern. Similarly, you’ll be able to use Offscreen to prepare new UI in the background so that it’s ready before the user reveals it.',
  'Concurrent rendering is a powerful new tool in React and most of our new features are built to take advantage of it, including Suspense, transitions, and streaming server rendering. But React 18 is just the beginning of what we aim to build on this new foundation.',
  'Technically, concurrent rendering is a breaking change. Because concurrent rendering is interruptible, components behave slightly differently when it is enabled.',
  'In our testing, we’ve upgraded thousands of components to React 18. What we’ve found is that nearly all existing components “just work” with concurrent rendering, without any changes. However, some of them may require some additional migration effort. Although the changes are usually small, you’ll still have the ability to make them at your own pace. The new rendering behavior in React 18 is only enabled in the parts of your app that use new features.',
  'The overall upgrade strategy is to get your application running on React 18 without breaking existing code. Then you can gradually start adding concurrent features at your own pace. You can use <StrictMode> to help surface concurrency-related bugs during development. Strict Mode doesn’t affect production behavior, but during development it will log extra warnings and double-invoke functions that are expected to be idempotent. It won’t catch everything, but it’s effective at preventing the most common types of mistakes.',
  'After you upgrade to React 18, you’ll be able to start using concurrent features immediately. For example, you can use startTransition to navigate between screens without blocking user input. Or useDeferredValue to throttle expensive re-renders.',
  'However, long term, we expect the main way you’ll add concurrency to your app is by using a concurrent-enabled library or framework. In most cases, you won’t interact with concurrent APIs directly. For example, instead of developers calling startTransition whenever they navigate to a new screen, router libraries will automatically wrap navigations in startTransition.',
  'It may take some time for libraries to upgrade to be concurrent compatible. We’ve provided new APIs to make it easier for libraries to take advantage of concurrent features. In the meantime, please be patient with maintainers as we work to gradually migrate the React ecosystem.',
  'For more info, see our previous post: How to upgrade to React 18.',
  'In React 18, you can start using Suspense for data fetching in opinionated frameworks like Relay, Next.js, Hydrogen, or Remix. Ad hoc data fetching with Suspense is technically possible, but still not recommended as a general strategy.',
  'In the future, we may expose additional primitives that could make it easier to access your data with Suspense, perhaps without the use of an opinionated framework. However, Suspense works best when it’s deeply integrated into your application’s architecture: your router, your data layer, and your server rendering environment. So even long term, we expect that libraries and frameworks will play a crucial role in the React ecosystem.',
  'As in previous versions of React, you can also use Suspense for code splitting on the client with React.lazy. But our vision for Suspense has always been about much more than loading code — the goal is to extend support for Suspense so that eventually, the same declarative Suspense fallback can handle any asynchronous operation (loading code, data, images, etc).',
  'Server Components is an upcoming feature that allows developers to build apps that span the server and client, combining the rich interactivity of client-side apps with the improved performance of traditional server rendering. Server Components is not inherently coupled to Concurrent React, but it’s designed to work best with concurrent features like Suspense and streaming server rendering.',
  'Server Components is still experimental, but we expect to release an initial version in a minor 18.x release. In the meantime, we’re working with frameworks like Next.js, Hydrogen, and Remix to advance the proposal and get it ready for broad adoption.',
  'Batching is when React groups multiple state updates into a single re-render for better performance. Without automatic batching, we only batched updates inside React event handlers. Updates inside of promises, setTimeout, native event handlers, or any other event were not batched in React by default. With automatic batching, these updates will be batched automatically:',
  'For more info, see this post for Automatic batching for fewer renders in React 18.',
  'A transition is a new concept in React to distinguish between urgent and non-urgent updates.',
  'Urgent updates like typing, clicking, or pressing, need immediate response to match our intuitions about how physical objects behave. Otherwise they feel “wrong”. However, transitions are different because the user doesn’t expect to see every intermediate value on screen.',
  'For example, when you select a filter in a dropdown, you expect the filter button itself to respond immediately when you click. However, the actual results may transition separately. A small delay would be imperceptible and often expected. And if you change the filter again before the results are done rendering, you only care to see the latest results.',
  'Typically, for the best user experience, a single user input should result in both an urgent update and a non-urgent one. You can use startTransition API inside an input event to inform React which updates are urgent and which are “transitions”:',
  'Updates wrapped in startTransition are handled as non-urgent and will be interrupted if more urgent updates like clicks or key presses come in. If a transition gets interrupted by the user (for example, by typing multiple characters in a row), React will throw out the stale rendering work that wasn’t finished and render only the latest update.',
  'Transitions will opt in to concurrent rendering, which allows the update to be interrupted. If the content re-suspends, transitions also tell React to continue showing the current content while rendering the transition content in the background (see the Suspense RFC for more info).',
  'See docs for transitions here.',
  'Suspense lets you declaratively specify the loading state for a part of the component tree if it’s not yet ready to be displayed:',
  'Suspense makes the “UI loading state” a first-class declarative concept in the React programming model. This lets us build higher-level features on top of it.',
  'We introduced a limited version of Suspense several years ago. However, the only supported use case was code splitting with React.lazy, and it wasn’t supported at all when rendering on the server.',
  'In React 18, we’ve added support for Suspense on the server and expanded its capabilities using concurrent rendering features.',
  'Suspense in React 18 works best when combined with the transition API. If you suspend during a transition, React will prevent already-visible content from being replaced by a fallback. Instead, React will delay the render until enough data has loaded to prevent a bad loading state.',
  'For more, see the RFC for Suspense in React 18.',
  'In this release we took the opportunity to redesign the APIs we expose for rendering on the client and server. These changes allow users to continue using the old APIs in React 17 mode while they upgrade to the new APIs in React 18.',
  'These new APIs are now exported from react-dom/client:',
  'Both createRoot and hydrateRoot accept a new option called onRecoverableError in case you want to be notified when React recovers from errors during rendering or hydration for logging. By default, React will use reportError, or console.error in the older browsers.',
  'See docs for React DOM Client here.',
  'These new APIs are now exported from react-dom/server and have full support for streaming Suspense on the server:',
  'The existing renderToString method keeps working but is discouraged.',
  'See docs for React DOM Server here.',
  'In the future, we’d like to add a feature that allows React to add and remove sections of the UI while preserving state. For example, when a user tabs away from a screen and back, React should be able to immediately show the previous screen. To do this, React would unmount and remount trees using the same component state as before.',
  'This feature will give React apps better performance out-of-the-box, but requires components to be resilient to effects being mounted and destroyed multiple times. Most effects will work without any changes, but some effects assume they are only mounted or destroyed once.',
  'To help surface these issues, React 18 introduces a new development-only check to Strict Mode. This new check will automatically unmount and remount every component, whenever a component mounts for the first time, restoring the previous state on the second mount.',
  'Before this change, React would mount the component and create the effects:',
  'With Strict Mode in React 18, React will simulate unmounting and remounting the component in development mode:',
  'See docs for ensuring reusable state here.',
  'useId is a new Hook for generating unique IDs on both the client and server, while avoiding hydration mismatches. It is primarily useful for component libraries integrating with accessibility APIs that require unique IDs. This solves an issue that already exists in React 17 and below, but it’s even more important in React 18 because of how the new streaming server renderer delivers HTML out-of-order. See docs here.',
  'Note',
  'useId is not for generating keys in a list. Keys should be generated from your data.',
  'useTransition and startTransition let you mark some state updates as not urgent. Other state updates are considered urgent by default. React will allow urgent state updates (for example, updating a text input) to interrupt non-urgent state updates (for example, rendering a list of search results). See docs here',
  'useDeferredValue lets you defer re-rendering a non-urgent part of the tree. It is similar to debouncing, but has a few advantages compared to it. There is no fixed time delay, so React will attempt the deferred render right after the first render is reflected on the screen. The deferred render is interruptible and doesn’t block user input. See docs here.',
  'useSyncExternalStore is a new Hook that allows external stores to support concurrent reads by forcing updates to the store to be synchronous. It removes the need for useEffect when implementing subscriptions to external data sources, and is recommended for any library that integrates with state external to React. See docs here.',
  'Note',
  'useSyncExternalStore is intended to be used by libraries, not application code.',
  'useInsertionEffect is a new Hook that allows CSS-in-JS libraries to address performance issues of injecting styles in render. Unless you’ve already built a CSS-in-JS library we don’t expect you to ever use this. This Hook will run after the DOM is mutated, but before layout effects read the new layout. This solves an issue that already exists in React 17 and below, but is even more important in React 18 because React yields to the browser during concurrent rendering, giving it a chance to recalculate layout. See docs here.',
  'Note',
  'useInsertionEffect is intended to be used by libraries, not application code.',
  'See How to Upgrade to React 18 for step-by-step instructions and a full list of breaking and notable changes.',
  'How do you like these docs?'
]
URL:  https://react.dev/blog/2021/06/08/the-plan-for-react-18
[
  'June 8, 2021 by Andrew Clark, Brian Vaughn, Christine Abernathy, Dan Abramov, Rachel Nabors, Rick Hanlon, Sebastian Markbåge, and Seth Webster',
  'The React team is excited to share a few updates:',
  'These updates are primarily aimed at maintainers of third-party libraries. If you’re learning, teaching, or using React to build user-facing applications, you can safely ignore this post. But you are welcome to follow the discussions in the React 18 Working Group if you’re curious!',
  'When it’s released, React 18 will include out-of-the-box improvements (like automatic batching), new APIs (like startTransition), and a new streaming server renderer with built-in support for React.lazy.',
  'These features are possible thanks to a new opt-in mechanism we’re adding in React 18. It’s called “concurrent rendering” and it lets React prepare multiple versions of the UI at the same time. This change is mostly behind-the-scenes, but it unlocks new possibilities to improve both real and perceived performance of your app.',
  'If you’ve been following our research into the future of React (we don’t expect you to!), you might have heard of something called “concurrent mode” or that it might break your app. In response to this feedback from the community, we’ve redesigned the upgrade strategy for gradual adoption. Instead of an all-or-nothing “mode”, concurrent rendering will only be enabled for updates triggered by one of the new features. In practice, this means you will be able to adopt React 18 without rewrites and try the new features at your own pace.',
  'Since concurrency in React 18 is opt-in, there are no significant out-of-the-box breaking changes to component behavior. You can upgrade to React 18 with minimal or no changes to your application code, with a level of effort comparable to a typical major React release. Based on our experience converting several apps to React 18, we expect that many users will be able to upgrade within a single afternoon.',
  'We successfully shipped concurrent features to tens of thousands of components at Facebook, and in our experience, we’ve found that most React components “just work” without additional changes. We’re committed to making sure this is a smooth upgrade for the entire community, so today we’re announcing the React 18 Working Group.',
  'We’re trying something new for this release: We’ve invited a panel of experts, developers, library authors, and educators from across the React community to participate in our React 18 Working Group to provide feedback, ask questions, and collaborate on the release. We couldn’t invite everyone we wanted to this initial, small group, but if this experiment works out, we hope there will be more in the future!',
  'The goal of the React 18 Working Group is to prepare the ecosystem for a smooth, gradual adoption of React 18 by existing applications and libraries. The Working Group is hosted on GitHub Discussions and is available for the public to read. Members of the working group can leave feedback, ask questions, and share ideas. The core team will also use the discussions repo to share our research findings. As the stable release gets closer, any important information will also be posted on this blog.',
  'For more information on upgrading to React 18, or additional resources about the release, see the React 18 announcement post.',
  'Everyone can read the discussions in the React 18 Working Group repo.',
  'Because we expect an initial surge of interest in the Working Group, only invited members will be allowed to create or comment on threads. However, the threads are fully visible to the public, so everyone has access to the same information. We believe this is a good compromise between creating a productive environment for working group members, while maintaining transparency with the wider community.',
  'As always, you can submit bug reports, questions, and general feedback to our issue tracker.',
  'New alphas are regularly published to npm using the @alpha tag. These releases are built using the most recent commit to our main repo. When a feature or bugfix is merged, it will appear in an alpha the following weekday.',
  'There may be significant behavioral or API changes between alpha releases. Please remember that alpha releases are not recommended for user-facing, production applications.',
  'We don’t have a specific release date scheduled, but we expect it will take several months of feedback and iteration before React 18 is ready for most production applications.',
  'More details about our projected release timeline are available in the Working Group. We’ll post updates on this blog when we’re closer to a public release.',
  'How do you like these docs?'
]
URL:  https://react.dev/blog/2021/12/17/react-conf-2021-recap
[
  'December 17, 2021 by Jesslyn Tannady and Rick Hanlon',
  'Last week we hosted our 6th React Conf. In previous years, we’ve used the React Conf stage to deliver industry changing announcements such as React Native and React Hooks. This year, we shared our multi-platform vision for React, starting with the release of React 18 and gradual adoption of concurrent features.',
  'This was the first time React Conf was hosted online, and it was streamed for free, translated to 8 different languages. Participants from all over the world joined our conference Discord and the replay event for accessibility in all timezones. Over 50,000 people registered, with over 60,000 views of 19 talks, and 5,000 participants in Discord across both events.',
  'All the talks are available to stream online.',
  'Here’s a summary of what was shared on stage:',
  'In the keynote, we shared our vision for the future of React starting with React 18.',
  'React 18 adds the long-awaited concurrent renderer and updates to Suspense without any major breaking changes. Apps can upgrade to React 18 and begin gradually adopting concurrent features with the amount of effort on par with any other major release.',
  'This means there is no concurrent mode, only concurrent features.',
  'In the keynote, we also shared our vision for Suspense, Server Components, new React working groups, and our long-term many-platform vision for React Native.',
  'Watch the full keynote from Andrew Clark, Juan Tejada, Lauren Tan, and Rick Hanlon here:',
  'In the keynote, we also announced that the React 18 RC is available to try now. Pending further feedback, this is the exact version of React that we will publish to stable early next year.',
  'To try the React 18 RC, upgrade your dependencies:',
  'and switch to the new createRoot API:',
  'For a demo of upgrading to React 18, see Shruti Kapoor’s talk here:',
  'React 18 also includes improvements to server-side rendering performance using Suspense.',
  'Streaming server rendering lets you generate HTML from React components on the server, and stream that HTML to your users. In React 18, you can use Suspense to break down your app into smaller independent units which can be streamed independently of each other without blocking the rest of the app. This means users will see your content sooner and be able to start interacting with it much faster.',
  'For a deep dive, see Shaundai Person’s talk here:',
  'For React 18, we created our first Working Group to collaborate with a panel of experts, developers, library maintainers, and educators. Together we worked to create our gradual adoption strategy and refine new APIs such as useId, useSyncExternalStore, and useInsertionEffect.',
  'For an overview of this work, see Aakansha’ Doshi’s talk:',
  'To support the new features in this release, we also announced the newly formed React DevTools team and a new Timeline Profiler to help developers debug their React apps.',
  'For more information and a demo of new DevTools features, see Brian Vaughn’s talk:',
  'Looking further into the future, Xuan Huang (黄玄) shared an update from our React Labs research into an auto-memoizing compiler. Check out this talk for more information and a demo of the compiler prototype:',
  'Rachel Nabors kicked off a section of talks about learning and designing with React with a keynote about our investment in React’s new docs (now shipped as react.dev):',
  'We also heard talks on learning and designing with React:',
  'Talks from the Relay, React Native, and PyTorch teams:',
  'And talks from the community on accessibility, tooling, and Server Components:',
  'This was our first year planning a conference ourselves, and we have a lot of people to thank.',
  'First, thanks to all of our speakers Aakansha Doshi, Andrew Clark, Brian Vaughn, Daishi Kato, Debbie O’Brien, Delba de Oliveira, Diego Haz, Eric Rozell, Helen Lin, Juan Tejada, Lauren Tan, Linton Ye, Lyle Troxell, Rachel Nabors, Rick Hanlon, Robert Balicki, Roman Rädle, Sarah Rainsberger, Shaundai Person, Shruti Kapoor, Steven Moyes, Tafu Nakazaki, and  Xuan Huang (黄玄).',
  'Thanks to everyone who helped provide feedback on talks including Andrew Clark, Dan Abramov, Dave McCabe, Eli White, Joe Savona,  Lauren Tan, Rachel Nabors, and Tim Yung.',
  'Thanks to Lauren Tan for setting up the conference Discord and serving as our Discord admin.',
  'Thanks to Seth Webster for feedback on overall direction and making sure we were focused on diversity and inclusion.',
  'Thanks to Rachel Nabors for spearheading our moderation effort, and Aisha Blake for creating our moderation guide, leading our moderation team, training the translators and moderators, and helping to moderate both events.',
  'Thanks to our moderators Jesslyn Tannady, Suzie Grange, Becca Bailey, Luna Wei, Joe Previte, Nicola Corti, Gijs Weterings, Claudio Procida, Julia Neumann, Mengdi Chen, Jean Zhang, Ricky Li, and Xuan Huang (黄玄).',
  'Thanks to Manjula Dube, Sahil Mhapsekar, and Vihang Patel from React India, and Jasmine Xie, QiChang Li, and YanLun Li from React China for helping moderate our replay event and keep it engaging for the community.',
  'Thanks to Vercel for publishing their Virtual Event Starter Kit, which the conference website was built on, and to Lee Robinson and Delba de Oliveira for sharing their experience running Next.js Conf.',
  'Thanks to Leah Silber for sharing her experience running conferences, learnings from running RustConf, and for her book Event Driven and the advice it contains for running conferences.',
  'Thanks to Kevin Lewis and Rachel Nabors for sharing their experience running Women of React Conf.',
  'Thanks to Aakansha Doshi, Laurie Barth, Michael Chan, and Shaundai Person for their advice and ideas throughout planning.',
  'Thanks to Dan Lebowitz for help designing and building the conference website and tickets.',
  'Thanks to Laura Podolak Waddell, Desmond Osei-Acheampong, Mark Rossi, Josh Toberman and others on the Facebook Video Productions team for recording the videos for the Keynote and Meta employee talks.',
  'Thanks to our partner HitPlay for helping to organize the conference, editing all the videos in the stream, translating all the talks, and moderating the Discord in multiple languages.',
  'Finally, thanks to all of our participants for making this a great React Conf!',
  'How do you like these docs?'
]
URL:  https://react.dev/blog/2023/03/16/introducing-react-dev
[
  'March 16, 2023 by Dan Abramov and Rachel Nabors',
  'Today we are thrilled to launch react.dev, the new home for React and its documentation. In this post, we would like to give you a tour of the new site.',
  'First, a little bit of housekeeping.',
  'To celebrate the launch of the new docs and, more importantly, to clearly separate the old and the new content, we’ve moved to the shorter react.dev domain. The old reactjs.org domain will now redirect here.',
  'The old React docs are now archived at legacy.reactjs.org. All existing links to the old content will automatically redirect there to avoid “breaking the web”, but the legacy site will not get many more updates.',
  'Believe it or not, React will soon be ten years old. In JavaScript years, it’s like a whole century! We’ve refreshed the React homepage to reflect why we think React is a great way to create user interfaces today, and updated the getting started guides to more prominently mention modern React-based frameworks.',
  'If you haven’t seen the new homepage yet, check it out!',
  'When we released React Hooks in 2018, the Hooks docs assumed the reader is familiar with class components. This helped the community adopt Hooks very swiftly, but after a while the old docs failed to serve the new readers. New readers had to learn React twice: once with class components and then once again with Hooks.',
  'The new docs teach React with Hooks from the beginning. The docs are divided in two main sections:',
  'Let’s have a closer look at what you can find in each section.',
  'There are still a few rare class component use cases that do not yet have a Hook-based equivalent. Class components remain supported, and are documented in the Legacy API section of the new site.',
  'The Learn section begins with the Quick Start page. It is a short introductory tour of React. It introduces the syntax for concepts like components, props, and state, but doesn’t go into much detail on how to use them.',
  'If you like to learn by doing, we recommend checking out the Tic-Tac-Toe Tutorial next. It walks you through building a little game with React, while teaching the skills you’ll use every day. Here’s what you’ll build:',
  'We’d also like to highlight Thinking in React—that’s the tutorial that made React “click” for many of us. We’ve updated both of these classic tutorials to use function components and Hooks, so they’re as good as new.',
  'The example above is a sandbox. We’ve added a lot of sandboxes—over 600!—everywhere throughout the site. You can edit any sandbox, or press “Fork” in the upper right corner to open it in a separate tab. Sandboxes let you quickly play with the React APIs, explore your ideas, and check your understanding.',
  'We’d like everyone in the world to have an equal opportunity to learn React for free on their own.',
  'This is why the Learn section is organized like a self-paced course split into chapters. The first two chapters describe the fundamentals of React. If you’re new to React, or want to refresh it in your memory, start here:',
  'The next two chapters are more advanced, and will give you a deeper insight into the trickier parts:',
  'Every chapter consists of several related pages. Most of these pages teach a specific skill or a technique—for example, Writing Markup with JSX, Updating Objects in State, or Sharing State Between Components. Some of the pages focus on explaining an idea—like Render and Commit, or State as a Snapshot. And there are a few, like You Might Not Need an Effect, that share our suggestions based on what we’ve learned over these years.',
  'You don’t have to read these chapters as a sequence. Who has the time for this?! But you could. Pages in the Learn section only rely on concepts introduced by the earlier pages. If you want to read it like a book, go for it!',
  'Most pages in the Learn section end with a few challenges to check your understanding. For example, here are a few challenges from the page about Conditional Rendering.',
  'You don’t have to solve them right now! Unless you really want to.',
  'Use the conditional operator (cond ? a : b) to render a ❌ if isPacked isn’t true.',
  'Notice the “Show solution” button in the left bottom corner. It’s handy if you want to check yourself!',
  'When we couldn’t figure out how to explain something with code and words alone, we’ve added diagrams that help provide some intuition. For example, here is one of the diagrams from Preserving and Resetting State:',
  'When section changes to div, the section is deleted and the new div is added',
  'You’ll also see some illustrations throughout the docs—here’s one of the browser painting the screen:',
  'Illustrated by Rachel Lee Nabors',
  'We’ve confirmed with the browser vendors that this depiction is 100% scientifically accurate.',
  'In the API Reference, every React API now has a dedicated page. This includes all kinds of APIs:',
  'You’ll notice that every API page is split into at least two segments: Reference and Usage.',
  'Reference describes the formal API signature by listing its arguments and return values. It’s concise, but it can feel a bit abstract if you’re not familiar with that API. It describes what an API does, but not how to use it.',
  'Usage shows why and how you would use this API in practice, like a colleague or a friend might explain. It shows the canonical scenarios for how each API was meant to be used by the React team. We’ve added color-coded snippets, examples of using different APIs together, and recipes that you can copy and paste from:',
  'In this example, the count state variable holds a number. Clicking the button increments it.',
  'Some API pages also include Troubleshooting (for common problems) and Alternatives (for deprecated APIs).',
  'We hope that this approach will make the API reference useful not only as a way to look up an argument, but as a way to see all the different things you can do with any given API—and how it connects to the other ones.',
  'That’s a wrap for our little tour! Have a look around the new website, see what you like or don’t like, and keep the feedback coming in the anonymous survey or in our issue tracker.',
  'We acknowledge this project has taken a long time to ship. We wanted to maintain a high quality bar that the React community deserves. While writing these docs and creating all of the examples, we found mistakes in some of our own explanations, bugs in React, and even gaps in the React design that we are now working to address. We hope that the new documentation will help us hold React itself to a higher bar in the future.',
  'We’ve heard many of your requests to expand the content and functionality of the website, for example:',
  'Now that react.dev is out, we will be able to shift our focus from “catching up” with the third-party React educational resources to adding new information and further improving our new website.',
  'We think there’s never been a better time to learn React.',
  'On the React team, Rachel Nabors led the project (and provided the illustrations), and Dan Abramov designed the curriculum. They co-authored most of the content together as well.',
  'Of course, no project this large happens in isolation. We have a lot of people to thank!',
  'Sylwia Vargas overhauled our examples to go beyond “foo/bar/baz” and kittens, and feature scientists, artists and cities from around the world. Maggie Appleton turned our doodles into a clear diagram system.',
  'Thanks to David McCabe, Sophie Alpert, Rick Hanlon, Andrew Clark, and Matt Carroll for additional writing contributions. We’d also like to thank Natalia Tepluhina and Sebastian Markbåge for their ideas and feedback.',
  'Thanks to Dan Lebowitz for the site design and Razvan Gradinar for the sandbox design.',
  'On the development front, thanks to Jared Palmer for prototype development. Thanks to Dane Grant and Dustin Goodman from ThisDotLabs for their support on UI development. Thanks to Ives van Hoorne, Alex Moldovan, Jasper De Moor, and Danilo Woznica from CodeSandbox for their work with sandbox integration. Thanks to Rick Hanlon for spot development and design work, finessing our colors and finer details. Thanks to Harish Kumar and Luna Ruan for adding new features to the site and helping maintain it.',
  'Huge thanks to the folks who volunteered their time to participate in the alpha and beta testing program. Your enthusiasm and invaluable feedback helped us shape these docs. A special shout out to our beta tester, Debbie O’Brien, who gave a talk about her experience using the React docs at React Conf 2021.',
  'Finally, thanks to the React community for being the inspiration behind this effort. You are the reason we do this, and we hope that the new docs will help you use React to build any user interface that you want.',
  'How do you like these docs?'
]
URL:  https://react.dev/reference
[
  'Is this page useful?',
  'This section provides detailed reference documentation for working with React. For an introduction to React, please visit the Learn section.',
  'Our The React reference documentation is broken down into functional subsections:',
  'Programmatic React features:',
  'React-dom contains features that are only supported for web applications (which run in the browser DOM environment). This section is broken into the following:',
  'How do you like these docs?'
]
URL:  https://react.dev/blog/2023/03/22/react-labs-what-we-have-been-working-on-march-2023
[
  'March 22, 2023 by Joseph Savona, Josh Story, Lauren Tan, Mengdi Chen, Samuel Susla, Sathya Gunasekaran, Sebastian Markbåge, and Andrew Clark',
  'In React Labs posts, we write about projects in active research and development. We’ve made significant progress on them since our last update, and we’d like to share what we learned.',
  'React Server Components (or RSC) is a new application architecture designed by the React team.',
  'We’ve first shared our research on RSC in an introductory talk and an RFC. To recap them, we are introducing a new kind of component—Server Components—that run ahead of time and are excluded from your JavaScript bundle. Server Components can run during the build, letting you read from the filesystem or fetch static content. They can also run on the server, letting you access your data layer without having to build an API. You can pass data by props from Server Components to the interactive Client Components in the browser.',
  'RSC combines the simple “request/response” mental model of server-centric Multi-Page Apps with the seamless interactivity of client-centric Single-Page Apps, giving you the best of both worlds.',
  'Since our last update, we have merged the React Server Components RFC to ratify the proposal. We resolved outstanding issues with the React Server Module Conventions proposal, and reached consensus with our partners to go with the "use client" convention. These documents also act as specification for what an RSC-compatible implementation should support.',
  'The biggest change is that we introduced async / await as the primary way to do data fetching from Server Components. We also plan to support data loading from the client by introducing a new Hook called use that unwraps Promises. Although we can’t support async / await in arbitrary components in client-only apps, we plan to add support for it when you structure your client-only app similar to how RSC apps are structured.',
  'Now that we have data fetching pretty well sorted, we’re exploring the other direction: sending data from the client to the server, so that you can execute database mutations and implement forms. We’re doing this by letting you pass Server Action functions across the server/client boundary, which the client can then call, providing seamless RPC. Server Actions also give you progressively enhanced forms before JavaScript loads.',
  'React Server Components has shipped in Next.js App Router. This showcases a deep integration of a router that really buys into RSC as a primitive, but it’s not the only way to build a RSC-compatible router and framework. There’s a clear separation for features provided by the RSC spec and implementation. React Server Components is meant as a spec for components that work across compatible React frameworks.',
  'We generally recommend using an existing framework, but if you need to build your own custom framework, it is possible. Building your own RSC-compatible framework is not as easy as we’d like it to be, mainly due to the deep bundler integration needed. The current generation of bundlers are great for use on the client, but they weren’t designed with first-class support for splitting a single module graph between the server and the client. This is why we’re now partnering directly with bundler developers to get the primitives for RSC built-in.',
  'Suspense lets you specify what to display on the screen while the data or code for your components is still being loaded. This lets your users progressively see more content while the page is loading as well as during the router navigations that load more data and code. However, from the user’s perspective, data loading and rendering do not tell the whole story when considering whether new content is ready. By default, browsers load stylesheets, fonts, and images independently, which can lead to UI jumps and consecutive layout shifts.',
  'We’re working to fully integrate Suspense with the loading lifecycle of stylesheets, fonts, and images, so that React takes them into account to determine whether the content is ready to be displayed. Without any change to the way you author your React components, updates will behave in a more coherent and pleasing manner. As an optimization, we will also provide a manual way to preload assets like fonts directly from components.',
  'We are currently implementing these features and will have more to share soon.',
  'Different pages and screens in your app may have different metadata like the <title> tag, description, and other <meta> tags specific to this screen. From the maintenance perspective, it’s more scalable to keep this information close to the React component for that page or screen. However, the HTML tags for this metadata need to be in the document <head> which is typically rendered in a component at the very root of your app.',
  'Today, people solve this problem with one of the two techniques.',
  'One technique is to render a special third-party component that moves <title>, <meta>, and other tags inside it into the document <head>. This works for major browsers but there are many clients which do not run client-side JavaScript, such as Open Graph parsers, and so this technique is not universally suitable.',
  'Another technique is to server-render the page in two parts. First, the main content is rendered and all such tags are collected. Then, the <head> is rendered with these tags. Finally, the <head> and the main content are sent to the browser. This approach works, but it prevents you from taking advantage of the React 18’s Streaming Server Renderer because you’d have to wait for all content to render before sending the <head>.',
  'This is why we’re adding built-in support for rendering <title>, <meta>, and metadata <link> tags anywhere in your component tree out of the box. It would work the same way in all environments, including fully client-side code, SSR, and in the future, RSC. We will share more details about this soon.',
  'Since our previous update we’ve been actively iterating on the design of React Forget, an optimizing compiler for React. We’ve previously talked about it as an “auto-memoizing compiler”, and that is true in some sense. But building the compiler has helped us understand React’s programming model even more deeply. A better way to understand React Forget is as an automatic reactivity compiler.',
  'The core idea of React is that developers define their UI as a function of the current state. You work with plain JavaScript values — numbers, strings, arrays, objects — and use standard JavaScript idioms — if/else, for, etc — to describe your component logic. The mental model is that React will re-render whenever the application state changes. We believe this simple mental model and keeping close to JavaScript semantics is an important principle in React’s programming model.',
  'The catch is that React can sometimes be too reactive: it can re-render too much. For example, in JavaScript we don’t have cheap ways to compare if two objects or arrays are equivalent (having the same keys and values), so creating a new object or array on each render may cause React to do more work than it strictly needs to. This means developers have to explicitly memoize components so as to not over-react to changes.',
  'Our goal with React Forget is to ensure that React apps have just the right amount of reactivity by default: that apps re-render only when state values meaningfully change. From an implementation perspective this means automatically memoizing, but we believe that the reactivity framing is a better way to understand React and Forget. One way to think about this is that React currently re-renders when object identity changes. With Forget, React re-renders when the semantic value changes — but without incurring the runtime cost of deep comparisons.',
  'In terms of concrete progress, since our last update we have substantially iterated on the design of the compiler to align with this automatic reactivity approach and to incorporate feedback from using the compiler internally. After some significant refactors to the compiler starting late last year, we’ve now begun using the compiler in production in limited areas at Meta. We plan to open-source it once we’ve proved it in production.',
  'Finally, a lot of people have expressed interest in how the compiler works. We’re looking forward to sharing a lot more details when we prove the compiler and open-source it. But there are a few bits we can share now:',
  'The core of the compiler is almost completely decoupled from Babel, and the core compiler API is (roughly) old AST in, new AST out (while retaining source location data). Under the hood we use a custom code representation and transformation pipeline in order to do low-level semantic analysis. However, the primary public interface to the compiler will be via Babel and other build system plugins. For ease of testing we currently have a Babel plugin which is a very thin wrapper that calls the compiler to generate a new version of each function and swap it in.',
  'As we refactored the compiler over the last few months, we wanted to focus on refining the core compilation model to ensure we could handle complexities such as conditionals, loops, reassignment, and mutation. However, JavaScript has a lot of ways to express each of those features: if/else, ternaries, for, for-in, for-of, etc. Trying to support the full language up-front would have delayed the point where we could validate the core model. Instead, we started with a small but representative subset of the language: let/const, if/else, for loops, objects, arrays, primitives, function calls, and a few other features. As we gained confidence in the core model and refined our internal abstractions, we expanded the supported language subset. We’re also explicit about syntax we don’t yet support, logging diagnostics and skipping compilation for unsupported input. We have utilities to try the compiler on Meta’s codebases and see what unsupported features are most common so we can prioritize those next. We’ll continue incrementally expanding towards supporting the whole language.',
  'Making plain JavaScript in React components reactive requires a compiler with a deep understanding of semantics so that it can understand exactly what the code is doing. By taking this approach, we’re creating a system for reactivity within JavaScript that lets you write product code of any complexity with the full expressivity of the language, instead of being limited to a domain specific language.',
  'Offscreen rendering is an upcoming capability in React for rendering screens in the background without additional performance overhead. You can think of it as a version of the content-visibility CSS property that works not only for DOM elements but React components, too. During our research, we’ve discovered a variety of use cases:',
  'Most React developers will not interact with React’s offscreen APIs directly. Instead, offscreen rendering will be integrated into things like routers and UI libraries, and then developers who use those libraries will automatically benefit without additional work.',
  'The idea is that you should be able to render any React tree offscreen without changing the way you write your components. When a component is rendered offscreen, it does not actually mount until the component becomes visible — its effects are not fired. For example, if a component uses useEffect to log analytics when it appears for the first time, prerendering won’t mess up the accuracy of those analytics. Similarly, when a component goes offscreen, its effects are unmounted, too. A key feature of offscreen rendering is that you can toggle the visibility of a component without losing its state.',
  'Since our last update, we’ve tested an experimental version of prerendering internally at Meta in our React Native apps on Android and iOS, with positive performance results. We’ve also improved how offscreen rendering works with Suspense — suspending inside an offscreen tree will not trigger Suspense fallbacks. Our remaining work involves finalizing the primitives that are exposed to library developers. We expect to publish an RFC later this year, alongside an experimental API for testing and feedback.',
  'The Transition Tracing API lets you detect when React Transitions become slower and investigate why they may be slow. Following our last update, we have completed the initial design of the API and published an RFC. The basic capabilities have also been implemented. The project is currently on hold. We welcome feedback on the RFC and look forward to resuming its development to provide a better performance measurement tool for React. This will be particularly useful with routers built on top of React Transitions, like the Next.js App Router.',
  'In addition to this update, our team has made recent guest appearances on community podcasts and livestreams to speak more on our work and answer questions.',
  'Thanks to Andrew Clark, Dan Abramov, Dave McCabe, Luna Wei, Matt Carroll, Sean Keegan, Sebastian Silbermann, Seth Webster, and Sophie Alpert for reviewing this post.',
  'Thanks for reading, and see you in the next update!',
  'How do you like these docs?'
]
URL:  https://react.dev/blog/2020/12/21/data-fetching-with-react-server-components
[
  'December 21, 2020 by Dan Abramov, Lauren Tan, Joseph Savona, and Sebastian Markbåge',
  '2020 has been a long year. As it comes to an end we wanted to share a special Holiday Update on our research into zero-bundle-size React Server Components.',
  'To introduce React Server Components, we have prepared a talk and a demo. If you want, you can check them out during the holidays, or later when work picks back up in the new year.',
  'React Server Components are still in research and development. We are sharing this work in the spirit of transparency and to get initial feedback from the React community. There will be plenty of time for that, so don’t feel like you have to catch up right now!',
  'If you want to check them out, we recommend going in the following order:',
  'Watch the talk to learn about React Server Components and see the demo.',
  'Clone the demo to play with React Server Components on your computer.',
  'Read the RFC (with FAQ at the end) for a deeper technical breakdown and to provide feedback.',
  'We are excited to hear from you on the RFC or in replies to the @reactjs Twitter handle. Happy holidays, stay safe, and see you next year!',
  'How do you like these docs?'
]
URL:  https://react.dev/blog/2022/06/15/react-labs-what-we-have-been-working-on-june-2022
[
  'June 15, 2022 by Andrew Clark, Dan Abramov, Jan Kassens, Joseph Savona, Josh Story, Lauren Tan, Luna Ruan, Mengdi Chen, Rick Hanlon, Robert Zhang, Sathya Gunasekaran, Sebastian Markbåge, and Xuan Huang',
  'React 18 was years in the making, and with it brought valuable lessons for the React team. Its release was the result of many years of research and exploring many paths. Some of those paths were successful; many more were dead-ends that led to new insights. One lesson we’ve learned is that it’s frustrating for the community to wait for new features without having insight into these paths that we’re exploring.',
  'We typically have a number of projects being worked on at any time, ranging from the more experimental to the clearly defined. Looking ahead, we’d like to start regularly sharing more about what we’ve been working on with the community across these projects.',
  'To set expectations, this is not a roadmap with clear timelines. Many of these projects are under active research and are difficult to put concrete ship dates on. They may possibly never even ship in their current iteration depending on what we learn. Instead, we want to share with you the problem spaces we’re actively thinking about, and what we’ve learned so far.',
  'We announced an experimental demo of React Server Components (RSC) in December 2020. Since then we’ve been finishing up its dependencies in React 18, and working on changes inspired by experimental feedback.',
  'In particular, we’re abandoning the idea of having forked I/O libraries (eg react-fetch), and instead adopting an async/await model for better compatibility. This doesn’t technically block RSC’s release because you can also use routers for data fetching. Another change is that we’re also moving away from the file extension approach in favor of annotating boundaries.',
  'We’re working together with Vercel and Shopify to unify bundler support for shared semantics in both Webpack and Vite. Before launch, we want to make sure that the semantics of RSCs are the same across the whole React ecosystem. This is the major blocker for reaching stable.',
  'Currently, assets like scripts, external styles, fonts, and images are typically preloaded and loaded using external systems. This can make it tricky to coordinate across new environments like streaming, Server Components, and more.\n' +
    'We’re looking at adding APIs to preload and load deduplicated external assets through React APIs that work in all React environments.',
  'We’re also looking at having these support Suspense so you can have images, CSS, and fonts that block display until they’re loaded but don’t block streaming and concurrent rendering. This can help avoid “popcorning“ as the visuals pop and layout shifts.',
  'Static Site Generation (SSG) and Incremental Static Regeneration (ISR) are great ways to get performance for cacheable pages, but we think we can add features to improve performance of dynamic Server Side Rendering (SSR) – especially when most but not all of the content is cacheable. We’re exploring ways to optimize server rendering utilizing compilation and static passes.',
  'We gave an early preview of React Forget at React Conf 2021. It’s a compiler that automatically generates the equivalent of useMemo and useCallback calls to minimize the cost of re-rendering, while retaining React’s programming model.',
  'Recently, we finished a rewrite of the compiler to make it more reliable and capable. This new architecture allows us to analyze and memoize more complex patterns such as the use of local mutations, and opens up many new compile-time optimization opportunities beyond just being on par with memoization Hooks.',
  'We’re also working on a playground for exploring many aspects of the compiler. While the goal of the playground is to make development of the compiler easier, we think that it will make it easier to try it out and build intuition for what the compiler does. It reveals various insights into how it works under the hood, and live renders the compiler’s outputs as you type. This will be shipped together with the compiler when it’s released.',
  'Today, if you want to hide and show a component, you have two options. One is to add or remove it from the tree completely. The problem with this approach is that the state of your UI is lost each time you unmount, including state stored in the DOM, like scroll position.',
  'The other option is to keep the component mounted and toggle the appearance visually using CSS. This preserves the state of your UI, but it comes at a performance cost, because React must keep rendering the hidden component and all of its children whenever it receives new updates.',
  'Offscreen introduces a third option: hide the UI visually, but deprioritize its content. The idea is similar in spirit to the content-visibility CSS property: when content is hidden, it doesn’t need to stay in sync with the rest of the UI. React can defer the rendering work until the rest of the app is idle, or until the content becomes visible again.',
  'Offscreen is a low level capability that unlocks high level features. Similar to React’s other concurrent features like startTransition, in most cases you won’t interact with the Offscreen API directly, but instead via an opinionated framework to implement patterns like:',
  'Currently, React has two profiling tools. The original Profiler shows an overview of all the commits in a profiling session. For each commit, it also shows all components that rendered and the amount of time it took for them to render. We also have a beta version of a Timeline Profiler introduced in React 18 that shows when components schedule updates and when React works on these updates. Both of these profilers help developers identify performance problems in their code.',
  'We’ve realized that developers don’t find knowing about individual slow commits or components out of context that useful. It’s more useful to know about what actually causes the slow commits. And that developers want to be able to track specific interactions (eg a button click, an initial load, or a page navigation) to watch for performance regressions and to understand why an interaction was slow and how to fix it.',
  'We previously tried to solve this issue by creating an Interaction Tracing API, but it had some fundamental design flaws that reduced the accuracy of tracking why an interaction was slow and sometimes resulted in interactions never ending. We ended up removing this API because of these issues.',
  'We are working on a new version for the Interaction Tracing API (tentatively called Transition Tracing because it is initiated via startTransition) that solves these problems.',
  'Last year, we announced the beta version of the new React documentation website (later shipped as react.dev) of the new React documentation website. The new learning materials teach Hooks first and has new diagrams, illustrations, as well as many interactive examples and challenges. We took a break from that work to focus on the React 18 release, but now that React 18 is out, we’re actively working to finish and ship the new documentation.',
  'We are currently writing a detailed section about effects, as we’ve heard that is one of the more challenging topics for both new and experienced React users. Synchronizing with Effects is the first published page in the series, and there are more to come in the following weeks. When we first started writing a detailed section about effects, we’ve realized that many common effect patterns can be simplified by adding a new primitive to React. We’ve shared some initial thoughts on that in the useEvent RFC. It is currently in early research, and we are still iterating on the idea. We appreciate the community’s comments on the RFC so far, as well as the feedback and contributions to the ongoing documentation rewrite. We’d specifically like to thank Harish Kumar for submitting and reviewing many improvements to the new website implementation.',
  'Thanks to Sophie Alpert for reviewing this blog post!',
  'How do you like these docs?'
]
URL:  https://react.dev/reference/react/experimental_useEffectEvent
[
  'Is this page useful?',
  'This API is experimental and is not available in a stable version of React yet.',
  'You can try it by upgrading React packages to the most recent experimental version:',
  'Experimental versions of React may contain bugs. Don’t use them in production.',
  'useEffectEvent is a React Hook that lets you extract non-reactive logic into an Effect Event.',
  'How do you like these docs?'
]
